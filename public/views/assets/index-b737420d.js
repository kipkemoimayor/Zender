var px = Object.defineProperty
var yx = (e, t, n) =>
  t in e ? px(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)
var ke = (e, t, n) => (yx(e, typeof t != 'symbol' ? t + '' : t, n), n)
;(function () {
  const t = document.createElement('link').relList
  if (t && t.supports && t.supports('modulepreload')) return
  for (const a of document.querySelectorAll('link[rel="modulepreload"]')) i(a)
  new MutationObserver((a) => {
    for (const s of a)
      if (s.type === 'childList')
        for (const o of s.addedNodes) o.tagName === 'LINK' && o.rel === 'modulepreload' && i(o)
  }).observe(document, { childList: !0, subtree: !0 })
  function n(a) {
    const s = {}
    return (
      a.integrity && (s.integrity = a.integrity),
      a.referrerPolicy && (s.referrerPolicy = a.referrerPolicy),
      a.crossOrigin === 'use-credentials'
        ? (s.credentials = 'include')
        : a.crossOrigin === 'anonymous'
        ? (s.credentials = 'omit')
        : (s.credentials = 'same-origin'),
      s
    )
  }
  function i(a) {
    if (a.ep) return
    a.ep = !0
    const s = n(a)
    fetch(a.href, s)
  }
})()
function cf(e, t) {
  const n = Object.create(null),
    i = e.split(',')
  for (let a = 0; a < i.length; a++) n[i[a]] = !0
  return t ? (a) => !!n[a.toLowerCase()] : (a) => !!n[a]
}
const _t = {},
  zs = [],
  ri = () => {},
  bx = () => !1,
  _x = /^on[^a-z]/,
  kc = (e) => _x.test(e),
  uf = (e) => e.startsWith('onUpdate:'),
  Nt = Object.assign,
  df = (e, t) => {
    const n = e.indexOf(t)
    n > -1 && e.splice(n, 1)
  },
  xx = Object.prototype.hasOwnProperty,
  rt = (e, t) => xx.call(e, t),
  We = Array.isArray,
  Hs = (e) => Cc(e) === '[object Map]',
  Bp = (e) => Cc(e) === '[object Set]',
  Je = (e) => typeof e == 'function',
  Ft = (e) => typeof e == 'string',
  ff = (e) => typeof e == 'symbol',
  bt = (e) => e !== null && typeof e == 'object',
  Np = (e) => bt(e) && Je(e.then) && Je(e.catch),
  $p = Object.prototype.toString,
  Cc = (e) => $p.call(e),
  wx = (e) => Cc(e).slice(8, -1),
  zp = (e) => Cc(e) === '[object Object]',
  hf = (e) => Ft(e) && e !== 'NaN' && e[0] !== '-' && '' + parseInt(e, 10) === e,
  Il = cf(
    ',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'
  ),
  Mc = (e) => {
    const t = Object.create(null)
    return (n) => t[n] || (t[n] = e(n))
  },
  Sx = /-(\w)/g,
  Yn = Mc((e) => e.replace(Sx, (t, n) => (n ? n.toUpperCase() : ''))),
  kx = /\B([A-Z])/g,
  oo = Mc((e) => e.replace(kx, '-$1').toLowerCase()),
  na = Mc((e) => e.charAt(0).toUpperCase() + e.slice(1)),
  du = Mc((e) => (e ? `on${na(e)}` : '')),
  fr = (e, t) => !Object.is(e, t),
  Dl = (e, t) => {
    for (let n = 0; n < e.length; n++) e[n](t)
  },
  Zl = (e, t, n) => {
    Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: n })
  },
  Gu = (e) => {
    const t = parseFloat(e)
    return isNaN(t) ? e : t
  },
  Cx = (e) => {
    const t = Ft(e) ? Number(e) : NaN
    return isNaN(t) ? e : t
  }
let Uh
const Xu = () =>
  Uh ||
  (Uh =
    typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
      ? self
      : typeof window < 'u'
      ? window
      : typeof global < 'u'
      ? global
      : {})
function vf(e) {
  if (We(e)) {
    const t = {}
    for (let n = 0; n < e.length; n++) {
      const i = e[n],
        a = Ft(i) ? Tx(i) : vf(i)
      if (a) for (const s in a) t[s] = a[s]
    }
    return t
  } else {
    if (Ft(e)) return e
    if (bt(e)) return e
  }
}
const Mx = /;(?![^(]*\))/g,
  Ax = /:([^]+)/,
  Px = /\/\*[^]*?\*\//g
function Tx(e) {
  const t = {}
  return (
    e
      .replace(Px, '')
      .split(Mx)
      .forEach((n) => {
        if (n) {
          const i = n.split(Ax)
          i.length > 1 && (t[i[0].trim()] = i[1].trim())
        }
      }),
    t
  )
}
function ki(e) {
  let t = ''
  if (Ft(e)) t = e
  else if (We(e))
    for (let n = 0; n < e.length; n++) {
      const i = ki(e[n])
      i && (t += i + ' ')
    }
  else if (bt(e)) for (const n in e) e[n] && (t += n + ' ')
  return t.trim()
}
const Vx = 'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
  Ex = cf(Vx)
function Hp(e) {
  return !!e || e === ''
}
const ze = (e) =>
    Ft(e)
      ? e
      : e == null
      ? ''
      : We(e) || (bt(e) && (e.toString === $p || !Je(e.toString)))
      ? JSON.stringify(e, Wp, 2)
      : String(e),
  Wp = (e, t) =>
    t && t.__v_isRef
      ? Wp(e, t.value)
      : Hs(t)
      ? { [`Map(${t.size})`]: [...t.entries()].reduce((n, [i, a]) => ((n[`${i} =>`] = a), n), {}) }
      : Bp(t)
      ? { [`Set(${t.size})`]: [...t.values()] }
      : bt(t) && !We(t) && !zp(t)
      ? String(t)
      : t
let Vn
class jp {
  constructor(t = !1) {
    ;(this.detached = t),
      (this._active = !0),
      (this.effects = []),
      (this.cleanups = []),
      (this.parent = Vn),
      !t && Vn && (this.index = (Vn.scopes || (Vn.scopes = [])).push(this) - 1)
  }
  get active() {
    return this._active
  }
  run(t) {
    if (this._active) {
      const n = Vn
      try {
        return (Vn = this), t()
      } finally {
        Vn = n
      }
    }
  }
  on() {
    Vn = this
  }
  off() {
    Vn = this.parent
  }
  stop(t) {
    if (this._active) {
      let n, i
      for (n = 0, i = this.effects.length; n < i; n++) this.effects[n].stop()
      for (n = 0, i = this.cleanups.length; n < i; n++) this.cleanups[n]()
      if (this.scopes) for (n = 0, i = this.scopes.length; n < i; n++) this.scopes[n].stop(!0)
      if (!this.detached && this.parent && !t) {
        const a = this.parent.scopes.pop()
        a && a !== this && ((this.parent.scopes[this.index] = a), (a.index = this.index))
      }
      ;(this.parent = void 0), (this._active = !1)
    }
  }
}
function Ac(e) {
  return new jp(e)
}
function Lx(e, t = Vn) {
  t && t.active && t.effects.push(e)
}
function Ox() {
  return Vn
}
function Mn(e) {
  Vn && Vn.cleanups.push(e)
}
const gf = (e) => {
    const t = new Set(e)
    return (t.w = 0), (t.n = 0), t
  },
  Up = (e) => (e.w & Ma) > 0,
  Yp = (e) => (e.n & Ma) > 0,
  Ix = ({ deps: e }) => {
    if (e.length) for (let t = 0; t < e.length; t++) e[t].w |= Ma
  },
  Dx = (e) => {
    const { deps: t } = e
    if (t.length) {
      let n = 0
      for (let i = 0; i < t.length; i++) {
        const a = t[i]
        Up(a) && !Yp(a) ? a.delete(e) : (t[n++] = a), (a.w &= ~Ma), (a.n &= ~Ma)
      }
      t.length = n
    }
  },
  Jl = new WeakMap()
let $o = 0,
  Ma = 1
const Ku = 30
let ei
const ss = Symbol(''),
  qu = Symbol('')
class mf {
  constructor(t, n = null, i) {
    ;(this.fn = t),
      (this.scheduler = n),
      (this.active = !0),
      (this.deps = []),
      (this.parent = void 0),
      Lx(this, i)
  }
  run() {
    if (!this.active) return this.fn()
    let t = ei,
      n = Sa
    for (; t; ) {
      if (t === this) return
      t = t.parent
    }
    try {
      return (
        (this.parent = ei),
        (ei = this),
        (Sa = !0),
        (Ma = 1 << ++$o),
        $o <= Ku ? Ix(this) : Yh(this),
        this.fn()
      )
    } finally {
      $o <= Ku && Dx(this),
        (Ma = 1 << --$o),
        (ei = this.parent),
        (Sa = n),
        (this.parent = void 0),
        this.deferStop && this.stop()
    }
  }
  stop() {
    ei === this
      ? (this.deferStop = !0)
      : this.active && (Yh(this), this.onStop && this.onStop(), (this.active = !1))
  }
}
function Yh(e) {
  const { deps: t } = e
  if (t.length) {
    for (let n = 0; n < t.length; n++) t[n].delete(e)
    t.length = 0
  }
}
let Sa = !0
const Gp = []
function ro() {
  Gp.push(Sa), (Sa = !1)
}
function lo() {
  const e = Gp.pop()
  Sa = e === void 0 ? !0 : e
}
function An(e, t, n) {
  if (Sa && ei) {
    let i = Jl.get(e)
    i || Jl.set(e, (i = new Map()))
    let a = i.get(n)
    a || i.set(n, (a = gf())), Xp(a)
  }
}
function Xp(e, t) {
  let n = !1
  $o <= Ku ? Yp(e) || ((e.n |= Ma), (n = !Up(e))) : (n = !e.has(ei)), n && (e.add(ei), ei.deps.push(e))
}
function qi(e, t, n, i, a, s) {
  const o = Jl.get(e)
  if (!o) return
  let r = []
  if (t === 'clear') r = [...o.values()]
  else if (n === 'length' && We(e)) {
    const l = Number(i)
    o.forEach((c, u) => {
      ;(u === 'length' || u >= l) && r.push(c)
    })
  } else
    switch ((n !== void 0 && r.push(o.get(n)), t)) {
      case 'add':
        We(e) ? hf(n) && r.push(o.get('length')) : (r.push(o.get(ss)), Hs(e) && r.push(o.get(qu)))
        break
      case 'delete':
        We(e) || (r.push(o.get(ss)), Hs(e) && r.push(o.get(qu)))
        break
      case 'set':
        Hs(e) && r.push(o.get(ss))
        break
    }
  if (r.length === 1) r[0] && Zu(r[0])
  else {
    const l = []
    for (const c of r) c && l.push(...c)
    Zu(gf(l))
  }
}
function Zu(e, t) {
  const n = We(e) ? e : [...e]
  for (const i of n) i.computed && Gh(i)
  for (const i of n) i.computed || Gh(i)
}
function Gh(e, t) {
  ;(e !== ei || e.allowRecurse) && (e.scheduler ? e.scheduler() : e.run())
}
function Fx(e, t) {
  var n
  return (n = Jl.get(e)) == null ? void 0 : n.get(t)
}
const Rx = cf('__proto__,__v_isRef,__isVue'),
  Kp = new Set(
    Object.getOwnPropertyNames(Symbol)
      .filter((e) => e !== 'arguments' && e !== 'caller')
      .map((e) => Symbol[e])
      .filter(ff)
  ),
  Bx = pf(),
  Nx = pf(!1, !0),
  $x = pf(!0),
  Xh = zx()
function zx() {
  const e = {}
  return (
    ['includes', 'indexOf', 'lastIndexOf'].forEach((t) => {
      e[t] = function (...n) {
        const i = Qe(this)
        for (let s = 0, o = this.length; s < o; s++) An(i, 'get', s + '')
        const a = i[t](...n)
        return a === -1 || a === !1 ? i[t](...n.map(Qe)) : a
      }
    }),
    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach((t) => {
      e[t] = function (...n) {
        ro()
        const i = Qe(this)[t].apply(this, n)
        return lo(), i
      }
    }),
    e
  )
}
function Hx(e) {
  const t = Qe(this)
  return An(t, 'has', e), t.hasOwnProperty(e)
}
function pf(e = !1, t = !1) {
  return function (i, a, s) {
    if (a === '__v_isReactive') return !e
    if (a === '__v_isReadonly') return e
    if (a === '__v_isShallow') return t
    if (a === '__v_raw' && s === (e ? (t ? aw : e0) : t ? Qp : Jp).get(i)) return i
    const o = We(i)
    if (!e) {
      if (o && rt(Xh, a)) return Reflect.get(Xh, a, s)
      if (a === 'hasOwnProperty') return Hx
    }
    const r = Reflect.get(i, a, s)
    return (ff(a) ? Kp.has(a) : Rx(a)) || (e || An(i, 'get', a), t)
      ? r
      : Tt(r)
      ? o && hf(a)
        ? r
        : r.value
      : bt(r)
      ? e
        ? $r(r)
        : yn(r)
      : r
  }
}
const Wx = qp(),
  jx = qp(!0)
function qp(e = !1) {
  return function (n, i, a, s) {
    let o = n[i]
    if (Xs(o) && Tt(o) && !Tt(a)) return !1
    if (!e && (!Ql(a) && !Xs(a) && ((o = Qe(o)), (a = Qe(a))), !We(n) && Tt(o) && !Tt(a)))
      return (o.value = a), !0
    const r = We(n) && hf(i) ? Number(i) < n.length : rt(n, i),
      l = Reflect.set(n, i, a, s)
    return n === Qe(s) && (r ? fr(a, o) && qi(n, 'set', i, a) : qi(n, 'add', i, a)), l
  }
}
function Ux(e, t) {
  const n = rt(e, t)
  e[t]
  const i = Reflect.deleteProperty(e, t)
  return i && n && qi(e, 'delete', t, void 0), i
}
function Yx(e, t) {
  const n = Reflect.has(e, t)
  return (!ff(t) || !Kp.has(t)) && An(e, 'has', t), n
}
function Gx(e) {
  return An(e, 'iterate', We(e) ? 'length' : ss), Reflect.ownKeys(e)
}
const Zp = { get: Bx, set: Wx, deleteProperty: Ux, has: Yx, ownKeys: Gx },
  Xx = {
    get: $x,
    set(e, t) {
      return !0
    },
    deleteProperty(e, t) {
      return !0
    }
  },
  Kx = Nt({}, Zp, { get: Nx, set: jx }),
  yf = (e) => e,
  Pc = (e) => Reflect.getPrototypeOf(e)
function nl(e, t, n = !1, i = !1) {
  e = e.__v_raw
  const a = Qe(e),
    s = Qe(t)
  n || (t !== s && An(a, 'get', t), An(a, 'get', s))
  const { has: o } = Pc(a),
    r = i ? yf : n ? wf : hr
  if (o.call(a, t)) return r(e.get(t))
  if (o.call(a, s)) return r(e.get(s))
  e !== a && e.get(t)
}
function il(e, t = !1) {
  const n = this.__v_raw,
    i = Qe(n),
    a = Qe(e)
  return t || (e !== a && An(i, 'has', e), An(i, 'has', a)), e === a ? n.has(e) : n.has(e) || n.has(a)
}
function al(e, t = !1) {
  return (e = e.__v_raw), !t && An(Qe(e), 'iterate', ss), Reflect.get(e, 'size', e)
}
function Kh(e) {
  e = Qe(e)
  const t = Qe(this)
  return Pc(t).has.call(t, e) || (t.add(e), qi(t, 'add', e, e)), this
}
function qh(e, t) {
  t = Qe(t)
  const n = Qe(this),
    { has: i, get: a } = Pc(n)
  let s = i.call(n, e)
  s || ((e = Qe(e)), (s = i.call(n, e)))
  const o = a.call(n, e)
  return n.set(e, t), s ? fr(t, o) && qi(n, 'set', e, t) : qi(n, 'add', e, t), this
}
function Zh(e) {
  const t = Qe(this),
    { has: n, get: i } = Pc(t)
  let a = n.call(t, e)
  a || ((e = Qe(e)), (a = n.call(t, e))), i && i.call(t, e)
  const s = t.delete(e)
  return a && qi(t, 'delete', e, void 0), s
}
function Jh() {
  const e = Qe(this),
    t = e.size !== 0,
    n = e.clear()
  return t && qi(e, 'clear', void 0, void 0), n
}
function sl(e, t) {
  return function (i, a) {
    const s = this,
      o = s.__v_raw,
      r = Qe(o),
      l = t ? yf : e ? wf : hr
    return !e && An(r, 'iterate', ss), o.forEach((c, u) => i.call(a, l(c), l(u), s))
  }
}
function ol(e, t, n) {
  return function (...i) {
    const a = this.__v_raw,
      s = Qe(a),
      o = Hs(s),
      r = e === 'entries' || (e === Symbol.iterator && o),
      l = e === 'keys' && o,
      c = a[e](...i),
      u = n ? yf : t ? wf : hr
    return (
      !t && An(s, 'iterate', l ? qu : ss),
      {
        next() {
          const { value: d, done: f } = c.next()
          return f ? { value: d, done: f } : { value: r ? [u(d[0]), u(d[1])] : u(d), done: f }
        },
        [Symbol.iterator]() {
          return this
        }
      }
    )
  }
}
function ua(e) {
  return function (...t) {
    return e === 'delete' ? !1 : this
  }
}
function qx() {
  const e = {
      get(s) {
        return nl(this, s)
      },
      get size() {
        return al(this)
      },
      has: il,
      add: Kh,
      set: qh,
      delete: Zh,
      clear: Jh,
      forEach: sl(!1, !1)
    },
    t = {
      get(s) {
        return nl(this, s, !1, !0)
      },
      get size() {
        return al(this)
      },
      has: il,
      add: Kh,
      set: qh,
      delete: Zh,
      clear: Jh,
      forEach: sl(!1, !0)
    },
    n = {
      get(s) {
        return nl(this, s, !0)
      },
      get size() {
        return al(this, !0)
      },
      has(s) {
        return il.call(this, s, !0)
      },
      add: ua('add'),
      set: ua('set'),
      delete: ua('delete'),
      clear: ua('clear'),
      forEach: sl(!0, !1)
    },
    i = {
      get(s) {
        return nl(this, s, !0, !0)
      },
      get size() {
        return al(this, !0)
      },
      has(s) {
        return il.call(this, s, !0)
      },
      add: ua('add'),
      set: ua('set'),
      delete: ua('delete'),
      clear: ua('clear'),
      forEach: sl(!0, !0)
    }
  return (
    ['keys', 'values', 'entries', Symbol.iterator].forEach((s) => {
      ;(e[s] = ol(s, !1, !1)), (n[s] = ol(s, !0, !1)), (t[s] = ol(s, !1, !0)), (i[s] = ol(s, !0, !0))
    }),
    [e, n, t, i]
  )
}
const [Zx, Jx, Qx, ew] = qx()
function bf(e, t) {
  const n = t ? (e ? ew : Qx) : e ? Jx : Zx
  return (i, a, s) =>
    a === '__v_isReactive'
      ? !e
      : a === '__v_isReadonly'
      ? e
      : a === '__v_raw'
      ? i
      : Reflect.get(rt(n, a) && a in i ? n : i, a, s)
}
const tw = { get: bf(!1, !1) },
  nw = { get: bf(!1, !0) },
  iw = { get: bf(!0, !1) },
  Jp = new WeakMap(),
  Qp = new WeakMap(),
  e0 = new WeakMap(),
  aw = new WeakMap()
function sw(e) {
  switch (e) {
    case 'Object':
    case 'Array':
      return 1
    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return 2
    default:
      return 0
  }
}
function ow(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : sw(wx(e))
}
function yn(e) {
  return Xs(e) ? e : _f(e, !1, Zp, tw, Jp)
}
function t0(e) {
  return _f(e, !1, Kx, nw, Qp)
}
function $r(e) {
  return _f(e, !0, Xx, iw, e0)
}
function _f(e, t, n, i, a) {
  if (!bt(e) || (e.__v_raw && !(t && e.__v_isReactive))) return e
  const s = a.get(e)
  if (s) return s
  const o = ow(e)
  if (o === 0) return e
  const r = new Proxy(e, o === 2 ? i : n)
  return a.set(e, r), r
}
function Ws(e) {
  return Xs(e) ? Ws(e.__v_raw) : !!(e && e.__v_isReactive)
}
function Xs(e) {
  return !!(e && e.__v_isReadonly)
}
function Ql(e) {
  return !!(e && e.__v_isShallow)
}
function n0(e) {
  return Ws(e) || Xs(e)
}
function Qe(e) {
  const t = e && e.__v_raw
  return t ? Qe(t) : e
}
function xf(e) {
  return Zl(e, '__v_skip', !0), e
}
const hr = (e) => (bt(e) ? yn(e) : e),
  wf = (e) => (bt(e) ? $r(e) : e)
function i0(e) {
  Sa && ei && ((e = Qe(e)), Xp(e.dep || (e.dep = gf())))
}
function a0(e, t) {
  e = Qe(e)
  const n = e.dep
  n && Zu(n)
}
function Tt(e) {
  return !!(e && e.__v_isRef === !0)
}
function te(e) {
  return s0(e, !1)
}
function Ce(e) {
  return s0(e, !0)
}
function s0(e, t) {
  return Tt(e) ? e : new rw(e, t)
}
class rw {
  constructor(t, n) {
    ;(this.__v_isShallow = n),
      (this.dep = void 0),
      (this.__v_isRef = !0),
      (this._rawValue = n ? t : Qe(t)),
      (this._value = n ? t : hr(t))
  }
  get value() {
    return i0(this), this._value
  }
  set value(t) {
    const n = this.__v_isShallow || Ql(t) || Xs(t)
    ;(t = n ? t : Qe(t)),
      fr(t, this._rawValue) && ((this._rawValue = t), (this._value = n ? t : hr(t)), a0(this))
  }
}
function Xe(e) {
  return Tt(e) ? e.value : e
}
const lw = {
  get: (e, t, n) => Xe(Reflect.get(e, t, n)),
  set: (e, t, n, i) => {
    const a = e[t]
    return Tt(a) && !Tt(n) ? ((a.value = n), !0) : Reflect.set(e, t, n, i)
  }
}
function o0(e) {
  return Ws(e) ? e : new Proxy(e, lw)
}
function Sf(e) {
  const t = We(e) ? new Array(e.length) : {}
  for (const n in e) t[n] = r0(e, n)
  return t
}
class cw {
  constructor(t, n, i) {
    ;(this._object = t), (this._key = n), (this._defaultValue = i), (this.__v_isRef = !0)
  }
  get value() {
    const t = this._object[this._key]
    return t === void 0 ? this._defaultValue : t
  }
  set value(t) {
    this._object[this._key] = t
  }
  get dep() {
    return Fx(Qe(this._object), this._key)
  }
}
class uw {
  constructor(t) {
    ;(this._getter = t), (this.__v_isRef = !0), (this.__v_isReadonly = !0)
  }
  get value() {
    return this._getter()
  }
}
function ve(e, t, n) {
  return Tt(e) ? e : Je(e) ? new uw(e) : bt(e) && arguments.length > 1 ? r0(e, t, n) : te(e)
}
function r0(e, t, n) {
  const i = e[t]
  return Tt(i) ? i : new cw(e, t, n)
}
class dw {
  constructor(t, n, i, a) {
    ;(this._setter = n),
      (this.dep = void 0),
      (this.__v_isRef = !0),
      (this.__v_isReadonly = !1),
      (this._dirty = !0),
      (this.effect = new mf(t, () => {
        this._dirty || ((this._dirty = !0), a0(this))
      })),
      (this.effect.computed = this),
      (this.effect.active = this._cacheable = !a),
      (this.__v_isReadonly = i)
  }
  get value() {
    const t = Qe(this)
    return i0(t), (t._dirty || !t._cacheable) && ((t._dirty = !1), (t._value = t.effect.run())), t._value
  }
  set value(t) {
    this._setter(t)
  }
}
function fw(e, t, n = !1) {
  let i, a
  const s = Je(e)
  return s ? ((i = e), (a = ri)) : ((i = e.get), (a = e.set)), new dw(i, a, s || !a, n)
}
function ka(e, t, n, i) {
  let a
  try {
    a = i ? e(...i) : e()
  } catch (s) {
    Tc(s, t, n)
  }
  return a
}
function Un(e, t, n, i) {
  if (Je(e)) {
    const s = ka(e, t, n, i)
    return (
      s &&
        Np(s) &&
        s.catch((o) => {
          Tc(o, t, n)
        }),
      s
    )
  }
  const a = []
  for (let s = 0; s < e.length; s++) a.push(Un(e[s], t, n, i))
  return a
}
function Tc(e, t, n, i = !0) {
  const a = t ? t.vnode : null
  if (t) {
    let s = t.parent
    const o = t.proxy,
      r = n
    for (; s; ) {
      const c = s.ec
      if (c) {
        for (let u = 0; u < c.length; u++) if (c[u](e, o, r) === !1) return
      }
      s = s.parent
    }
    const l = t.appContext.config.errorHandler
    if (l) {
      ka(l, null, 10, [e, o, r])
      return
    }
  }
  hw(e, n, a, i)
}
function hw(e, t, n, i = !0) {
  console.error(e)
}
let vr = !1,
  Ju = !1
const ln = []
let wi = 0
const js = []
let Hi = null,
  Za = 0
const l0 = Promise.resolve()
let kf = null
function mt(e) {
  const t = kf || l0
  return e ? t.then(this ? e.bind(this) : e) : t
}
function vw(e) {
  let t = wi + 1,
    n = ln.length
  for (; t < n; ) {
    const i = (t + n) >>> 1
    gr(ln[i]) < e ? (t = i + 1) : (n = i)
  }
  return t
}
function Cf(e) {
  ;(!ln.length || !ln.includes(e, vr && e.allowRecurse ? wi + 1 : wi)) &&
    (e.id == null ? ln.push(e) : ln.splice(vw(e.id), 0, e), c0())
}
function c0() {
  !vr && !Ju && ((Ju = !0), (kf = l0.then(d0)))
}
function gw(e) {
  const t = ln.indexOf(e)
  t > wi && ln.splice(t, 1)
}
function mw(e) {
  We(e) ? js.push(...e) : (!Hi || !Hi.includes(e, e.allowRecurse ? Za + 1 : Za)) && js.push(e), c0()
}
function Qh(e, t = vr ? wi + 1 : 0) {
  for (; t < ln.length; t++) {
    const n = ln[t]
    n && n.pre && (ln.splice(t, 1), t--, n())
  }
}
function u0(e) {
  if (js.length) {
    const t = [...new Set(js)]
    if (((js.length = 0), Hi)) {
      Hi.push(...t)
      return
    }
    for (Hi = t, Hi.sort((n, i) => gr(n) - gr(i)), Za = 0; Za < Hi.length; Za++) Hi[Za]()
    ;(Hi = null), (Za = 0)
  }
}
const gr = (e) => (e.id == null ? 1 / 0 : e.id),
  pw = (e, t) => {
    const n = gr(e) - gr(t)
    if (n === 0) {
      if (e.pre && !t.pre) return -1
      if (t.pre && !e.pre) return 1
    }
    return n
  }
function d0(e) {
  ;(Ju = !1), (vr = !0), ln.sort(pw)
  const t = ri
  try {
    for (wi = 0; wi < ln.length; wi++) {
      const n = ln[wi]
      n && n.active !== !1 && ka(n, null, 14)
    }
  } finally {
    ;(wi = 0), (ln.length = 0), u0(), (vr = !1), (kf = null), (ln.length || js.length) && d0()
  }
}
function yw(e, t, ...n) {
  if (e.isUnmounted) return
  const i = e.vnode.props || _t
  let a = n
  const s = t.startsWith('update:'),
    o = s && t.slice(7)
  if (o && o in i) {
    const u = `${o === 'modelValue' ? 'model' : o}Modifiers`,
      { number: d, trim: f } = i[u] || _t
    f && (a = n.map((h) => (Ft(h) ? h.trim() : h))), d && (a = n.map(Gu))
  }
  let r,
    l = i[(r = du(t))] || i[(r = du(Yn(t)))]
  !l && s && (l = i[(r = du(oo(t)))]), l && Un(l, e, 6, a)
  const c = i[r + 'Once']
  if (c) {
    if (!e.emitted) e.emitted = {}
    else if (e.emitted[r]) return
    ;(e.emitted[r] = !0), Un(c, e, 6, a)
  }
}
function f0(e, t, n = !1) {
  const i = t.emitsCache,
    a = i.get(e)
  if (a !== void 0) return a
  const s = e.emits
  let o = {},
    r = !1
  if (!Je(e)) {
    const l = (c) => {
      const u = f0(c, t, !0)
      u && ((r = !0), Nt(o, u))
    }
    !n && t.mixins.length && t.mixins.forEach(l), e.extends && l(e.extends), e.mixins && e.mixins.forEach(l)
  }
  return !s && !r
    ? (bt(e) && i.set(e, null), null)
    : (We(s) ? s.forEach((l) => (o[l] = null)) : Nt(o, s), bt(e) && i.set(e, o), o)
}
function Vc(e, t) {
  return !e || !kc(t)
    ? !1
    : ((t = t.slice(2).replace(/Once$/, '')),
      rt(e, t[0].toLowerCase() + t.slice(1)) || rt(e, oo(t)) || rt(e, t))
}
let In = null,
  Ec = null
function ec(e) {
  const t = In
  return (In = e), (Ec = (e && e.type.__scopeId) || null), t
}
function Ea(e) {
  Ec = e
}
function La() {
  Ec = null
}
function we(e, t = In, n) {
  if (!t || e._n) return e
  const i = (...a) => {
    i._d && fv(-1)
    const s = ec(t)
    let o
    try {
      o = e(...a)
    } finally {
      ec(s), i._d && fv(1)
    }
    return o
  }
  return (i._n = !0), (i._c = !0), (i._d = !0), i
}
function fu(e) {
  const {
    type: t,
    vnode: n,
    proxy: i,
    withProxy: a,
    props: s,
    propsOptions: [o],
    slots: r,
    attrs: l,
    emit: c,
    render: u,
    renderCache: d,
    data: f,
    setupState: h,
    ctx: v,
    inheritAttrs: g
  } = e
  let p, y
  const b = ec(e)
  try {
    if (n.shapeFlag & 4) {
      const w = a || i
      ;(p = _i(u.call(w, w, d, s, h, f, v))), (y = l)
    } else {
      const w = t
      ;(p = _i(w.length > 1 ? w(s, { attrs: l, slots: r, emit: c }) : w(s, null))), (y = t.props ? l : bw(l))
    }
  } catch (w) {
    ;(Qo.length = 0), Tc(w, e, 1), (p = m(li))
  }
  let x = p
  if (y && g !== !1) {
    const w = Object.keys(y),
      { shapeFlag: C } = x
    w.length && C & 7 && (o && w.some(uf) && (y = _w(y, o)), (x = Zi(x, y)))
  }
  return (
    n.dirs && ((x = Zi(x)), (x.dirs = x.dirs ? x.dirs.concat(n.dirs) : n.dirs)),
    n.transition && (x.transition = n.transition),
    (p = x),
    ec(b),
    p
  )
}
const bw = (e) => {
    let t
    for (const n in e) (n === 'class' || n === 'style' || kc(n)) && ((t || (t = {}))[n] = e[n])
    return t
  },
  _w = (e, t) => {
    const n = {}
    for (const i in e) (!uf(i) || !(i.slice(9) in t)) && (n[i] = e[i])
    return n
  }
function xw(e, t, n) {
  const { props: i, children: a, component: s } = e,
    { props: o, children: r, patchFlag: l } = t,
    c = s.emitsOptions
  if (t.dirs || t.transition) return !0
  if (n && l >= 0) {
    if (l & 1024) return !0
    if (l & 16) return i ? ev(i, o, c) : !!o
    if (l & 8) {
      const u = t.dynamicProps
      for (let d = 0; d < u.length; d++) {
        const f = u[d]
        if (o[f] !== i[f] && !Vc(c, f)) return !0
      }
    }
  } else return (a || r) && (!r || !r.$stable) ? !0 : i === o ? !1 : i ? (o ? ev(i, o, c) : !0) : !!o
  return !1
}
function ev(e, t, n) {
  const i = Object.keys(t)
  if (i.length !== Object.keys(e).length) return !0
  for (let a = 0; a < i.length; a++) {
    const s = i[a]
    if (t[s] !== e[s] && !Vc(n, s)) return !0
  }
  return !1
}
function ww({ vnode: e, parent: t }, n) {
  for (; t && t.subTree === e; ) ((e = t.vnode).el = n), (t = t.parent)
}
const Sw = (e) => e.__isSuspense
function kw(e, t) {
  t && t.pendingBranch ? (We(e) ? t.effects.push(...e) : t.effects.push(e)) : mw(e)
}
function Ut(e, t) {
  return Mf(e, null, t)
}
const rl = {}
function Pe(e, t, n) {
  return Mf(e, t, n)
}
function Mf(e, t, { immediate: n, deep: i, flush: a, onTrack: s, onTrigger: o } = _t) {
  var r
  const l = Ox() === ((r = Kt) == null ? void 0 : r.scope) ? Kt : null
  let c,
    u = !1,
    d = !1
  if (
    (Tt(e)
      ? ((c = () => e.value), (u = Ql(e)))
      : Ws(e)
      ? ((c = () => e), (i = !0))
      : We(e)
      ? ((d = !0),
        (u = e.some((w) => Ws(w) || Ql(w))),
        (c = () =>
          e.map((w) => {
            if (Tt(w)) return w.value
            if (Ws(w)) return es(w)
            if (Je(w)) return ka(w, l, 2)
          })))
      : Je(e)
      ? t
        ? (c = () => ka(e, l, 2))
        : (c = () => {
            if (!(l && l.isUnmounted)) return f && f(), Un(e, l, 3, [h])
          })
      : (c = ri),
    t && i)
  ) {
    const w = c
    c = () => es(w())
  }
  let f,
    h = (w) => {
      f = b.onStop = () => {
        ka(w, l, 4)
      }
    },
    v
  if (br)
    if (((h = ri), t ? n && Un(t, l, 3, [c(), d ? [] : void 0, h]) : c(), a === 'sync')) {
      const w = vS()
      v = w.__watcherHandles || (w.__watcherHandles = [])
    } else return ri
  let g = d ? new Array(e.length).fill(rl) : rl
  const p = () => {
    if (b.active)
      if (t) {
        const w = b.run()
        ;(i || u || (d ? w.some((C, P) => fr(C, g[P])) : fr(w, g))) &&
          (f && f(), Un(t, l, 3, [w, g === rl ? void 0 : d && g[0] === rl ? [] : g, h]), (g = w))
      } else b.run()
  }
  p.allowRecurse = !!t
  let y
  a === 'sync'
    ? (y = p)
    : a === 'post'
    ? (y = () => Sn(p, l && l.suspense))
    : ((p.pre = !0), l && (p.id = l.uid), (y = () => Cf(p)))
  const b = new mf(c, y)
  t ? (n ? p() : (g = b.run())) : a === 'post' ? Sn(b.run.bind(b), l && l.suspense) : b.run()
  const x = () => {
    b.stop(), l && l.scope && df(l.scope.effects, b)
  }
  return v && v.push(x), x
}
function Cw(e, t, n) {
  const i = this.proxy,
    a = Ft(e) ? (e.includes('.') ? h0(i, e) : () => i[e]) : e.bind(i, i)
  let s
  Je(t) ? (s = t) : ((s = t.handler), (n = t))
  const o = Kt
  Ks(this)
  const r = Mf(a, s.bind(i), n)
  return o ? Ks(o) : os(), r
}
function h0(e, t) {
  const n = t.split('.')
  return () => {
    let i = e
    for (let a = 0; a < n.length && i; a++) i = i[n[a]]
    return i
  }
}
function es(e, t) {
  if (!bt(e) || e.__v_skip || ((t = t || new Set()), t.has(e))) return e
  if ((t.add(e), Tt(e))) es(e.value, t)
  else if (We(e)) for (let n = 0; n < e.length; n++) es(e[n], t)
  else if (Bp(e) || Hs(e))
    e.forEach((n) => {
      es(n, t)
    })
  else if (zp(e)) for (const n in e) es(e[n], t)
  return e
}
function Et(e, t) {
  const n = In
  if (n === null) return e
  const i = Fc(n) || n.proxy,
    a = e.dirs || (e.dirs = [])
  for (let s = 0; s < t.length; s++) {
    let [o, r, l, c = _t] = t[s]
    o &&
      (Je(o) && (o = { mounted: o, updated: o }),
      o.deep && es(r),
      a.push({ dir: o, instance: i, value: r, oldValue: void 0, arg: l, modifiers: c }))
  }
  return e
}
function $a(e, t, n, i) {
  const a = e.dirs,
    s = t && t.dirs
  for (let o = 0; o < a.length; o++) {
    const r = a[o]
    s && (r.oldValue = s[o].value)
    let l = r.dir[i]
    l && (ro(), Un(l, n, 8, [e.el, r, e, t]), lo())
  }
}
function v0() {
  const e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map() }
  return (
    tn(() => {
      e.isMounted = !0
    }),
    _n(() => {
      e.isUnmounting = !0
    }),
    e
  )
}
const $n = [Function, Array],
  g0 = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: $n,
    onEnter: $n,
    onAfterEnter: $n,
    onEnterCancelled: $n,
    onBeforeLeave: $n,
    onLeave: $n,
    onAfterLeave: $n,
    onLeaveCancelled: $n,
    onBeforeAppear: $n,
    onAppear: $n,
    onAfterAppear: $n,
    onAppearCancelled: $n
  },
  Mw = {
    name: 'BaseTransition',
    props: g0,
    setup(e, { slots: t }) {
      const n = If(),
        i = v0()
      let a
      return () => {
        const s = t.default && Af(t.default(), !0)
        if (!s || !s.length) return
        let o = s[0]
        if (s.length > 1) {
          for (const g of s)
            if (g.type !== li) {
              o = g
              break
            }
        }
        const r = Qe(e),
          { mode: l } = r
        if (i.isLeaving) return hu(o)
        const c = tv(o)
        if (!c) return hu(o)
        const u = mr(c, r, i, n)
        pr(c, u)
        const d = n.subTree,
          f = d && tv(d)
        let h = !1
        const { getTransitionKey: v } = c.type
        if (v) {
          const g = v()
          a === void 0 ? (a = g) : g !== a && ((a = g), (h = !0))
        }
        if (f && f.type !== li && (!Ja(c, f) || h)) {
          const g = mr(f, r, i, n)
          if ((pr(f, g), l === 'out-in'))
            return (
              (i.isLeaving = !0),
              (g.afterLeave = () => {
                ;(i.isLeaving = !1), n.update.active !== !1 && n.update()
              }),
              hu(o)
            )
          l === 'in-out' &&
            c.type !== li &&
            (g.delayLeave = (p, y, b) => {
              const x = m0(i, f)
              ;(x[String(f.key)] = f),
                (p._leaveCb = () => {
                  y(), (p._leaveCb = void 0), delete u.delayedLeave
                }),
                (u.delayedLeave = b)
            })
        }
        return o
      }
    }
  },
  Aw = Mw
function m0(e, t) {
  const { leavingVNodes: n } = e
  let i = n.get(t.type)
  return i || ((i = Object.create(null)), n.set(t.type, i)), i
}
function mr(e, t, n, i) {
  const {
      appear: a,
      mode: s,
      persisted: o = !1,
      onBeforeEnter: r,
      onEnter: l,
      onAfterEnter: c,
      onEnterCancelled: u,
      onBeforeLeave: d,
      onLeave: f,
      onAfterLeave: h,
      onLeaveCancelled: v,
      onBeforeAppear: g,
      onAppear: p,
      onAfterAppear: y,
      onAppearCancelled: b
    } = t,
    x = String(e.key),
    w = m0(n, e),
    C = (S, _) => {
      S && Un(S, i, 9, _)
    },
    P = (S, _) => {
      const T = _[1]
      C(S, _), We(S) ? S.every((B) => B.length <= 1) && T() : S.length <= 1 && T()
    },
    k = {
      mode: s,
      persisted: o,
      beforeEnter(S) {
        let _ = r
        if (!n.isMounted)
          if (a) _ = g || r
          else return
        S._leaveCb && S._leaveCb(!0)
        const T = w[x]
        T && Ja(e, T) && T.el._leaveCb && T.el._leaveCb(), C(_, [S])
      },
      enter(S) {
        let _ = l,
          T = c,
          B = u
        if (!n.isMounted)
          if (a) (_ = p || l), (T = y || c), (B = b || u)
          else return
        let O = !1
        const N = (S._enterCb = (Q) => {
          O ||
            ((O = !0), Q ? C(B, [S]) : C(T, [S]), k.delayedLeave && k.delayedLeave(), (S._enterCb = void 0))
        })
        _ ? P(_, [S, N]) : N()
      },
      leave(S, _) {
        const T = String(e.key)
        if ((S._enterCb && S._enterCb(!0), n.isUnmounting)) return _()
        C(d, [S])
        let B = !1
        const O = (S._leaveCb = (N) => {
          B || ((B = !0), _(), N ? C(v, [S]) : C(h, [S]), (S._leaveCb = void 0), w[T] === e && delete w[T])
        })
        ;(w[T] = e), f ? P(f, [S, O]) : O()
      },
      clone(S) {
        return mr(S, t, n, i)
      }
    }
  return k
}
function hu(e) {
  if (Lc(e)) return (e = Zi(e)), (e.children = null), e
}
function tv(e) {
  return Lc(e) ? (e.children ? e.children[0] : void 0) : e
}
function pr(e, t) {
  e.shapeFlag & 6 && e.component
    ? pr(e.component.subTree, t)
    : e.shapeFlag & 128
    ? ((e.ssContent.transition = t.clone(e.ssContent)), (e.ssFallback.transition = t.clone(e.ssFallback)))
    : (e.transition = t)
}
function Af(e, t = !1, n) {
  let i = [],
    a = 0
  for (let s = 0; s < e.length; s++) {
    let o = e[s]
    const r = n == null ? o.key : String(n) + String(o.key != null ? o.key : s)
    o.type === Oe
      ? (o.patchFlag & 128 && a++, (i = i.concat(Af(o.children, t, r))))
      : (t || o.type !== li) && i.push(r != null ? Zi(o, { key: r }) : o)
  }
  if (a > 1) for (let s = 0; s < i.length; s++) i[s].patchFlag = -2
  return i
}
function hn(e, t) {
  return Je(e) ? (() => Nt({ name: e.name }, t, { setup: e }))() : e
}
const Fl = (e) => !!e.type.__asyncLoader,
  Lc = (e) => e.type.__isKeepAlive
function p0(e, t) {
  b0(e, 'a', t)
}
function y0(e, t) {
  b0(e, 'da', t)
}
function b0(e, t, n = Kt) {
  const i =
    e.__wdc ||
    (e.__wdc = () => {
      let a = n
      for (; a; ) {
        if (a.isDeactivated) return
        a = a.parent
      }
      return e()
    })
  if ((Oc(t, i, n), n)) {
    let a = n.parent
    for (; a && a.parent; ) Lc(a.parent.vnode) && Pw(i, t, n, a), (a = a.parent)
  }
}
function Pw(e, t, n, i) {
  const a = Oc(t, e, i, !0)
  w0(() => {
    df(i[t], a)
  }, n)
}
function Oc(e, t, n = Kt, i = !1) {
  if (n) {
    const a = n[e] || (n[e] = []),
      s =
        t.__weh ||
        (t.__weh = (...o) => {
          if (n.isUnmounted) return
          ro(), Ks(n)
          const r = Un(t, n, e, o)
          return os(), lo(), r
        })
    return i ? a.unshift(s) : a.push(s), s
  }
}
const ia =
    (e) =>
    (t, n = Kt) =>
      (!br || e === 'sp') && Oc(e, (...i) => t(...i), n),
  Ic = ia('bm'),
  tn = ia('m'),
  _0 = ia('bu'),
  x0 = ia('u'),
  _n = ia('bum'),
  w0 = ia('um'),
  Tw = ia('sp'),
  Vw = ia('rtg'),
  Ew = ia('rtc')
function Lw(e, t = Kt) {
  Oc('ec', e, t)
}
const Pf = 'components',
  Ow = 'directives'
function Se(e, t) {
  return Tf(Pf, e, !0, t) || e
}
const S0 = Symbol.for('v-ndc')
function Iw(e) {
  return Ft(e) ? Tf(Pf, e, !1) || e : e || S0
}
function Fn(e) {
  return Tf(Ow, e)
}
function Tf(e, t, n = !0, i = !1) {
  const a = In || Kt
  if (a) {
    const s = a.type
    if (e === Pf) {
      const r = dS(s, !1)
      if (r && (r === t || r === Yn(t) || r === na(Yn(t)))) return s
    }
    const o = nv(a[e] || s[e], t) || nv(a.appContext[e], t)
    return !o && i ? s : o
  }
}
function nv(e, t) {
  return e && (e[t] || e[Yn(t)] || e[na(Yn(t))])
}
function Xi(e, t, n, i) {
  let a
  const s = n && n[i]
  if (We(e) || Ft(e)) {
    a = new Array(e.length)
    for (let o = 0, r = e.length; o < r; o++) a[o] = t(e[o], o, void 0, s && s[o])
  } else if (typeof e == 'number') {
    a = new Array(e)
    for (let o = 0; o < e; o++) a[o] = t(o + 1, o, void 0, s && s[o])
  } else if (bt(e))
    if (e[Symbol.iterator]) a = Array.from(e, (o, r) => t(o, r, void 0, s && s[r]))
    else {
      const o = Object.keys(e)
      a = new Array(o.length)
      for (let r = 0, l = o.length; r < l; r++) {
        const c = o[r]
        a[r] = t(e[c], c, r, s && s[r])
      }
    }
  else a = []
  return n && (n[i] = a), a
}
const Qu = (e) => (e ? (I0(e) ? Fc(e) || e.proxy : Qu(e.parent)) : null),
  Zo = Nt(Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => e.props,
    $attrs: (e) => e.attrs,
    $slots: (e) => e.slots,
    $refs: (e) => e.refs,
    $parent: (e) => Qu(e.parent),
    $root: (e) => Qu(e.root),
    $emit: (e) => e.emit,
    $options: (e) => Vf(e),
    $forceUpdate: (e) => e.f || (e.f = () => Cf(e.update)),
    $nextTick: (e) => e.n || (e.n = mt.bind(e.proxy)),
    $watch: (e) => Cw.bind(e)
  }),
  vu = (e, t) => e !== _t && !e.__isScriptSetup && rt(e, t),
  Dw = {
    get({ _: e }, t) {
      const { ctx: n, setupState: i, data: a, props: s, accessCache: o, type: r, appContext: l } = e
      let c
      if (t[0] !== '$') {
        const h = o[t]
        if (h !== void 0)
          switch (h) {
            case 1:
              return i[t]
            case 2:
              return a[t]
            case 4:
              return n[t]
            case 3:
              return s[t]
          }
        else {
          if (vu(i, t)) return (o[t] = 1), i[t]
          if (a !== _t && rt(a, t)) return (o[t] = 2), a[t]
          if ((c = e.propsOptions[0]) && rt(c, t)) return (o[t] = 3), s[t]
          if (n !== _t && rt(n, t)) return (o[t] = 4), n[t]
          ed && (o[t] = 0)
        }
      }
      const u = Zo[t]
      let d, f
      if (u) return t === '$attrs' && An(e, 'get', t), u(e)
      if ((d = r.__cssModules) && (d = d[t])) return d
      if (n !== _t && rt(n, t)) return (o[t] = 4), n[t]
      if (((f = l.config.globalProperties), rt(f, t))) return f[t]
    },
    set({ _: e }, t, n) {
      const { data: i, setupState: a, ctx: s } = e
      return vu(a, t)
        ? ((a[t] = n), !0)
        : i !== _t && rt(i, t)
        ? ((i[t] = n), !0)
        : rt(e.props, t) || (t[0] === '$' && t.slice(1) in e)
        ? !1
        : ((s[t] = n), !0)
    },
    has({ _: { data: e, setupState: t, accessCache: n, ctx: i, appContext: a, propsOptions: s } }, o) {
      let r
      return (
        !!n[o] ||
        (e !== _t && rt(e, o)) ||
        vu(t, o) ||
        ((r = s[0]) && rt(r, o)) ||
        rt(i, o) ||
        rt(Zo, o) ||
        rt(a.config.globalProperties, o)
      )
    },
    defineProperty(e, t, n) {
      return (
        n.get != null ? (e._.accessCache[t] = 0) : rt(n, 'value') && this.set(e, t, n.value, null),
        Reflect.defineProperty(e, t, n)
      )
    }
  }
function iv(e) {
  return We(e) ? e.reduce((t, n) => ((t[n] = null), t), {}) : e
}
let ed = !0
function Fw(e) {
  const t = Vf(e),
    n = e.proxy,
    i = e.ctx
  ;(ed = !1), t.beforeCreate && av(t.beforeCreate, e, 'bc')
  const {
    data: a,
    computed: s,
    methods: o,
    watch: r,
    provide: l,
    inject: c,
    created: u,
    beforeMount: d,
    mounted: f,
    beforeUpdate: h,
    updated: v,
    activated: g,
    deactivated: p,
    beforeDestroy: y,
    beforeUnmount: b,
    destroyed: x,
    unmounted: w,
    render: C,
    renderTracked: P,
    renderTriggered: k,
    errorCaptured: S,
    serverPrefetch: _,
    expose: T,
    inheritAttrs: B,
    components: O,
    directives: N,
    filters: Q
  } = t
  if ((c && Rw(c, i, null), o))
    for (const U in o) {
      const X = o[U]
      Je(X) && (i[U] = X.bind(n))
    }
  if (a) {
    const U = a.call(n, n)
    bt(U) && (e.data = yn(U))
  }
  if (((ed = !0), s))
    for (const U in s) {
      const X = s[U],
        oe = Je(X) ? X.bind(n, n) : Je(X.get) ? X.get.bind(n, n) : ri,
        de = !Je(X) && Je(X.set) ? X.set.bind(n) : ri,
        ce = A({ get: oe, set: de })
      Object.defineProperty(i, U, {
        enumerable: !0,
        configurable: !0,
        get: () => ce.value,
        set: (Te) => (ce.value = Te)
      })
    }
  if (r) for (const U in r) k0(r[U], i, n, U)
  if (l) {
    const U = Je(l) ? l.call(n) : l
    Reflect.ownKeys(U).forEach((X) => {
      Vt(X, U[X])
    })
  }
  u && av(u, e, 'c')
  function j(U, X) {
    We(X) ? X.forEach((oe) => U(oe.bind(n))) : X && U(X.bind(n))
  }
  if (
    (j(Ic, d),
    j(tn, f),
    j(_0, h),
    j(x0, v),
    j(p0, g),
    j(y0, p),
    j(Lw, S),
    j(Ew, P),
    j(Vw, k),
    j(_n, b),
    j(w0, w),
    j(Tw, _),
    We(T))
  )
    if (T.length) {
      const U = e.exposed || (e.exposed = {})
      T.forEach((X) => {
        Object.defineProperty(U, X, { get: () => n[X], set: (oe) => (n[X] = oe) })
      })
    } else e.exposed || (e.exposed = {})
  C && e.render === ri && (e.render = C),
    B != null && (e.inheritAttrs = B),
    O && (e.components = O),
    N && (e.directives = N)
}
function Rw(e, t, n = ri) {
  We(e) && (e = td(e))
  for (const i in e) {
    const a = e[i]
    let s
    bt(a) ? ('default' in a ? (s = st(a.from || i, a.default, !0)) : (s = st(a.from || i))) : (s = st(a)),
      Tt(s)
        ? Object.defineProperty(t, i, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: (o) => (s.value = o)
          })
        : (t[i] = s)
  }
}
function av(e, t, n) {
  Un(We(e) ? e.map((i) => i.bind(t.proxy)) : e.bind(t.proxy), t, n)
}
function k0(e, t, n, i) {
  const a = i.includes('.') ? h0(n, i) : () => n[i]
  if (Ft(e)) {
    const s = t[e]
    Je(s) && Pe(a, s)
  } else if (Je(e)) Pe(a, e.bind(n))
  else if (bt(e))
    if (We(e)) e.forEach((s) => k0(s, t, n, i))
    else {
      const s = Je(e.handler) ? e.handler.bind(n) : t[e.handler]
      Je(s) && Pe(a, s, e)
    }
}
function Vf(e) {
  const t = e.type,
    { mixins: n, extends: i } = t,
    {
      mixins: a,
      optionsCache: s,
      config: { optionMergeStrategies: o }
    } = e.appContext,
    r = s.get(t)
  let l
  return (
    r
      ? (l = r)
      : !a.length && !n && !i
      ? (l = t)
      : ((l = {}), a.length && a.forEach((c) => tc(l, c, o, !0)), tc(l, t, o)),
    bt(t) && s.set(t, l),
    l
  )
}
function tc(e, t, n, i = !1) {
  const { mixins: a, extends: s } = t
  s && tc(e, s, n, !0), a && a.forEach((o) => tc(e, o, n, !0))
  for (const o in t)
    if (!(i && o === 'expose')) {
      const r = Bw[o] || (n && n[o])
      e[o] = r ? r(e[o], t[o]) : t[o]
    }
  return e
}
const Bw = {
  data: sv,
  props: ov,
  emits: ov,
  methods: zo,
  computed: zo,
  beforeCreate: mn,
  created: mn,
  beforeMount: mn,
  mounted: mn,
  beforeUpdate: mn,
  updated: mn,
  beforeDestroy: mn,
  beforeUnmount: mn,
  destroyed: mn,
  unmounted: mn,
  activated: mn,
  deactivated: mn,
  errorCaptured: mn,
  serverPrefetch: mn,
  components: zo,
  directives: zo,
  watch: $w,
  provide: sv,
  inject: Nw
}
function sv(e, t) {
  return t
    ? e
      ? function () {
          return Nt(Je(e) ? e.call(this, this) : e, Je(t) ? t.call(this, this) : t)
        }
      : t
    : e
}
function Nw(e, t) {
  return zo(td(e), td(t))
}
function td(e) {
  if (We(e)) {
    const t = {}
    for (let n = 0; n < e.length; n++) t[e[n]] = e[n]
    return t
  }
  return e
}
function mn(e, t) {
  return e ? [...new Set([].concat(e, t))] : t
}
function zo(e, t) {
  return e ? Nt(Object.create(null), e, t) : t
}
function ov(e, t) {
  return e ? (We(e) && We(t) ? [...new Set([...e, ...t])] : Nt(Object.create(null), iv(e), iv(t ?? {}))) : t
}
function $w(e, t) {
  if (!e) return t
  if (!t) return e
  const n = Nt(Object.create(null), e)
  for (const i in t) n[i] = mn(e[i], t[i])
  return n
}
function C0() {
  return {
    app: null,
    config: {
      isNativeTag: bx,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap()
  }
}
let zw = 0
function Hw(e, t) {
  return function (i, a = null) {
    Je(i) || (i = Nt({}, i)), a != null && !bt(a) && (a = null)
    const s = C0(),
      o = new Set()
    let r = !1
    const l = (s.app = {
      _uid: zw++,
      _component: i,
      _props: a,
      _container: null,
      _context: s,
      _instance: null,
      version: gS,
      get config() {
        return s.config
      },
      set config(c) {},
      use(c, ...u) {
        return (
          o.has(c) || (c && Je(c.install) ? (o.add(c), c.install(l, ...u)) : Je(c) && (o.add(c), c(l, ...u))),
          l
        )
      },
      mixin(c) {
        return s.mixins.includes(c) || s.mixins.push(c), l
      },
      component(c, u) {
        return u ? ((s.components[c] = u), l) : s.components[c]
      },
      directive(c, u) {
        return u ? ((s.directives[c] = u), l) : s.directives[c]
      },
      mount(c, u, d) {
        if (!r) {
          const f = m(i, a)
          return (
            (f.appContext = s),
            u && t ? t(f, c) : e(f, c, d),
            (r = !0),
            (l._container = c),
            (c.__vue_app__ = l),
            Fc(f.component) || f.component.proxy
          )
        }
      },
      unmount() {
        r && (e(null, l._container), delete l._container.__vue_app__)
      },
      provide(c, u) {
        return (s.provides[c] = u), l
      },
      runWithContext(c) {
        nc = l
        try {
          return c()
        } finally {
          nc = null
        }
      }
    })
    return l
  }
}
let nc = null
function Vt(e, t) {
  if (Kt) {
    let n = Kt.provides
    const i = Kt.parent && Kt.parent.provides
    i === n && (n = Kt.provides = Object.create(i)), (n[e] = t)
  }
}
function st(e, t, n = !1) {
  const i = Kt || In
  if (i || nc) {
    const a = i
      ? i.parent == null
        ? i.vnode.appContext && i.vnode.appContext.provides
        : i.parent.provides
      : nc._context.provides
    if (a && e in a) return a[e]
    if (arguments.length > 1) return n && Je(t) ? t.call(i && i.proxy) : t
  }
}
function Ww(e, t, n, i = !1) {
  const a = {},
    s = {}
  Zl(s, Dc, 1), (e.propsDefaults = Object.create(null)), M0(e, t, a, s)
  for (const o in e.propsOptions[0]) o in a || (a[o] = void 0)
  n ? (e.props = i ? a : t0(a)) : e.type.props ? (e.props = a) : (e.props = s), (e.attrs = s)
}
function jw(e, t, n, i) {
  const {
      props: a,
      attrs: s,
      vnode: { patchFlag: o }
    } = e,
    r = Qe(a),
    [l] = e.propsOptions
  let c = !1
  if ((i || o > 0) && !(o & 16)) {
    if (o & 8) {
      const u = e.vnode.dynamicProps
      for (let d = 0; d < u.length; d++) {
        let f = u[d]
        if (Vc(e.emitsOptions, f)) continue
        const h = t[f]
        if (l)
          if (rt(s, f)) h !== s[f] && ((s[f] = h), (c = !0))
          else {
            const v = Yn(f)
            a[v] = nd(l, r, v, h, e, !1)
          }
        else h !== s[f] && ((s[f] = h), (c = !0))
      }
    }
  } else {
    M0(e, t, a, s) && (c = !0)
    let u
    for (const d in r)
      (!t || (!rt(t, d) && ((u = oo(d)) === d || !rt(t, u)))) &&
        (l ? n && (n[d] !== void 0 || n[u] !== void 0) && (a[d] = nd(l, r, d, void 0, e, !0)) : delete a[d])
    if (s !== r) for (const d in s) (!t || !rt(t, d)) && (delete s[d], (c = !0))
  }
  c && qi(e, 'set', '$attrs')
}
function M0(e, t, n, i) {
  const [a, s] = e.propsOptions
  let o = !1,
    r
  if (t)
    for (let l in t) {
      if (Il(l)) continue
      const c = t[l]
      let u
      a && rt(a, (u = Yn(l)))
        ? !s || !s.includes(u)
          ? (n[u] = c)
          : ((r || (r = {}))[u] = c)
        : Vc(e.emitsOptions, l) || ((!(l in i) || c !== i[l]) && ((i[l] = c), (o = !0)))
    }
  if (s) {
    const l = Qe(n),
      c = r || _t
    for (let u = 0; u < s.length; u++) {
      const d = s[u]
      n[d] = nd(a, l, d, c[d], e, !rt(c, d))
    }
  }
  return o
}
function nd(e, t, n, i, a, s) {
  const o = e[n]
  if (o != null) {
    const r = rt(o, 'default')
    if (r && i === void 0) {
      const l = o.default
      if (o.type !== Function && !o.skipFactory && Je(l)) {
        const { propsDefaults: c } = a
        n in c ? (i = c[n]) : (Ks(a), (i = c[n] = l.call(null, t)), os())
      } else i = l
    }
    o[0] && (s && !r ? (i = !1) : o[1] && (i === '' || i === oo(n)) && (i = !0))
  }
  return i
}
function A0(e, t, n = !1) {
  const i = t.propsCache,
    a = i.get(e)
  if (a) return a
  const s = e.props,
    o = {},
    r = []
  let l = !1
  if (!Je(e)) {
    const u = (d) => {
      l = !0
      const [f, h] = A0(d, t, !0)
      Nt(o, f), h && r.push(...h)
    }
    !n && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u)
  }
  if (!s && !l) return bt(e) && i.set(e, zs), zs
  if (We(s))
    for (let u = 0; u < s.length; u++) {
      const d = Yn(s[u])
      rv(d) && (o[d] = _t)
    }
  else if (s)
    for (const u in s) {
      const d = Yn(u)
      if (rv(d)) {
        const f = s[u],
          h = (o[d] = We(f) || Je(f) ? { type: f } : Nt({}, f))
        if (h) {
          const v = uv(Boolean, h.type),
            g = uv(String, h.type)
          ;(h[0] = v > -1), (h[1] = g < 0 || v < g), (v > -1 || rt(h, 'default')) && r.push(d)
        }
      }
    }
  const c = [o, r]
  return bt(e) && i.set(e, c), c
}
function rv(e) {
  return e[0] !== '$'
}
function lv(e) {
  const t = e && e.toString().match(/^\s*(function|class) (\w+)/)
  return t ? t[2] : e === null ? 'null' : ''
}
function cv(e, t) {
  return lv(e) === lv(t)
}
function uv(e, t) {
  return We(t) ? t.findIndex((n) => cv(n, e)) : Je(t) && cv(t, e) ? 0 : -1
}
const P0 = (e) => e[0] === '_' || e === '$stable',
  Ef = (e) => (We(e) ? e.map(_i) : [_i(e)]),
  Uw = (e, t, n) => {
    if (t._n) return t
    const i = we((...a) => Ef(t(...a)), n)
    return (i._c = !1), i
  },
  T0 = (e, t, n) => {
    const i = e._ctx
    for (const a in e) {
      if (P0(a)) continue
      const s = e[a]
      if (Je(s)) t[a] = Uw(a, s, i)
      else if (s != null) {
        const o = Ef(s)
        t[a] = () => o
      }
    }
  },
  V0 = (e, t) => {
    const n = Ef(t)
    e.slots.default = () => n
  },
  Yw = (e, t) => {
    if (e.vnode.shapeFlag & 32) {
      const n = t._
      n ? ((e.slots = Qe(t)), Zl(t, '_', n)) : T0(t, (e.slots = {}))
    } else (e.slots = {}), t && V0(e, t)
    Zl(e.slots, Dc, 1)
  },
  Gw = (e, t, n) => {
    const { vnode: i, slots: a } = e
    let s = !0,
      o = _t
    if (i.shapeFlag & 32) {
      const r = t._
      r ? (n && r === 1 ? (s = !1) : (Nt(a, t), !n && r === 1 && delete a._)) : ((s = !t.$stable), T0(t, a)),
        (o = t)
    } else t && (V0(e, t), (o = { default: 1 }))
    if (s) for (const r in a) !P0(r) && !(r in o) && delete a[r]
  }
function id(e, t, n, i, a = !1) {
  if (We(e)) {
    e.forEach((f, h) => id(f, t && (We(t) ? t[h] : t), n, i, a))
    return
  }
  if (Fl(i) && !a) return
  const s = i.shapeFlag & 4 ? Fc(i.component) || i.component.proxy : i.el,
    o = a ? null : s,
    { i: r, r: l } = e,
    c = t && t.r,
    u = r.refs === _t ? (r.refs = {}) : r.refs,
    d = r.setupState
  if (
    (c != null && c !== l && (Ft(c) ? ((u[c] = null), rt(d, c) && (d[c] = null)) : Tt(c) && (c.value = null)),
    Je(l))
  )
    ka(l, r, 12, [o, u])
  else {
    const f = Ft(l),
      h = Tt(l)
    if (f || h) {
      const v = () => {
        if (e.f) {
          const g = f ? (rt(d, l) ? d[l] : u[l]) : l.value
          a
            ? We(g) && df(g, s)
            : We(g)
            ? g.includes(s) || g.push(s)
            : f
            ? ((u[l] = [s]), rt(d, l) && (d[l] = u[l]))
            : ((l.value = [s]), e.k && (u[e.k] = l.value))
        } else f ? ((u[l] = o), rt(d, l) && (d[l] = o)) : h && ((l.value = o), e.k && (u[e.k] = o))
      }
      o ? ((v.id = -1), Sn(v, n)) : v()
    }
  }
}
const Sn = kw
function Xw(e) {
  return Kw(e)
}
function Kw(e, t) {
  const n = Xu()
  n.__VUE__ = !0
  const {
      insert: i,
      remove: a,
      patchProp: s,
      createElement: o,
      createText: r,
      createComment: l,
      setText: c,
      setElementText: u,
      parentNode: d,
      nextSibling: f,
      setScopeId: h = ri,
      insertStaticContent: v
    } = e,
    g = (L, D, H, Z = null, ae = null, se = null, ye = !1, pe = null, _e = !!D.dynamicChildren) => {
      if (L === D) return
      L && !Ja(L, D) && ((Z = Y(L)), Te(L, ae, se, !0), (L = null)),
        D.patchFlag === -2 && ((_e = !1), (D.dynamicChildren = null))
      const { type: he, ref: Fe, shapeFlag: Le } = D
      switch (he) {
        case zr:
          p(L, D, H, Z)
          break
        case li:
          y(L, D, H, Z)
          break
        case gu:
          L == null && b(D, H, Z, ye)
          break
        case Oe:
          O(L, D, H, Z, ae, se, ye, pe, _e)
          break
        default:
          Le & 1
            ? C(L, D, H, Z, ae, se, ye, pe, _e)
            : Le & 6
            ? N(L, D, H, Z, ae, se, ye, pe, _e)
            : (Le & 64 || Le & 128) && he.process(L, D, H, Z, ae, se, ye, pe, _e, W)
      }
      Fe != null && ae && id(Fe, L && L.ref, se, D || L, !D)
    },
    p = (L, D, H, Z) => {
      if (L == null) i((D.el = r(D.children)), H, Z)
      else {
        const ae = (D.el = L.el)
        D.children !== L.children && c(ae, D.children)
      }
    },
    y = (L, D, H, Z) => {
      L == null ? i((D.el = l(D.children || '')), H, Z) : (D.el = L.el)
    },
    b = (L, D, H, Z) => {
      ;[L.el, L.anchor] = v(L.children, D, H, Z, L.el, L.anchor)
    },
    x = ({ el: L, anchor: D }, H, Z) => {
      let ae
      for (; L && L !== D; ) (ae = f(L)), i(L, H, Z), (L = ae)
      i(D, H, Z)
    },
    w = ({ el: L, anchor: D }) => {
      let H
      for (; L && L !== D; ) (H = f(L)), a(L), (L = H)
      a(D)
    },
    C = (L, D, H, Z, ae, se, ye, pe, _e) => {
      ;(ye = ye || D.type === 'svg'), L == null ? P(D, H, Z, ae, se, ye, pe, _e) : _(L, D, ae, se, ye, pe, _e)
    },
    P = (L, D, H, Z, ae, se, ye, pe) => {
      let _e, he
      const { type: Fe, props: Le, shapeFlag: Be, transition: je, dirs: tt } = L
      if (
        ((_e = L.el = o(L.type, se, Le && Le.is, Le)),
        Be & 8
          ? u(_e, L.children)
          : Be & 16 && S(L.children, _e, null, Z, ae, se && Fe !== 'foreignObject', ye, pe),
        tt && $a(L, null, Z, 'created'),
        k(_e, L, L.scopeId, ye, Z),
        Le)
      ) {
        for (const it in Le) it !== 'value' && !Il(it) && s(_e, it, null, Le[it], se, L.children, Z, ae, ie)
        'value' in Le && s(_e, 'value', null, Le.value), (he = Le.onVnodeBeforeMount) && gi(he, Z, L)
      }
      tt && $a(L, null, Z, 'beforeMount')
      const dt = (!ae || (ae && !ae.pendingBranch)) && je && !je.persisted
      dt && je.beforeEnter(_e),
        i(_e, D, H),
        ((he = Le && Le.onVnodeMounted) || dt || tt) &&
          Sn(() => {
            he && gi(he, Z, L), dt && je.enter(_e), tt && $a(L, null, Z, 'mounted')
          }, ae)
    },
    k = (L, D, H, Z, ae) => {
      if ((H && h(L, H), Z)) for (let se = 0; se < Z.length; se++) h(L, Z[se])
      if (ae) {
        let se = ae.subTree
        if (D === se) {
          const ye = ae.vnode
          k(L, ye, ye.scopeId, ye.slotScopeIds, ae.parent)
        }
      }
    },
    S = (L, D, H, Z, ae, se, ye, pe, _e = 0) => {
      for (let he = _e; he < L.length; he++) {
        const Fe = (L[he] = pe ? ga(L[he]) : _i(L[he]))
        g(null, Fe, D, H, Z, ae, se, ye, pe)
      }
    },
    _ = (L, D, H, Z, ae, se, ye) => {
      const pe = (D.el = L.el)
      let { patchFlag: _e, dynamicChildren: he, dirs: Fe } = D
      _e |= L.patchFlag & 16
      const Le = L.props || _t,
        Be = D.props || _t
      let je
      H && za(H, !1),
        (je = Be.onVnodeBeforeUpdate) && gi(je, H, D, L),
        Fe && $a(D, L, H, 'beforeUpdate'),
        H && za(H, !0)
      const tt = ae && D.type !== 'foreignObject'
      if (
        (he ? T(L.dynamicChildren, he, pe, H, Z, tt, se) : ye || X(L, D, pe, null, H, Z, tt, se, !1), _e > 0)
      ) {
        if (_e & 16) B(pe, D, Le, Be, H, Z, ae)
        else if (
          (_e & 2 && Le.class !== Be.class && s(pe, 'class', null, Be.class, ae),
          _e & 4 && s(pe, 'style', Le.style, Be.style, ae),
          _e & 8)
        ) {
          const dt = D.dynamicProps
          for (let it = 0; it < dt.length; it++) {
            const Ot = dt[it],
              xn = Le[Ot],
              Ii = Be[Ot]
            ;(Ii !== xn || Ot === 'value') && s(pe, Ot, xn, Ii, ae, L.children, H, Z, ie)
          }
        }
        _e & 1 && L.children !== D.children && u(pe, D.children)
      } else !ye && he == null && B(pe, D, Le, Be, H, Z, ae)
      ;((je = Be.onVnodeUpdated) || Fe) &&
        Sn(() => {
          je && gi(je, H, D, L), Fe && $a(D, L, H, 'updated')
        }, Z)
    },
    T = (L, D, H, Z, ae, se, ye) => {
      for (let pe = 0; pe < D.length; pe++) {
        const _e = L[pe],
          he = D[pe],
          Fe = _e.el && (_e.type === Oe || !Ja(_e, he) || _e.shapeFlag & 70) ? d(_e.el) : H
        g(_e, he, Fe, null, Z, ae, se, ye, !0)
      }
    },
    B = (L, D, H, Z, ae, se, ye) => {
      if (H !== Z) {
        if (H !== _t)
          for (const pe in H) !Il(pe) && !(pe in Z) && s(L, pe, H[pe], null, ye, D.children, ae, se, ie)
        for (const pe in Z) {
          if (Il(pe)) continue
          const _e = Z[pe],
            he = H[pe]
          _e !== he && pe !== 'value' && s(L, pe, he, _e, ye, D.children, ae, se, ie)
        }
        'value' in Z && s(L, 'value', H.value, Z.value)
      }
    },
    O = (L, D, H, Z, ae, se, ye, pe, _e) => {
      const he = (D.el = L ? L.el : r('')),
        Fe = (D.anchor = L ? L.anchor : r(''))
      let { patchFlag: Le, dynamicChildren: Be, slotScopeIds: je } = D
      je && (pe = pe ? pe.concat(je) : je),
        L == null
          ? (i(he, H, Z), i(Fe, H, Z), S(D.children, H, Fe, ae, se, ye, pe, _e))
          : Le > 0 && Le & 64 && Be && L.dynamicChildren
          ? (T(L.dynamicChildren, Be, H, ae, se, ye, pe),
            (D.key != null || (ae && D === ae.subTree)) && Lf(L, D, !0))
          : X(L, D, H, Fe, ae, se, ye, pe, _e)
    },
    N = (L, D, H, Z, ae, se, ye, pe, _e) => {
      ;(D.slotScopeIds = pe),
        L == null
          ? D.shapeFlag & 512
            ? ae.ctx.activate(D, H, Z, ye, _e)
            : Q(D, H, Z, ae, se, ye, _e)
          : ue(L, D, _e)
    },
    Q = (L, D, H, Z, ae, se, ye) => {
      const pe = (L.component = oS(L, Z, ae))
      if ((Lc(L) && (pe.ctx.renderer = W), rS(pe), pe.asyncDep)) {
        if ((ae && ae.registerDep(pe, j), !L.el)) {
          const _e = (pe.subTree = m(li))
          y(null, _e, D, H)
        }
        return
      }
      j(pe, L, D, H, ae, se, ye)
    },
    ue = (L, D, H) => {
      const Z = (D.component = L.component)
      if (xw(L, D, H))
        if (Z.asyncDep && !Z.asyncResolved) {
          U(Z, D, H)
          return
        } else (Z.next = D), gw(Z.update), Z.update()
      else (D.el = L.el), (Z.vnode = D)
    },
    j = (L, D, H, Z, ae, se, ye) => {
      const pe = () => {
          if (L.isMounted) {
            let { next: Fe, bu: Le, u: Be, parent: je, vnode: tt } = L,
              dt = Fe,
              it
            za(L, !1),
              Fe ? ((Fe.el = tt.el), U(L, Fe, ye)) : (Fe = tt),
              Le && Dl(Le),
              (it = Fe.props && Fe.props.onVnodeBeforeUpdate) && gi(it, je, Fe, tt),
              za(L, !0)
            const Ot = fu(L),
              xn = L.subTree
            ;(L.subTree = Ot),
              g(xn, Ot, d(xn.el), Y(xn), L, ae, se),
              (Fe.el = Ot.el),
              dt === null && ww(L, Ot.el),
              Be && Sn(Be, ae),
              (it = Fe.props && Fe.props.onVnodeUpdated) && Sn(() => gi(it, je, Fe, tt), ae)
          } else {
            let Fe
            const { el: Le, props: Be } = D,
              { bm: je, m: tt, parent: dt } = L,
              it = Fl(D)
            if (
              (za(L, !1),
              je && Dl(je),
              !it && (Fe = Be && Be.onVnodeBeforeMount) && gi(Fe, dt, D),
              za(L, !0),
              Le && De)
            ) {
              const Ot = () => {
                ;(L.subTree = fu(L)), De(Le, L.subTree, L, ae, null)
              }
              it ? D.type.__asyncLoader().then(() => !L.isUnmounted && Ot()) : Ot()
            } else {
              const Ot = (L.subTree = fu(L))
              g(null, Ot, H, Z, L, ae, se), (D.el = Ot.el)
            }
            if ((tt && Sn(tt, ae), !it && (Fe = Be && Be.onVnodeMounted))) {
              const Ot = D
              Sn(() => gi(Fe, dt, Ot), ae)
            }
            ;(D.shapeFlag & 256 || (dt && Fl(dt.vnode) && dt.vnode.shapeFlag & 256)) && L.a && Sn(L.a, ae),
              (L.isMounted = !0),
              (D = H = Z = null)
          }
        },
        _e = (L.effect = new mf(pe, () => Cf(he), L.scope)),
        he = (L.update = () => _e.run())
      ;(he.id = L.uid), za(L, !0), he()
    },
    U = (L, D, H) => {
      D.component = L
      const Z = L.vnode.props
      ;(L.vnode = D), (L.next = null), jw(L, D.props, Z, H), Gw(L, D.children, H), ro(), Qh(), lo()
    },
    X = (L, D, H, Z, ae, se, ye, pe, _e = !1) => {
      const he = L && L.children,
        Fe = L ? L.shapeFlag : 0,
        Le = D.children,
        { patchFlag: Be, shapeFlag: je } = D
      if (Be > 0) {
        if (Be & 128) {
          de(he, Le, H, Z, ae, se, ye, pe, _e)
          return
        } else if (Be & 256) {
          oe(he, Le, H, Z, ae, se, ye, pe, _e)
          return
        }
      }
      je & 8
        ? (Fe & 16 && ie(he, ae, se), Le !== he && u(H, Le))
        : Fe & 16
        ? je & 16
          ? de(he, Le, H, Z, ae, se, ye, pe, _e)
          : ie(he, ae, se, !0)
        : (Fe & 8 && u(H, ''), je & 16 && S(Le, H, Z, ae, se, ye, pe, _e))
    },
    oe = (L, D, H, Z, ae, se, ye, pe, _e) => {
      ;(L = L || zs), (D = D || zs)
      const he = L.length,
        Fe = D.length,
        Le = Math.min(he, Fe)
      let Be
      for (Be = 0; Be < Le; Be++) {
        const je = (D[Be] = _e ? ga(D[Be]) : _i(D[Be]))
        g(L[Be], je, H, null, ae, se, ye, pe, _e)
      }
      he > Fe ? ie(L, ae, se, !0, !1, Le) : S(D, H, Z, ae, se, ye, pe, _e, Le)
    },
    de = (L, D, H, Z, ae, se, ye, pe, _e) => {
      let he = 0
      const Fe = D.length
      let Le = L.length - 1,
        Be = Fe - 1
      for (; he <= Le && he <= Be; ) {
        const je = L[he],
          tt = (D[he] = _e ? ga(D[he]) : _i(D[he]))
        if (Ja(je, tt)) g(je, tt, H, null, ae, se, ye, pe, _e)
        else break
        he++
      }
      for (; he <= Le && he <= Be; ) {
        const je = L[Le],
          tt = (D[Be] = _e ? ga(D[Be]) : _i(D[Be]))
        if (Ja(je, tt)) g(je, tt, H, null, ae, se, ye, pe, _e)
        else break
        Le--, Be--
      }
      if (he > Le) {
        if (he <= Be) {
          const je = Be + 1,
            tt = je < Fe ? D[je].el : Z
          for (; he <= Be; ) g(null, (D[he] = _e ? ga(D[he]) : _i(D[he])), H, tt, ae, se, ye, pe, _e), he++
        }
      } else if (he > Be) for (; he <= Le; ) Te(L[he], ae, se, !0), he++
      else {
        const je = he,
          tt = he,
          dt = new Map()
        for (he = tt; he <= Be; he++) {
          const an = (D[he] = _e ? ga(D[he]) : _i(D[he]))
          an.key != null && dt.set(an.key, he)
        }
        let it,
          Ot = 0
        const xn = Be - tt + 1
        let Ii = !1,
          Co = 0
        const ca = new Array(xn)
        for (he = 0; he < xn; he++) ca[he] = 0
        for (he = je; he <= Le; he++) {
          const an = L[he]
          if (Ot >= xn) {
            Te(an, ae, se, !0)
            continue
          }
          let Nn
          if (an.key != null) Nn = dt.get(an.key)
          else
            for (it = tt; it <= Be; it++)
              if (ca[it - tt] === 0 && Ja(an, D[it])) {
                Nn = it
                break
              }
          Nn === void 0
            ? Te(an, ae, se, !0)
            : ((ca[Nn - tt] = he + 1),
              Nn >= Co ? (Co = Nn) : (Ii = !0),
              g(an, D[Nn], H, null, ae, se, ye, pe, _e),
              Ot++)
        }
        const Mo = Ii ? qw(ca) : zs
        for (it = Mo.length - 1, he = xn - 1; he >= 0; he--) {
          const an = tt + he,
            Nn = D[an],
            el = an + 1 < Fe ? D[an + 1].el : Z
          ca[he] === 0
            ? g(null, Nn, H, el, ae, se, ye, pe, _e)
            : Ii && (it < 0 || he !== Mo[it] ? ce(Nn, H, el, 2) : it--)
        }
      }
    },
    ce = (L, D, H, Z, ae = null) => {
      const { el: se, type: ye, transition: pe, children: _e, shapeFlag: he } = L
      if (he & 6) {
        ce(L.component.subTree, D, H, Z)
        return
      }
      if (he & 128) {
        L.suspense.move(D, H, Z)
        return
      }
      if (he & 64) {
        ye.move(L, D, H, W)
        return
      }
      if (ye === Oe) {
        i(se, D, H)
        for (let Le = 0; Le < _e.length; Le++) ce(_e[Le], D, H, Z)
        i(L.anchor, D, H)
        return
      }
      if (ye === gu) {
        x(L, D, H)
        return
      }
      if (Z !== 2 && he & 1 && pe)
        if (Z === 0) pe.beforeEnter(se), i(se, D, H), Sn(() => pe.enter(se), ae)
        else {
          const { leave: Le, delayLeave: Be, afterLeave: je } = pe,
            tt = () => i(se, D, H),
            dt = () => {
              Le(se, () => {
                tt(), je && je()
              })
            }
          Be ? Be(se, tt, dt) : dt()
        }
      else i(se, D, H)
    },
    Te = (L, D, H, Z = !1, ae = !1) => {
      const {
        type: se,
        props: ye,
        ref: pe,
        children: _e,
        dynamicChildren: he,
        shapeFlag: Fe,
        patchFlag: Le,
        dirs: Be
      } = L
      if ((pe != null && id(pe, null, H, L, !0), Fe & 256)) {
        D.ctx.deactivate(L)
        return
      }
      const je = Fe & 1 && Be,
        tt = !Fl(L)
      let dt
      if ((tt && (dt = ye && ye.onVnodeBeforeUnmount) && gi(dt, D, L), Fe & 6)) Ue(L.component, H, Z)
      else {
        if (Fe & 128) {
          L.suspense.unmount(H, Z)
          return
        }
        je && $a(L, null, D, 'beforeUnmount'),
          Fe & 64
            ? L.type.remove(L, D, H, ae, W, Z)
            : he && (se !== Oe || (Le > 0 && Le & 64))
            ? ie(he, D, H, !1, !0)
            : ((se === Oe && Le & 384) || (!ae && Fe & 16)) && ie(_e, D, H),
          Z && $e(L)
      }
      ;((tt && (dt = ye && ye.onVnodeUnmounted)) || je) &&
        Sn(() => {
          dt && gi(dt, D, L), je && $a(L, null, D, 'unmounted')
        }, H)
    },
    $e = (L) => {
      const { type: D, el: H, anchor: Z, transition: ae } = L
      if (D === Oe) {
        He(H, Z)
        return
      }
      if (D === gu) {
        w(L)
        return
      }
      const se = () => {
        a(H), ae && !ae.persisted && ae.afterLeave && ae.afterLeave()
      }
      if (L.shapeFlag & 1 && ae && !ae.persisted) {
        const { leave: ye, delayLeave: pe } = ae,
          _e = () => ye(H, se)
        pe ? pe(L.el, se, _e) : _e()
      } else se()
    },
    He = (L, D) => {
      let H
      for (; L !== D; ) (H = f(L)), a(L), (L = H)
      a(D)
    },
    Ue = (L, D, H) => {
      const { bum: Z, scope: ae, update: se, subTree: ye, um: pe } = L
      Z && Dl(Z),
        ae.stop(),
        se && ((se.active = !1), Te(ye, L, D, H)),
        pe && Sn(pe, D),
        Sn(() => {
          L.isUnmounted = !0
        }, D),
        D &&
          D.pendingBranch &&
          !D.isUnmounted &&
          L.asyncDep &&
          !L.asyncResolved &&
          L.suspenseId === D.pendingId &&
          (D.deps--, D.deps === 0 && D.resolve())
    },
    ie = (L, D, H, Z = !1, ae = !1, se = 0) => {
      for (let ye = se; ye < L.length; ye++) Te(L[ye], D, H, Z, ae)
    },
    Y = (L) =>
      L.shapeFlag & 6 ? Y(L.component.subTree) : L.shapeFlag & 128 ? L.suspense.next() : f(L.anchor || L.el),
    ne = (L, D, H) => {
      L == null ? D._vnode && Te(D._vnode, null, null, !0) : g(D._vnode || null, L, D, null, null, null, H),
        Qh(),
        u0(),
        (D._vnode = L)
    },
    W = { p: g, um: Te, m: ce, r: $e, mt: Q, mc: S, pc: X, pbc: T, n: Y, o: e }
  let le, De
  return t && ([le, De] = t(W)), { render: ne, hydrate: le, createApp: Hw(ne, le) }
}
function za({ effect: e, update: t }, n) {
  e.allowRecurse = t.allowRecurse = n
}
function Lf(e, t, n = !1) {
  const i = e.children,
    a = t.children
  if (We(i) && We(a))
    for (let s = 0; s < i.length; s++) {
      const o = i[s]
      let r = a[s]
      r.shapeFlag & 1 &&
        !r.dynamicChildren &&
        ((r.patchFlag <= 0 || r.patchFlag === 32) && ((r = a[s] = ga(a[s])), (r.el = o.el)), n || Lf(o, r)),
        r.type === zr && (r.el = o.el)
    }
}
function qw(e) {
  const t = e.slice(),
    n = [0]
  let i, a, s, o, r
  const l = e.length
  for (i = 0; i < l; i++) {
    const c = e[i]
    if (c !== 0) {
      if (((a = n[n.length - 1]), e[a] < c)) {
        ;(t[i] = a), n.push(i)
        continue
      }
      for (s = 0, o = n.length - 1; s < o; ) (r = (s + o) >> 1), e[n[r]] < c ? (s = r + 1) : (o = r)
      c < e[n[s]] && (s > 0 && (t[i] = n[s - 1]), (n[s] = i))
    }
  }
  for (s = n.length, o = n[s - 1]; s-- > 0; ) (n[s] = o), (o = t[o])
  return n
}
const Zw = (e) => e.__isTeleport,
  Jo = (e) => e && (e.disabled || e.disabled === ''),
  dv = (e) => typeof SVGElement < 'u' && e instanceof SVGElement,
  ad = (e, t) => {
    const n = e && e.to
    return Ft(n) ? (t ? t(n) : null) : n
  },
  Jw = {
    __isTeleport: !0,
    process(e, t, n, i, a, s, o, r, l, c) {
      const {
          mc: u,
          pc: d,
          pbc: f,
          o: { insert: h, querySelector: v, createText: g, createComment: p }
        } = c,
        y = Jo(t.props)
      let { shapeFlag: b, children: x, dynamicChildren: w } = t
      if (e == null) {
        const C = (t.el = g('')),
          P = (t.anchor = g(''))
        h(C, n, i), h(P, n, i)
        const k = (t.target = ad(t.props, v)),
          S = (t.targetAnchor = g(''))
        k && (h(S, k), (o = o || dv(k)))
        const _ = (T, B) => {
          b & 16 && u(x, T, B, a, s, o, r, l)
        }
        y ? _(n, P) : k && _(k, S)
      } else {
        t.el = e.el
        const C = (t.anchor = e.anchor),
          P = (t.target = e.target),
          k = (t.targetAnchor = e.targetAnchor),
          S = Jo(e.props),
          _ = S ? n : P,
          T = S ? C : k
        if (
          ((o = o || dv(P)),
          w ? (f(e.dynamicChildren, w, _, a, s, o, r), Lf(e, t, !0)) : l || d(e, t, _, T, a, s, o, r, !1),
          y)
        )
          S || ll(t, n, C, c, 1)
        else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
          const B = (t.target = ad(t.props, v))
          B && ll(t, B, null, c, 0)
        } else S && ll(t, P, k, c, 1)
      }
      E0(t)
    },
    remove(e, t, n, i, { um: a, o: { remove: s } }, o) {
      const { shapeFlag: r, children: l, anchor: c, targetAnchor: u, target: d, props: f } = e
      if ((d && s(u), (o || !Jo(f)) && (s(c), r & 16)))
        for (let h = 0; h < l.length; h++) {
          const v = l[h]
          a(v, t, n, !0, !!v.dynamicChildren)
        }
    },
    move: ll,
    hydrate: Qw
  }
function ll(e, t, n, { o: { insert: i }, m: a }, s = 2) {
  s === 0 && i(e.targetAnchor, t, n)
  const { el: o, anchor: r, shapeFlag: l, children: c, props: u } = e,
    d = s === 2
  if ((d && i(o, t, n), (!d || Jo(u)) && l & 16)) for (let f = 0; f < c.length; f++) a(c[f], t, n, 2)
  d && i(r, t, n)
}
function Qw(e, t, n, i, a, s, { o: { nextSibling: o, parentNode: r, querySelector: l } }, c) {
  const u = (t.target = ad(t.props, l))
  if (u) {
    const d = u._lpa || u.firstChild
    if (t.shapeFlag & 16)
      if (Jo(t.props)) (t.anchor = c(o(e), t, r(e), n, i, a, s)), (t.targetAnchor = d)
      else {
        t.anchor = o(e)
        let f = d
        for (; f; )
          if (((f = o(f)), f && f.nodeType === 8 && f.data === 'teleport anchor')) {
            ;(t.targetAnchor = f), (u._lpa = t.targetAnchor && o(t.targetAnchor))
            break
          }
        c(d, t, u, n, i, a, s)
      }
    E0(t)
  }
  return t.anchor && o(t.anchor)
}
const eS = Jw
function E0(e) {
  const t = e.ctx
  if (t && t.ut) {
    let n = e.children[0].el
    for (; n !== e.targetAnchor; )
      n.nodeType === 1 && n.setAttribute('data-v-owner', t.uid), (n = n.nextSibling)
    t.ut()
  }
}
const Oe = Symbol.for('v-fgt'),
  zr = Symbol.for('v-txt'),
  li = Symbol.for('v-cmt'),
  gu = Symbol.for('v-stc'),
  Qo = []
let ni = null
function Re(e = !1) {
  Qo.push((ni = e ? null : []))
}
function tS() {
  Qo.pop(), (ni = Qo[Qo.length - 1] || null)
}
let yr = 1
function fv(e) {
  yr += e
}
function L0(e) {
  return (e.dynamicChildren = yr > 0 ? ni || zs : null), tS(), yr > 0 && ni && ni.push(e), e
}
function et(e, t, n, i, a, s) {
  return L0(z(e, t, n, i, a, s, !0))
}
function Ct(e, t, n, i, a) {
  return L0(m(e, t, n, i, a, !0))
}
function sd(e) {
  return e ? e.__v_isVNode === !0 : !1
}
function Ja(e, t) {
  return e.type === t.type && e.key === t.key
}
const Dc = '__vInternal',
  O0 = ({ key: e }) => e ?? null,
  Rl = ({ ref: e, ref_key: t, ref_for: n }) => (
    typeof e == 'number' && (e = '' + e),
    e != null ? (Ft(e) || Tt(e) || Je(e) ? { i: In, r: e, k: t, f: !!n } : e) : null
  )
function z(e, t = null, n = null, i = 0, a = null, s = e === Oe ? 0 : 1, o = !1, r = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && O0(t),
    ref: t && Rl(t),
    scopeId: Ec,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: s,
    patchFlag: i,
    dynamicProps: a,
    dynamicChildren: null,
    appContext: null,
    ctx: In
  }
  return (
    r ? (Of(l, n), s & 128 && e.normalize(l)) : n && (l.shapeFlag |= Ft(n) ? 8 : 16),
    yr > 0 && !o && ni && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && ni.push(l),
    l
  )
}
const m = nS
function nS(e, t = null, n = null, i = 0, a = null, s = !1) {
  if (((!e || e === S0) && (e = li), sd(e))) {
    const r = Zi(e, t, !0)
    return (
      n && Of(r, n),
      yr > 0 && !s && ni && (r.shapeFlag & 6 ? (ni[ni.indexOf(e)] = r) : ni.push(r)),
      (r.patchFlag |= -2),
      r
    )
  }
  if ((fS(e) && (e = e.__vccOpts), t)) {
    t = iS(t)
    let { class: r, style: l } = t
    r && !Ft(r) && (t.class = ki(r)), bt(l) && (n0(l) && !We(l) && (l = Nt({}, l)), (t.style = vf(l)))
  }
  const o = Ft(e) ? 1 : Sw(e) ? 128 : Zw(e) ? 64 : bt(e) ? 4 : Je(e) ? 2 : 0
  return z(e, t, n, i, a, o, s, !0)
}
function iS(e) {
  return e ? (n0(e) || Dc in e ? Nt({}, e) : e) : null
}
function Zi(e, t, n = !1) {
  const { props: i, ref: a, patchFlag: s, children: o } = e,
    r = t ? xe(i || {}, t) : i
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: r,
    key: r && O0(r),
    ref: t && t.ref ? (n && a ? (We(a) ? a.concat(Rl(t)) : [a, Rl(t)]) : Rl(t)) : a,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: o,
    target: e.target,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    patchFlag: t && e.type !== Oe ? (s === -1 ? 16 : s | 16) : s,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: e.transition,
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && Zi(e.ssContent),
    ssFallback: e.ssFallback && Zi(e.ssFallback),
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  }
}
function nt(e = ' ', t = 0) {
  return m(zr, null, e, t)
}
function ct(e = '', t = !1) {
  return t ? (Re(), Ct(li, null, e)) : m(li, null, e)
}
function _i(e) {
  return e == null || typeof e == 'boolean'
    ? m(li)
    : We(e)
    ? m(Oe, null, e.slice())
    : typeof e == 'object'
    ? ga(e)
    : m(zr, null, String(e))
}
function ga(e) {
  return (e.el === null && e.patchFlag !== -1) || e.memo ? e : Zi(e)
}
function Of(e, t) {
  let n = 0
  const { shapeFlag: i } = e
  if (t == null) t = null
  else if (We(t)) n = 16
  else if (typeof t == 'object')
    if (i & 65) {
      const a = t.default
      a && (a._c && (a._d = !1), Of(e, a()), a._c && (a._d = !0))
      return
    } else {
      n = 32
      const a = t._
      !a && !(Dc in t)
        ? (t._ctx = In)
        : a === 3 && In && (In.slots._ === 1 ? (t._ = 1) : ((t._ = 2), (e.patchFlag |= 1024)))
    }
  else
    Je(t)
      ? ((t = { default: t, _ctx: In }), (n = 32))
      : ((t = String(t)), i & 64 ? ((n = 16), (t = [nt(t)])) : (n = 8))
  ;(e.children = t), (e.shapeFlag |= n)
}
function xe(...e) {
  const t = {}
  for (let n = 0; n < e.length; n++) {
    const i = e[n]
    for (const a in i)
      if (a === 'class') t.class !== i.class && (t.class = ki([t.class, i.class]))
      else if (a === 'style') t.style = vf([t.style, i.style])
      else if (kc(a)) {
        const s = t[a],
          o = i[a]
        o && s !== o && !(We(s) && s.includes(o)) && (t[a] = s ? [].concat(s, o) : o)
      } else a !== '' && (t[a] = i[a])
  }
  return t
}
function gi(e, t, n, i = null) {
  Un(e, t, 7, [n, i])
}
const aS = C0()
let sS = 0
function oS(e, t, n) {
  const i = e.type,
    a = (t ? t.appContext : e.appContext) || aS,
    s = {
      uid: sS++,
      vnode: e,
      type: i,
      parent: t,
      appContext: a,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      scope: new jp(!0),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: t ? t.provides : Object.create(a.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: A0(i, a),
      emitsOptions: f0(i, a),
      emit: null,
      emitted: null,
      propsDefaults: _t,
      inheritAttrs: i.inheritAttrs,
      ctx: _t,
      data: _t,
      props: _t,
      attrs: _t,
      slots: _t,
      refs: _t,
      setupState: _t,
      setupContext: null,
      attrsProxy: null,
      slotsProxy: null,
      suspense: n,
      suspenseId: n ? n.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    }
  return (s.ctx = { _: s }), (s.root = t ? t.root : s), (s.emit = yw.bind(null, s)), e.ce && e.ce(s), s
}
let Kt = null
const If = () => Kt || In
let Df,
  As,
  hv = '__VUE_INSTANCE_SETTERS__'
;(As = Xu()[hv]) || (As = Xu()[hv] = []),
  As.push((e) => (Kt = e)),
  (Df = (e) => {
    As.length > 1 ? As.forEach((t) => t(e)) : As[0](e)
  })
const Ks = (e) => {
    Df(e), e.scope.on()
  },
  os = () => {
    Kt && Kt.scope.off(), Df(null)
  }
function I0(e) {
  return e.vnode.shapeFlag & 4
}
let br = !1
function rS(e, t = !1) {
  br = t
  const { props: n, children: i } = e.vnode,
    a = I0(e)
  Ww(e, n, a, t), Yw(e, i)
  const s = a ? lS(e, t) : void 0
  return (br = !1), s
}
function lS(e, t) {
  const n = e.type
  ;(e.accessCache = Object.create(null)), (e.proxy = xf(new Proxy(e.ctx, Dw)))
  const { setup: i } = n
  if (i) {
    const a = (e.setupContext = i.length > 1 ? uS(e) : null)
    Ks(e), ro()
    const s = ka(i, e, 0, [e.props, a])
    if ((lo(), os(), Np(s))) {
      if ((s.then(os, os), t))
        return s
          .then((o) => {
            vv(e, o, t)
          })
          .catch((o) => {
            Tc(o, e, 0)
          })
      e.asyncDep = s
    } else vv(e, s, t)
  } else D0(e, t)
}
function vv(e, t, n) {
  Je(t) ? (e.type.__ssrInlineRender ? (e.ssrRender = t) : (e.render = t)) : bt(t) && (e.setupState = o0(t)),
    D0(e, n)
}
let gv
function D0(e, t, n) {
  const i = e.type
  if (!e.render) {
    if (!t && gv && !i.render) {
      const a = i.template || Vf(e).template
      if (a) {
        const { isCustomElement: s, compilerOptions: o } = e.appContext.config,
          { delimiters: r, compilerOptions: l } = i,
          c = Nt(Nt({ isCustomElement: s, delimiters: r }, o), l)
        i.render = gv(a, c)
      }
    }
    e.render = i.render || ri
  }
  Ks(e), ro(), Fw(e), lo(), os()
}
function cS(e) {
  return (
    e.attrsProxy ||
    (e.attrsProxy = new Proxy(e.attrs, {
      get(t, n) {
        return An(e, 'get', '$attrs'), t[n]
      }
    }))
  )
}
function uS(e) {
  const t = (n) => {
    e.exposed = n || {}
  }
  return {
    get attrs() {
      return cS(e)
    },
    slots: e.slots,
    emit: e.emit,
    expose: t
  }
}
function Fc(e) {
  if (e.exposed)
    return (
      e.exposeProxy ||
      (e.exposeProxy = new Proxy(o0(xf(e.exposed)), {
        get(t, n) {
          if (n in t) return t[n]
          if (n in Zo) return Zo[n](e)
        },
        has(t, n) {
          return n in t || n in Zo
        }
      }))
    )
}
function dS(e, t = !0) {
  return Je(e) ? e.displayName || e.name : e.name || (t && e.__name)
}
function fS(e) {
  return Je(e) && '__vccOpts' in e
}
const A = (e, t) => fw(e, t, br)
function Ei(e, t, n) {
  const i = arguments.length
  return i === 2
    ? bt(t) && !We(t)
      ? sd(t)
        ? m(e, null, [t])
        : m(e, t)
      : m(e, null, t)
    : (i > 3 ? (n = Array.prototype.slice.call(arguments, 2)) : i === 3 && sd(n) && (n = [n]), m(e, t, n))
}
const hS = Symbol.for('v-scx'),
  vS = () => st(hS),
  gS = '3.3.4',
  mS = 'http://www.w3.org/2000/svg',
  Qa = typeof document < 'u' ? document : null,
  mv = Qa && Qa.createElement('template'),
  pS = {
    insert: (e, t, n) => {
      t.insertBefore(e, n || null)
    },
    remove: (e) => {
      const t = e.parentNode
      t && t.removeChild(e)
    },
    createElement: (e, t, n, i) => {
      const a = t ? Qa.createElementNS(mS, e) : Qa.createElement(e, n ? { is: n } : void 0)
      return e === 'select' && i && i.multiple != null && a.setAttribute('multiple', i.multiple), a
    },
    createText: (e) => Qa.createTextNode(e),
    createComment: (e) => Qa.createComment(e),
    setText: (e, t) => {
      e.nodeValue = t
    },
    setElementText: (e, t) => {
      e.textContent = t
    },
    parentNode: (e) => e.parentNode,
    nextSibling: (e) => e.nextSibling,
    querySelector: (e) => Qa.querySelector(e),
    setScopeId(e, t) {
      e.setAttribute(t, '')
    },
    insertStaticContent(e, t, n, i, a, s) {
      const o = n ? n.previousSibling : t.lastChild
      if (a && (a === s || a.nextSibling))
        for (; t.insertBefore(a.cloneNode(!0), n), !(a === s || !(a = a.nextSibling)); );
      else {
        mv.innerHTML = i ? `<svg>${e}</svg>` : e
        const r = mv.content
        if (i) {
          const l = r.firstChild
          for (; l.firstChild; ) r.appendChild(l.firstChild)
          r.removeChild(l)
        }
        t.insertBefore(r, n)
      }
      return [o ? o.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
    }
  }
function yS(e, t, n) {
  const i = e._vtc
  i && (t = (t ? [t, ...i] : [...i]).join(' ')),
    t == null ? e.removeAttribute('class') : n ? e.setAttribute('class', t) : (e.className = t)
}
function bS(e, t, n) {
  const i = e.style,
    a = Ft(n)
  if (n && !a) {
    if (t && !Ft(t)) for (const s in t) n[s] == null && od(i, s, '')
    for (const s in n) od(i, s, n[s])
  } else {
    const s = i.display
    a ? t !== n && (i.cssText = n) : t && e.removeAttribute('style'), '_vod' in e && (i.display = s)
  }
}
const pv = /\s*!important$/
function od(e, t, n) {
  if (We(n)) n.forEach((i) => od(e, t, i))
  else if ((n == null && (n = ''), t.startsWith('--'))) e.setProperty(t, n)
  else {
    const i = _S(e, t)
    pv.test(n) ? e.setProperty(oo(i), n.replace(pv, ''), 'important') : (e[i] = n)
  }
}
const yv = ['Webkit', 'Moz', 'ms'],
  mu = {}
function _S(e, t) {
  const n = mu[t]
  if (n) return n
  let i = Yn(t)
  if (i !== 'filter' && i in e) return (mu[t] = i)
  i = na(i)
  for (let a = 0; a < yv.length; a++) {
    const s = yv[a] + i
    if (s in e) return (mu[t] = s)
  }
  return t
}
const bv = 'http://www.w3.org/1999/xlink'
function xS(e, t, n, i, a) {
  if (i && t.startsWith('xlink:'))
    n == null ? e.removeAttributeNS(bv, t.slice(6, t.length)) : e.setAttributeNS(bv, t, n)
  else {
    const s = Ex(t)
    n == null || (s && !Hp(n)) ? e.removeAttribute(t) : e.setAttribute(t, s ? '' : n)
  }
}
function wS(e, t, n, i, a, s, o) {
  if (t === 'innerHTML' || t === 'textContent') {
    i && o(i, a, s), (e[t] = n ?? '')
    return
  }
  const r = e.tagName
  if (t === 'value' && r !== 'PROGRESS' && !r.includes('-')) {
    e._value = n
    const c = r === 'OPTION' ? e.getAttribute('value') : e.value,
      u = n ?? ''
    c !== u && (e.value = u), n == null && e.removeAttribute(t)
    return
  }
  let l = !1
  if (n === '' || n == null) {
    const c = typeof e[t]
    c === 'boolean'
      ? (n = Hp(n))
      : n == null && c === 'string'
      ? ((n = ''), (l = !0))
      : c === 'number' && ((n = 0), (l = !0))
  }
  try {
    e[t] = n
  } catch {}
  l && e.removeAttribute(t)
}
function Ds(e, t, n, i) {
  e.addEventListener(t, n, i)
}
function SS(e, t, n, i) {
  e.removeEventListener(t, n, i)
}
function kS(e, t, n, i, a = null) {
  const s = e._vei || (e._vei = {}),
    o = s[t]
  if (i && o) o.value = i
  else {
    const [r, l] = CS(t)
    if (i) {
      const c = (s[t] = PS(i, a))
      Ds(e, r, c, l)
    } else o && (SS(e, r, o, l), (s[t] = void 0))
  }
}
const _v = /(?:Once|Passive|Capture)$/
function CS(e) {
  let t
  if (_v.test(e)) {
    t = {}
    let i
    for (; (i = e.match(_v)); ) (e = e.slice(0, e.length - i[0].length)), (t[i[0].toLowerCase()] = !0)
  }
  return [e[2] === ':' ? e.slice(3) : oo(e.slice(2)), t]
}
let pu = 0
const MS = Promise.resolve(),
  AS = () => pu || (MS.then(() => (pu = 0)), (pu = Date.now()))
function PS(e, t) {
  const n = (i) => {
    if (!i._vts) i._vts = Date.now()
    else if (i._vts <= n.attached) return
    Un(TS(i, n.value), t, 5, [i])
  }
  return (n.value = e), (n.attached = AS()), n
}
function TS(e, t) {
  if (We(t)) {
    const n = e.stopImmediatePropagation
    return (
      (e.stopImmediatePropagation = () => {
        n.call(e), (e._stopped = !0)
      }),
      t.map((i) => (a) => !a._stopped && i && i(a))
    )
  } else return t
}
const xv = /^on[a-z]/,
  VS = (e, t, n, i, a = !1, s, o, r, l) => {
    t === 'class'
      ? yS(e, i, a)
      : t === 'style'
      ? bS(e, n, i)
      : kc(t)
      ? uf(t) || kS(e, t, n, i, o)
      : (t[0] === '.' ? ((t = t.slice(1)), !0) : t[0] === '^' ? ((t = t.slice(1)), !1) : ES(e, t, i, a))
      ? wS(e, t, i, s, o, r, l)
      : (t === 'true-value' ? (e._trueValue = i) : t === 'false-value' && (e._falseValue = i), xS(e, t, i, a))
  }
function ES(e, t, n, i) {
  return i
    ? !!(t === 'innerHTML' || t === 'textContent' || (t in e && xv.test(t) && Je(n)))
    : t === 'spellcheck' ||
      t === 'draggable' ||
      t === 'translate' ||
      t === 'form' ||
      (t === 'list' && e.tagName === 'INPUT') ||
      (t === 'type' && e.tagName === 'TEXTAREA') ||
      (xv.test(t) && Ft(n))
    ? !1
    : t in e
}
const da = 'transition',
  Vo = 'animation',
  Pi = (e, { slots: t }) => Ei(Aw, R0(e), t)
Pi.displayName = 'Transition'
const F0 = {
    name: String,
    type: String,
    css: { type: Boolean, default: !0 },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  },
  LS = (Pi.props = Nt({}, g0, F0)),
  Ha = (e, t = []) => {
    We(e) ? e.forEach((n) => n(...t)) : e && e(...t)
  },
  wv = (e) => (e ? (We(e) ? e.some((t) => t.length > 1) : e.length > 1) : !1)
function R0(e) {
  const t = {}
  for (const O in e) O in F0 || (t[O] = e[O])
  if (e.css === !1) return t
  const {
      name: n = 'v',
      type: i,
      duration: a,
      enterFromClass: s = `${n}-enter-from`,
      enterActiveClass: o = `${n}-enter-active`,
      enterToClass: r = `${n}-enter-to`,
      appearFromClass: l = s,
      appearActiveClass: c = o,
      appearToClass: u = r,
      leaveFromClass: d = `${n}-leave-from`,
      leaveActiveClass: f = `${n}-leave-active`,
      leaveToClass: h = `${n}-leave-to`
    } = e,
    v = OS(a),
    g = v && v[0],
    p = v && v[1],
    {
      onBeforeEnter: y,
      onEnter: b,
      onEnterCancelled: x,
      onLeave: w,
      onLeaveCancelled: C,
      onBeforeAppear: P = y,
      onAppear: k = b,
      onAppearCancelled: S = x
    } = t,
    _ = (O, N, Q) => {
      ha(O, N ? u : r), ha(O, N ? c : o), Q && Q()
    },
    T = (O, N) => {
      ;(O._isLeaving = !1), ha(O, d), ha(O, h), ha(O, f), N && N()
    },
    B = (O) => (N, Q) => {
      const ue = O ? k : b,
        j = () => _(N, O, Q)
      Ha(ue, [N, j]),
        Sv(() => {
          ha(N, O ? l : s), Ni(N, O ? u : r), wv(ue) || kv(N, i, g, j)
        })
    }
  return Nt(t, {
    onBeforeEnter(O) {
      Ha(y, [O]), Ni(O, s), Ni(O, o)
    },
    onBeforeAppear(O) {
      Ha(P, [O]), Ni(O, l), Ni(O, c)
    },
    onEnter: B(!1),
    onAppear: B(!0),
    onLeave(O, N) {
      O._isLeaving = !0
      const Q = () => T(O, N)
      Ni(O, d),
        N0(),
        Ni(O, f),
        Sv(() => {
          O._isLeaving && (ha(O, d), Ni(O, h), wv(w) || kv(O, i, p, Q))
        }),
        Ha(w, [O, Q])
    },
    onEnterCancelled(O) {
      _(O, !1), Ha(x, [O])
    },
    onAppearCancelled(O) {
      _(O, !0), Ha(S, [O])
    },
    onLeaveCancelled(O) {
      T(O), Ha(C, [O])
    }
  })
}
function OS(e) {
  if (e == null) return null
  if (bt(e)) return [yu(e.enter), yu(e.leave)]
  {
    const t = yu(e)
    return [t, t]
  }
}
function yu(e) {
  return Cx(e)
}
function Ni(e, t) {
  t.split(/\s+/).forEach((n) => n && e.classList.add(n)), (e._vtc || (e._vtc = new Set())).add(t)
}
function ha(e, t) {
  t.split(/\s+/).forEach((i) => i && e.classList.remove(i))
  const { _vtc: n } = e
  n && (n.delete(t), n.size || (e._vtc = void 0))
}
function Sv(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e)
  })
}
let IS = 0
function kv(e, t, n, i) {
  const a = (e._endId = ++IS),
    s = () => {
      a === e._endId && i()
    }
  if (n) return setTimeout(s, n)
  const { type: o, timeout: r, propCount: l } = B0(e, t)
  if (!o) return i()
  const c = o + 'end'
  let u = 0
  const d = () => {
      e.removeEventListener(c, f), s()
    },
    f = (h) => {
      h.target === e && ++u >= l && d()
    }
  setTimeout(() => {
    u < l && d()
  }, r + 1),
    e.addEventListener(c, f)
}
function B0(e, t) {
  const n = window.getComputedStyle(e),
    i = (v) => (n[v] || '').split(', '),
    a = i(`${da}Delay`),
    s = i(`${da}Duration`),
    o = Cv(a, s),
    r = i(`${Vo}Delay`),
    l = i(`${Vo}Duration`),
    c = Cv(r, l)
  let u = null,
    d = 0,
    f = 0
  t === da
    ? o > 0 && ((u = da), (d = o), (f = s.length))
    : t === Vo
    ? c > 0 && ((u = Vo), (d = c), (f = l.length))
    : ((d = Math.max(o, c)),
      (u = d > 0 ? (o > c ? da : Vo) : null),
      (f = u ? (u === da ? s.length : l.length) : 0))
  const h = u === da && /\b(transform|all)(,|$)/.test(i(`${da}Property`).toString())
  return { type: u, timeout: d, propCount: f, hasTransform: h }
}
function Cv(e, t) {
  for (; e.length < t.length; ) e = e.concat(e)
  return Math.max(...t.map((n, i) => Mv(n) + Mv(e[i])))
}
function Mv(e) {
  return Number(e.slice(0, -1).replace(',', '.')) * 1e3
}
function N0() {
  return document.body.offsetHeight
}
const $0 = new WeakMap(),
  z0 = new WeakMap(),
  H0 = {
    name: 'TransitionGroup',
    props: Nt({}, LS, { tag: String, moveClass: String }),
    setup(e, { slots: t }) {
      const n = If(),
        i = v0()
      let a, s
      return (
        x0(() => {
          if (!a.length) return
          const o = e.moveClass || `${e.name || 'v'}-move`
          if (!$S(a[0].el, n.vnode.el, o)) return
          a.forEach(RS), a.forEach(BS)
          const r = a.filter(NS)
          N0(),
            r.forEach((l) => {
              const c = l.el,
                u = c.style
              Ni(c, o), (u.transform = u.webkitTransform = u.transitionDuration = '')
              const d = (c._moveCb = (f) => {
                ;(f && f.target !== c) ||
                  ((!f || /transform$/.test(f.propertyName)) &&
                    (c.removeEventListener('transitionend', d), (c._moveCb = null), ha(c, o)))
              })
              c.addEventListener('transitionend', d)
            })
        }),
        () => {
          const o = Qe(e),
            r = R0(o)
          let l = o.tag || Oe
          ;(a = s), (s = t.default ? Af(t.default()) : [])
          for (let c = 0; c < s.length; c++) {
            const u = s[c]
            u.key != null && pr(u, mr(u, r, i, n))
          }
          if (a)
            for (let c = 0; c < a.length; c++) {
              const u = a[c]
              pr(u, mr(u, r, i, n)), $0.set(u, u.el.getBoundingClientRect())
            }
          return m(l, null, s)
        }
      )
    }
  },
  DS = (e) => delete e.mode
H0.props
const FS = H0
function RS(e) {
  const t = e.el
  t._moveCb && t._moveCb(), t._enterCb && t._enterCb()
}
function BS(e) {
  z0.set(e, e.el.getBoundingClientRect())
}
function NS(e) {
  const t = $0.get(e),
    n = z0.get(e),
    i = t.left - n.left,
    a = t.top - n.top
  if (i || a) {
    const s = e.el.style
    return (s.transform = s.webkitTransform = `translate(${i}px,${a}px)`), (s.transitionDuration = '0s'), e
  }
}
function $S(e, t, n) {
  const i = e.cloneNode()
  e._vtc &&
    e._vtc.forEach((o) => {
      o.split(/\s+/).forEach((r) => r && i.classList.remove(r))
    }),
    n.split(/\s+/).forEach((o) => o && i.classList.add(o)),
    (i.style.display = 'none')
  const a = t.nodeType === 1 ? t : t.parentNode
  a.appendChild(i)
  const { hasTransform: s } = B0(i)
  return a.removeChild(i), s
}
const Av = (e) => {
  const t = e.props['onUpdate:modelValue'] || !1
  return We(t) ? (n) => Dl(t, n) : t
}
function zS(e) {
  e.target.composing = !0
}
function Pv(e) {
  const t = e.target
  t.composing && ((t.composing = !1), t.dispatchEvent(new Event('input')))
}
const HS = {
    created(e, { modifiers: { lazy: t, trim: n, number: i } }, a) {
      e._assign = Av(a)
      const s = i || (a.props && a.props.type === 'number')
      Ds(e, t ? 'change' : 'input', (o) => {
        if (o.target.composing) return
        let r = e.value
        n && (r = r.trim()), s && (r = Gu(r)), e._assign(r)
      }),
        n &&
          Ds(e, 'change', () => {
            e.value = e.value.trim()
          }),
        t || (Ds(e, 'compositionstart', zS), Ds(e, 'compositionend', Pv), Ds(e, 'change', Pv))
    },
    mounted(e, { value: t }) {
      e.value = t ?? ''
    },
    beforeUpdate(e, { value: t, modifiers: { lazy: n, trim: i, number: a } }, s) {
      if (
        ((e._assign = Av(s)),
        e.composing ||
          (document.activeElement === e &&
            e.type !== 'range' &&
            (n || (i && e.value.trim() === t) || ((a || e.type === 'number') && Gu(e.value) === t))))
      )
        return
      const o = t ?? ''
      e.value !== o && (e.value = o)
    }
  },
  WS = ['ctrl', 'shift', 'alt', 'meta'],
  jS = {
    stop: (e) => e.stopPropagation(),
    prevent: (e) => e.preventDefault(),
    self: (e) => e.target !== e.currentTarget,
    ctrl: (e) => !e.ctrlKey,
    shift: (e) => !e.shiftKey,
    alt: (e) => !e.altKey,
    meta: (e) => !e.metaKey,
    left: (e) => 'button' in e && e.button !== 0,
    middle: (e) => 'button' in e && e.button !== 1,
    right: (e) => 'button' in e && e.button !== 2,
    exact: (e, t) => WS.some((n) => e[`${n}Key`] && !t.includes(n))
  },
  US =
    (e, t) =>
    (n, ...i) => {
      for (let a = 0; a < t.length; a++) {
        const s = jS[t[a]]
        if (s && s(n, t)) return
      }
      return e(n, ...i)
    },
  Li = {
    beforeMount(e, { value: t }, { transition: n }) {
      ;(e._vod = e.style.display === 'none' ? '' : e.style.display), n && t ? n.beforeEnter(e) : Eo(e, t)
    },
    mounted(e, { value: t }, { transition: n }) {
      n && t && n.enter(e)
    },
    updated(e, { value: t, oldValue: n }, { transition: i }) {
      !t != !n &&
        (i
          ? t
            ? (i.beforeEnter(e), Eo(e, !0), i.enter(e))
            : i.leave(e, () => {
                Eo(e, !1)
              })
          : Eo(e, t))
    },
    beforeUnmount(e, { value: t }) {
      Eo(e, t)
    }
  }
function Eo(e, t) {
  e.style.display = t ? e._vod : 'none'
}
const YS = Nt({ patchProp: VS }, pS)
let Tv
function GS() {
  return Tv || (Tv = Xw(YS))
}
const XS = (...e) => {
  const t = GS().createApp(...e),
    { mount: n } = t
  return (
    (t.mount = (i) => {
      const a = KS(i)
      if (!a) return
      const s = t._component
      !Je(s) && !s.render && !s.template && (s.template = a.innerHTML), (a.innerHTML = '')
      const o = n(a, !1, a instanceof SVGElement)
      return a instanceof Element && (a.removeAttribute('v-cloak'), a.setAttribute('data-v-app', '')), o
    }),
    t
  )
}
function KS(e) {
  return Ft(e) ? document.querySelector(e) : e
}
const yt = typeof window < 'u',
  Ff = yt && 'IntersectionObserver' in window,
  qS = yt && ('ontouchstart' in window || window.navigator.maxTouchPoints > 0)
function Vv(e, t, n) {
  ZS(e, t), t.set(e, n)
}
function ZS(e, t) {
  if (t.has(e)) throw new TypeError('Cannot initialize the same private elements twice on an object')
}
function JS(e, t, n) {
  var i = W0(e, t, 'set')
  return QS(e, i, n), n
}
function QS(e, t, n) {
  if (t.set) t.set.call(e, n)
  else {
    if (!t.writable) throw new TypeError('attempted to set read only private field')
    t.value = n
  }
}
function Wa(e, t) {
  var n = W0(e, t, 'get')
  return ek(e, n)
}
function W0(e, t, n) {
  if (!t.has(e)) throw new TypeError('attempted to ' + n + ' private field on non-instance')
  return t.get(e)
}
function ek(e, t) {
  return t.get ? t.get.call(e) : t.value
}
function j0(e, t, n) {
  const i = t.length - 1
  if (i < 0) return e === void 0 ? n : e
  for (let a = 0; a < i; a++) {
    if (e == null) return n
    e = e[t[a]]
  }
  return e == null || e[t[i]] === void 0 ? n : e[t[i]]
}
function co(e, t) {
  if (e === t) return !0
  if (
    (e instanceof Date && t instanceof Date && e.getTime() !== t.getTime()) ||
    e !== Object(e) ||
    t !== Object(t)
  )
    return !1
  const n = Object.keys(e)
  return n.length !== Object.keys(t).length ? !1 : n.every((i) => co(e[i], t[i]))
}
function rd(e, t, n) {
  return e == null || !t || typeof t != 'string'
    ? n
    : e[t] !== void 0
    ? e[t]
    : ((t = t.replace(/\[(\w+)\]/g, '.$1')), (t = t.replace(/^\./, '')), j0(e, t.split('.'), n))
}
function Si(e, t, n) {
  if (t == null) return e === void 0 ? n : e
  if (e !== Object(e)) {
    if (typeof t != 'function') return n
    const a = t(e, n)
    return typeof a > 'u' ? n : a
  }
  if (typeof t == 'string') return rd(e, t, n)
  if (Array.isArray(t)) return j0(e, t, n)
  if (typeof t != 'function') return n
  const i = t(e, n)
  return typeof i > 'u' ? n : i
}
function ji(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
  return Array.from({ length: e }, (n, i) => t + i)
}
function Ve(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'px'
  if (!(e == null || e === '')) return isNaN(+e) ? String(e) : isFinite(+e) ? `${Number(e)}${t}` : void 0
}
function ic(e) {
  return e !== null && typeof e == 'object' && !Array.isArray(e)
}
function ld(e) {
  return e && '$el' in e ? e.$el : e
}
const Ev = Object.freeze({
    enter: 13,
    tab: 9,
    delete: 46,
    esc: 27,
    space: 32,
    up: 38,
    down: 40,
    left: 37,
    right: 39,
    end: 35,
    home: 36,
    del: 46,
    backspace: 8,
    insert: 45,
    pageup: 33,
    pagedown: 34,
    shift: 16
  }),
  cd = Object.freeze({
    enter: 'Enter',
    tab: 'Tab',
    delete: 'Delete',
    esc: 'Escape',
    space: 'Space',
    up: 'ArrowUp',
    down: 'ArrowDown',
    left: 'ArrowLeft',
    right: 'ArrowRight',
    end: 'End',
    home: 'Home',
    del: 'Delete',
    backspace: 'Backspace',
    insert: 'Insert',
    pageup: 'PageUp',
    pagedown: 'PageDown',
    shift: 'Shift'
  })
function U0(e) {
  return Object.keys(e)
}
function ts(e, t) {
  return t.every((n) => e.hasOwnProperty(n))
}
function ds(e, t, n) {
  const i = Object.create(null),
    a = Object.create(null)
  for (const s in e)
    t.some((o) => (o instanceof RegExp ? o.test(s) : o === s)) && !(n != null && n.some((o) => o === s))
      ? (i[s] = e[s])
      : (a[s] = e[s])
  return [i, a]
}
function Gn(e, t) {
  const n = { ...e }
  return t.forEach((i) => delete n[i]), n
}
const Y0 = /^on[^a-z]/,
  Rf = (e) => Y0.test(e),
  tk = [
    'onAfterscriptexecute',
    'onAnimationcancel',
    'onAnimationend',
    'onAnimationiteration',
    'onAnimationstart',
    'onAuxclick',
    'onBeforeinput',
    'onBeforescriptexecute',
    'onChange',
    'onClick',
    'onCompositionend',
    'onCompositionstart',
    'onCompositionupdate',
    'onContextmenu',
    'onCopy',
    'onCut',
    'onDblclick',
    'onFocusin',
    'onFocusout',
    'onFullscreenchange',
    'onFullscreenerror',
    'onGesturechange',
    'onGestureend',
    'onGesturestart',
    'onGotpointercapture',
    'onInput',
    'onKeydown',
    'onKeypress',
    'onKeyup',
    'onLostpointercapture',
    'onMousedown',
    'onMousemove',
    'onMouseout',
    'onMouseover',
    'onMouseup',
    'onMousewheel',
    'onPaste',
    'onPointercancel',
    'onPointerdown',
    'onPointerenter',
    'onPointerleave',
    'onPointermove',
    'onPointerout',
    'onPointerover',
    'onPointerup',
    'onReset',
    'onSelect',
    'onSubmit',
    'onTouchcancel',
    'onTouchend',
    'onTouchmove',
    'onTouchstart',
    'onTransitioncancel',
    'onTransitionend',
    'onTransitionrun',
    'onTransitionstart',
    'onWheel'
  ]
function ys(e) {
  const [t, n] = ds(e, [Y0]),
    i = Gn(t, tk),
    [a, s] = ds(n, ['class', 'style', 'id', /^data-/])
  return Object.assign(a, t), Object.assign(s, i), [a, s]
}
function Dn(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e]
}
function cn(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
    n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
  return Math.max(t, Math.min(n, e))
}
function Lv(e) {
  const t = e.toString().trim()
  return t.includes('.') ? t.length - t.indexOf('.') - 1 : 0
}
function Ov(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : '0'
  return e + n.repeat(Math.max(0, t - e.length))
}
function nk(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1
  const n = []
  let i = 0
  for (; i < e.length; ) n.push(e.substr(i, t)), (i += t)
  return n
}
function Iv(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3
  if (e < t) return `${e} B`
  const n = t === 1024 ? ['Ki', 'Mi', 'Gi'] : ['k', 'M', 'G']
  let i = -1
  for (; Math.abs(e) >= t && i < n.length - 1; ) (e /= t), ++i
  return `${e.toFixed(1)} ${n[i]}B`
}
function Wn() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    n = arguments.length > 2 ? arguments[2] : void 0
  const i = {}
  for (const a in e) i[a] = e[a]
  for (const a in t) {
    const s = e[a],
      o = t[a]
    if (ic(s) && ic(o)) {
      i[a] = Wn(s, o, n)
      continue
    }
    if (Array.isArray(s) && Array.isArray(o) && n) {
      i[a] = n(s, o)
      continue
    }
    i[a] = o
  }
  return i
}
function G0(e) {
  return e.map((t) => (t.type === Oe ? G0(t.children) : t)).flat()
}
function rs() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ''
  if (rs.cache.has(e)) return rs.cache.get(e)
  const t = e
    .replace(/[^a-z]/gi, '-')
    .replace(/\B([A-Z])/g, '-$1')
    .toLowerCase()
  return rs.cache.set(e, t), t
}
rs.cache = new Map()
function er(e, t) {
  if (!t || typeof t != 'object') return []
  if (Array.isArray(t)) return t.map((n) => er(e, n)).flat(1)
  if (Array.isArray(t.children)) return t.children.map((n) => er(e, n)).flat(1)
  if (t.component) {
    if (Object.getOwnPropertySymbols(t.component.provides).includes(e)) return [t.component]
    if (t.component.subTree) return er(e, t.component.subTree).flat(1)
  }
  return []
}
var cl = new WeakMap(),
  Ps = new WeakMap()
class ik {
  constructor(t) {
    Vv(this, cl, { writable: !0, value: [] }), Vv(this, Ps, { writable: !0, value: 0 }), (this.size = t)
  }
  push(t) {
    ;(Wa(this, cl)[Wa(this, Ps)] = t), JS(this, Ps, (Wa(this, Ps) + 1) % this.size)
  }
  values() {
    return Wa(this, cl)
      .slice(Wa(this, Ps))
      .concat(Wa(this, cl).slice(0, Wa(this, Ps)))
  }
}
function ak(e) {
  return 'touches' in e
    ? { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY }
    : { clientX: e.clientX, clientY: e.clientY }
}
function Bf(e) {
  const t = yn({}),
    n = A(e)
  return (
    Ut(
      () => {
        for (const i in n.value) t[i] = n.value[i]
      },
      { flush: 'sync' }
    ),
    Sf(t)
  )
}
function ac(e, t) {
  return e.includes(t)
}
function X0(e) {
  return e[2].toLowerCase() + e.slice(3)
}
const Mi = () => [Function, Array]
function Dv(e, t) {
  return (
    (t = 'on' + na(t)),
    !!(e[t] || e[`${t}Once`] || e[`${t}Capture`] || e[`${t}OnceCapture`] || e[`${t}CaptureOnce`])
  )
}
function Nf(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i]
  if (Array.isArray(e)) for (const a of e) a(...n)
  else typeof e == 'function' && e(...n)
}
function _r(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
  const n = ['button', '[href]', 'input:not([type="hidden"])', 'select', 'textarea', '[tabindex]']
    .map((i) => `${i}${t ? ':not([tabindex="-1"])' : ''}:not([disabled])`)
    .join(', ')
  return [...e.querySelectorAll(n)]
}
function K0(e, t, n) {
  let i,
    a = e.indexOf(document.activeElement)
  const s = t === 'next' ? 1 : -1
  do (a += s), (i = e[a])
  while ((!i || i.offsetParent == null || !((n == null ? void 0 : n(i)) ?? !0)) && a < e.length && a >= 0)
  return i
}
function sc(e, t) {
  var i, a, s, o
  const n = _r(e)
  if (!t)
    (e === document.activeElement || !e.contains(document.activeElement)) && ((i = n[0]) == null || i.focus())
  else if (t === 'first') (a = n[0]) == null || a.focus()
  else if (t === 'last') (s = n.at(-1)) == null || s.focus()
  else if (typeof t == 'number') (o = n[t]) == null || o.focus()
  else {
    const r = K0(n, t)
    r ? r.focus() : sc(e, t === 'next' ? 'first' : 'last')
  }
}
function q0() {}
function qs(e, t) {
  if (!(yt && typeof CSS < 'u' && typeof CSS.supports < 'u' && CSS.supports(`selector(${t})`))) return null
  try {
    return !!e && e.matches(t)
  } catch {
    return null
  }
}
const Z0 = ['top', 'bottom'],
  sk = ['start', 'end', 'left', 'right']
function ud(e, t) {
  let [n, i] = e.split(' ')
  return i || (i = ac(Z0, n) ? 'start' : ac(sk, n) ? 'top' : 'center'), { side: dd(n, t), align: dd(i, t) }
}
function dd(e, t) {
  return e === 'start' ? (t ? 'right' : 'left') : e === 'end' ? (t ? 'left' : 'right') : e
}
function bu(e) {
  return {
    side: { center: 'center', top: 'bottom', bottom: 'top', left: 'right', right: 'left' }[e.side],
    align: e.align
  }
}
function _u(e) {
  return {
    side: e.side,
    align: { center: 'center', top: 'bottom', bottom: 'top', left: 'right', right: 'left' }[e.align]
  }
}
function Fv(e) {
  return { side: e.align, align: e.side }
}
function Rv(e) {
  return ac(Z0, e.side) ? 'y' : 'x'
}
class Us {
  constructor(t) {
    let { x: n, y: i, width: a, height: s } = t
    ;(this.x = n), (this.y = i), (this.width = a), (this.height = s)
  }
  get top() {
    return this.y
  }
  get bottom() {
    return this.y + this.height
  }
  get left() {
    return this.x
  }
  get right() {
    return this.x + this.width
  }
}
function Bv(e, t) {
  return {
    x: { before: Math.max(0, t.left - e.left), after: Math.max(0, e.right - t.right) },
    y: { before: Math.max(0, t.top - e.top), after: Math.max(0, e.bottom - t.bottom) }
  }
}
function $f(e) {
  const t = e.getBoundingClientRect(),
    n = getComputedStyle(e),
    i = n.transform
  if (i) {
    let a, s, o, r, l
    if (i.startsWith('matrix3d('))
      (a = i.slice(9, -1).split(/, /)), (s = +a[0]), (o = +a[5]), (r = +a[12]), (l = +a[13])
    else if (i.startsWith('matrix('))
      (a = i.slice(7, -1).split(/, /)), (s = +a[0]), (o = +a[3]), (r = +a[4]), (l = +a[5])
    else return new Us(t)
    const c = n.transformOrigin,
      u = t.x - r - (1 - s) * parseFloat(c),
      d = t.y - l - (1 - o) * parseFloat(c.slice(c.indexOf(' ') + 1)),
      f = s ? t.width / s : e.offsetWidth + 1,
      h = o ? t.height / o : e.offsetHeight + 1
    return new Us({ x: u, y: d, width: f, height: h })
  } else return new Us(t)
}
function ns(e, t, n) {
  if (typeof e.animate > 'u') return { finished: Promise.resolve() }
  let i
  try {
    i = e.animate(t, n)
  } catch {
    return { finished: Promise.resolve() }
  }
  return (
    typeof i.finished > 'u' &&
      (i.finished = new Promise((a) => {
        i.onfinish = () => {
          a(i)
        }
      })),
    i
  )
}
const Bl = new WeakMap()
function ok(e, t) {
  Object.keys(t).forEach((n) => {
    if (Rf(n)) {
      const i = X0(n),
        a = Bl.get(e)
      if (t[n] == null)
        a == null ||
          a.forEach((s) => {
            const [o, r] = s
            o === i && (e.removeEventListener(i, r), a.delete(s))
          })
      else if (!a || ![...a].some((s) => s[0] === i && s[1] === t[n])) {
        e.addEventListener(i, t[n])
        const s = a || new Set()
        s.add([i, t[n]]), Bl.has(e) || Bl.set(e, s)
      }
    } else t[n] == null ? e.removeAttribute(n) : e.setAttribute(n, t[n])
  })
}
function rk(e, t) {
  Object.keys(t).forEach((n) => {
    if (Rf(n)) {
      const i = X0(n),
        a = Bl.get(e)
      a == null ||
        a.forEach((s) => {
          const [o, r] = s
          o === i && (e.removeEventListener(i, r), a.delete(s))
        })
    } else e.removeAttribute(n)
  })
}
const Ts = 2.4,
  Nv = 0.2126729,
  $v = 0.7151522,
  zv = 0.072175,
  lk = 0.55,
  ck = 0.58,
  uk = 0.57,
  dk = 0.62,
  ul = 0.03,
  Hv = 1.45,
  fk = 5e-4,
  hk = 1.25,
  vk = 1.25,
  Wv = 0.078,
  jv = 12.82051282051282,
  dl = 0.06,
  Uv = 0.001
function Yv(e, t) {
  const n = (e.r / 255) ** Ts,
    i = (e.g / 255) ** Ts,
    a = (e.b / 255) ** Ts,
    s = (t.r / 255) ** Ts,
    o = (t.g / 255) ** Ts,
    r = (t.b / 255) ** Ts
  let l = n * Nv + i * $v + a * zv,
    c = s * Nv + o * $v + r * zv
  if ((l <= ul && (l += (ul - l) ** Hv), c <= ul && (c += (ul - c) ** Hv), Math.abs(c - l) < fk)) return 0
  let u
  if (c > l) {
    const d = (c ** lk - l ** ck) * hk
    u = d < Uv ? 0 : d < Wv ? d - d * jv * dl : d - dl
  } else {
    const d = (c ** dk - l ** uk) * vk
    u = d > -Uv ? 0 : d > -Wv ? d - d * jv * dl : d + dl
  }
  return u * 100
}
function gk(e, t) {
  t = Array.isArray(t)
    ? t
        .slice(0, -1)
        .map((n) => `'${n}'`)
        .join(', ') + ` or '${t.at(-1)}'`
    : `'${t}'`
}
const oc = 0.20689655172413793,
  mk = (e) => (e > oc ** 3 ? Math.cbrt(e) : e / (3 * oc ** 2) + 4 / 29),
  pk = (e) => (e > oc ? e ** 3 : 3 * oc ** 2 * (e - 4 / 29))
function J0(e) {
  const t = mk,
    n = t(e[1])
  return [116 * n - 16, 500 * (t(e[0] / 0.95047) - n), 200 * (n - t(e[2] / 1.08883))]
}
function Q0(e) {
  const t = pk,
    n = (e[0] + 16) / 116
  return [t(n + e[1] / 500) * 0.95047, t(n), t(n - e[2] / 200) * 1.08883]
}
const yk = [
    [3.2406, -1.5372, -0.4986],
    [-0.9689, 1.8758, 0.0415],
    [0.0557, -0.204, 1.057]
  ],
  bk = (e) => (e <= 0.0031308 ? e * 12.92 : 1.055 * e ** (1 / 2.4) - 0.055),
  _k = [
    [0.4124, 0.3576, 0.1805],
    [0.2126, 0.7152, 0.0722],
    [0.0193, 0.1192, 0.9505]
  ],
  xk = (e) => (e <= 0.04045 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4)
function ey(e) {
  const t = Array(3),
    n = bk,
    i = yk
  for (let a = 0; a < 3; ++a) t[a] = Math.round(cn(n(i[a][0] * e[0] + i[a][1] * e[1] + i[a][2] * e[2])) * 255)
  return { r: t[0], g: t[1], b: t[2] }
}
function zf(e) {
  let { r: t, g: n, b: i } = e
  const a = [0, 0, 0],
    s = xk,
    o = _k
  ;(t = s(t / 255)), (n = s(n / 255)), (i = s(i / 255))
  for (let r = 0; r < 3; ++r) a[r] = o[r][0] * t + o[r][1] * n + o[r][2] * i
  return a
}
function Gv(e) {
  return !!e && /^(#|var\(--|(rgb|hsl)a?\()/.test(e)
}
const Xv = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/,
  wk = {
    rgb: (e, t, n, i) => ({ r: e, g: t, b: n, a: i }),
    rgba: (e, t, n, i) => ({ r: e, g: t, b: n, a: i }),
    hsl: (e, t, n, i) => Kv({ h: e, s: t, l: n, a: i }),
    hsla: (e, t, n, i) => Kv({ h: e, s: t, l: n, a: i }),
    hsv: (e, t, n, i) => Ji({ h: e, s: t, v: n, a: i }),
    hsva: (e, t, n, i) => Ji({ h: e, s: t, v: n, a: i })
  }
function jn(e) {
  if (typeof e == 'number') return { r: (e & 16711680) >> 16, g: (e & 65280) >> 8, b: e & 255 }
  if (typeof e == 'string' && Xv.test(e)) {
    const { groups: t } = e.match(Xv),
      { fn: n, values: i } = t,
      a = i
        .split(/,\s*/)
        .map((s) =>
          s.endsWith('%') && ['hsl', 'hsla', 'hsv', 'hsva'].includes(n) ? parseFloat(s) / 100 : parseFloat(s)
        )
    return wk[n](...a)
  } else if (typeof e == 'string') {
    let t = e.startsWith('#') ? e.slice(1) : e
    return (
      [3, 4].includes(t.length)
        ? (t = t
            .split('')
            .map((n) => n + n)
            .join(''))
        : [6, 8].includes(t.length),
      sy(t)
    )
  } else if (typeof e == 'object') {
    if (ts(e, ['r', 'g', 'b'])) return e
    if (ts(e, ['h', 's', 'l'])) return Ji(Hf(e))
    if (ts(e, ['h', 's', 'v'])) return Ji(e)
  }
  throw new TypeError(`Invalid color: ${e == null ? e : String(e) || e.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`)
}
function Ji(e) {
  const { h: t, s: n, v: i, a } = e,
    s = (r) => {
      const l = (r + t / 60) % 6
      return i - i * n * Math.max(Math.min(l, 4 - l, 1), 0)
    },
    o = [s(5), s(3), s(1)].map((r) => Math.round(r * 255))
  return { r: o[0], g: o[1], b: o[2], a }
}
function Kv(e) {
  return Ji(Hf(e))
}
function Rc(e) {
  if (!e) return { h: 0, s: 1, v: 1, a: 1 }
  const t = e.r / 255,
    n = e.g / 255,
    i = e.b / 255,
    a = Math.max(t, n, i),
    s = Math.min(t, n, i)
  let o = 0
  a !== s &&
    (a === t
      ? (o = 60 * (0 + (n - i) / (a - s)))
      : a === n
      ? (o = 60 * (2 + (i - t) / (a - s)))
      : a === i && (o = 60 * (4 + (t - n) / (a - s)))),
    o < 0 && (o = o + 360)
  const r = a === 0 ? 0 : (a - s) / a,
    l = [o, r, a]
  return { h: l[0], s: l[1], v: l[2], a: e.a }
}
function ty(e) {
  const { h: t, s: n, v: i, a } = e,
    s = i - (i * n) / 2,
    o = s === 1 || s === 0 ? 0 : (i - s) / Math.min(s, 1 - s)
  return { h: t, s: o, l: s, a }
}
function Hf(e) {
  const { h: t, s: n, l: i, a } = e,
    s = i + n * Math.min(i, 1 - i),
    o = s === 0 ? 0 : 2 - (2 * i) / s
  return { h: t, s: o, v: s, a }
}
function ny(e) {
  let { r: t, g: n, b: i, a } = e
  return a === void 0 ? `rgb(${t}, ${n}, ${i})` : `rgba(${t}, ${n}, ${i}, ${a})`
}
function iy(e) {
  return ny(Ji(e))
}
function fl(e) {
  const t = Math.round(e).toString(16)
  return ('00'.substr(0, 2 - t.length) + t).toUpperCase()
}
function ay(e) {
  let { r: t, g: n, b: i, a } = e
  return `#${[fl(t), fl(n), fl(i), a !== void 0 ? fl(Math.round(a * 255)) : ''].join('')}`
}
function sy(e) {
  e = kk(e)
  let [t, n, i, a] = nk(e, 2).map((s) => parseInt(s, 16))
  return (a = a === void 0 ? a : a / 255), { r: t, g: n, b: i, a }
}
function Sk(e) {
  const t = sy(e)
  return Rc(t)
}
function oy(e) {
  return ay(Ji(e))
}
function kk(e) {
  return (
    e.startsWith('#') && (e = e.slice(1)),
    (e = e.replace(/([^0-9a-f])/gi, 'F')),
    (e.length === 3 || e.length === 4) &&
      (e = e
        .split('')
        .map((t) => t + t)
        .join('')),
    e.length !== 6 && (e = Ov(Ov(e, 6), 8, 'F')),
    e
  )
}
function Ck(e, t) {
  const n = J0(zf(e))
  return (n[0] = n[0] + t * 10), ey(Q0(n))
}
function Mk(e, t) {
  const n = J0(zf(e))
  return (n[0] = n[0] - t * 10), ey(Q0(n))
}
function fd(e) {
  const t = jn(e)
  return zf(t)[1]
}
function Ak(e, t) {
  const n = fd(e),
    i = fd(t),
    a = Math.max(n, i),
    s = Math.min(n, i)
  return (a + 0.05) / (s + 0.05)
}
function ry(e) {
  const t = Math.abs(Yv(jn(0), jn(e)))
  return Math.abs(Yv(jn(16777215), jn(e))) > Math.min(t, 50) ? '#fff' : '#000'
}
function ee(e, t) {
  return (n) =>
    Object.keys(e).reduce((i, a) => {
      const o = typeof e[a] == 'object' && e[a] != null && !Array.isArray(e[a]) ? e[a] : { type: e[a] }
      return (
        n && a in n ? (i[a] = { ...o, default: n[a] }) : (i[a] = o), t && !i[a].source && (i[a].source = t), i
      )
    }, {})
}
const Me = ee(
  { class: [String, Array], style: { type: [String, Array, Object], default: null } },
  'component'
)
function Xn(e) {
  if (((e._setup = e._setup ?? e.setup), !e.name)) return e
  if (e._setup) {
    e.props = ee(e.props ?? {}, e.name)()
    const t = Object.keys(e.props)
    ;(e.filterProps = function (i) {
      return ds(i, t, ['class', 'style'])
    }),
      (e.props._as = String),
      (e.setup = function (i, a) {
        const s = Uf()
        if (!s.value) return e._setup(i, a)
        const { props: o, provideSubDefaults: r } = Dk(i, i._as ?? e.name, s),
          l = e._setup(o, a)
        return r(), l
      })
  }
  return e
}
function fe() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0
  return (t) => (e ? Xn : hn)(t)
}
function hi(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'div',
    n = arguments.length > 2 ? arguments[2] : void 0
  return fe()({
    name: n ?? na(Yn(e.replace(/__/g, '-'))),
    props: { tag: { type: String, default: t }, ...Me() },
    setup(i, a) {
      let { slots: s } = a
      return () => {
        var o
        return Ei(
          i.tag,
          { class: [e, i.class], style: i.style },
          (o = s.default) == null ? void 0 : o.call(s)
        )
      }
    }
  })
}
function ly(e) {
  if (typeof e.getRootNode != 'function') {
    for (; e.parentNode; ) e = e.parentNode
    return e !== document ? null : document
  }
  const t = e.getRootNode()
  return t !== document && t.getRootNode({ composed: !0 }) !== document ? null : t
}
const xr = 'cubic-bezier(0.4, 0, 0.2, 1)',
  Pk = 'cubic-bezier(0.0, 0, 0.2, 1)',
  Tk = 'cubic-bezier(0.4, 0, 1, 1)'
function Jt(e, t) {
  const n = If()
  if (!n) throw new Error(`[Vuetify] ${e} ${t || 'must be called from inside a setup function'}`)
  return n
}
function aa() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'composables'
  const t = Jt(e).type
  return rs((t == null ? void 0 : t.aliasName) || (t == null ? void 0 : t.name))
}
let cy = 0,
  Nl = new WeakMap()
function vn() {
  const e = Jt('getUid')
  if (Nl.has(e)) return Nl.get(e)
  {
    const t = cy++
    return Nl.set(e, t), t
  }
}
vn.reset = () => {
  ;(cy = 0), (Nl = new WeakMap())
}
function Wf(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1
  for (; e; ) {
    if (t ? Vk(e) : jf(e)) return e
    e = e.parentElement
  }
  return document.scrollingElement
}
function rc(e, t) {
  const n = []
  if (t && e && !t.contains(e)) return n
  for (; e && (jf(e) && n.push(e), e !== t); ) e = e.parentElement
  return n
}
function jf(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1
  const t = window.getComputedStyle(e)
  return t.overflowY === 'scroll' || (t.overflowY === 'auto' && e.scrollHeight > e.clientHeight)
}
function Vk(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1
  const t = window.getComputedStyle(e)
  return ['scroll', 'auto'].includes(t.overflowY)
}
function Ek(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Jt('injectSelf')
  const { provides: n } = t
  if (n && e in n) return n[e]
}
function Lk(e) {
  for (; e; ) {
    if (window.getComputedStyle(e).position === 'fixed') return !0
    e = e.offsetParent
  }
  return !1
}
function ge(e) {
  const t = Jt('useRender')
  t.render = e
}
const Zs = Symbol.for('vuetify:defaults')
function Ok(e) {
  return te(e)
}
function Uf() {
  const e = st(Zs)
  if (!e) throw new Error('[Vuetify] Could not find defaults instance')
  return e
}
function zt(e, t) {
  const n = Uf(),
    i = te(e),
    a = A(() => {
      if (Xe(t == null ? void 0 : t.disabled)) return n.value
      const o = Xe(t == null ? void 0 : t.scoped),
        r = Xe(t == null ? void 0 : t.reset),
        l = Xe(t == null ? void 0 : t.root)
      if (i.value == null && !(o || r || l)) return n.value
      let c = Wn(i.value, { prev: n.value })
      if (o) return c
      if (r || l) {
        const u = Number(r || 1 / 0)
        for (let d = 0; d <= u && !(!c || !('prev' in c)); d++) c = c.prev
        return c && typeof l == 'string' && l in c && (c = Wn(Wn(c, { prev: c }), c[l])), c
      }
      return c.prev ? Wn(c.prev, c) : c
    })
  return Vt(Zs, a), a
}
function Ik(e, t) {
  var n, i
  return (
    typeof ((n = e.props) == null ? void 0 : n[t]) < 'u' ||
    typeof ((i = e.props) == null ? void 0 : i[rs(t)]) < 'u'
  )
}
function Dk() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    t = arguments.length > 1 ? arguments[1] : void 0,
    n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Uf()
  const i = Jt('useDefaults')
  if (((t = t ?? i.type.name ?? i.type.__name), !t))
    throw new Error('[Vuetify] Could not determine component name')
  const a = A(() => {
      var l
      return (l = n.value) == null ? void 0 : l[e._as ?? t]
    }),
    s = new Proxy(e, {
      get(l, c) {
        var d, f, h, v
        const u = Reflect.get(l, c)
        return c === 'class' || c === 'style'
          ? [(d = a.value) == null ? void 0 : d[c], u].filter((g) => g != null)
          : typeof c == 'string' && !Ik(i.vnode, c)
          ? ((f = a.value) == null ? void 0 : f[c]) ??
            ((v = (h = n.value) == null ? void 0 : h.global) == null ? void 0 : v[c]) ??
            u
          : u
      }
    }),
    o = Ce()
  Ut(() => {
    if (a.value) {
      const l = Object.entries(a.value).filter((c) => {
        let [u] = c
        return u.startsWith(u[0].toUpperCase())
      })
      o.value = l.length ? Object.fromEntries(l) : void 0
    } else o.value = void 0
  })
  function r() {
    const l = Ek(Zs, i)
    Vt(
      Zs,
      A(() => (o.value ? Wn((l == null ? void 0 : l.value) ?? {}, o.value) : l == null ? void 0 : l.value))
    )
  }
  return { props: s, provideSubDefaults: r }
}
const Bc = ['sm', 'md', 'lg', 'xl', 'xxl'],
  hd = Symbol.for('vuetify:display'),
  qv = { mobileBreakpoint: 'lg', thresholds: { xs: 0, sm: 600, md: 960, lg: 1280, xl: 1920, xxl: 2560 } },
  Fk = function () {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : qv
    return Wn(qv, e)
  }
function Zv(e) {
  return yt && !e ? window.innerWidth : (typeof e == 'object' && e.clientWidth) || 0
}
function Jv(e) {
  return yt && !e ? window.innerHeight : (typeof e == 'object' && e.clientHeight) || 0
}
function Qv(e) {
  const t = yt && !e ? window.navigator.userAgent : 'ssr'
  function n(v) {
    return !!t.match(v)
  }
  const i = n(/android/i),
    a = n(/iphone|ipad|ipod/i),
    s = n(/cordova/i),
    o = n(/electron/i),
    r = n(/chrome/i),
    l = n(/edge/i),
    c = n(/firefox/i),
    u = n(/opera/i),
    d = n(/win/i),
    f = n(/mac/i),
    h = n(/linux/i)
  return {
    android: i,
    ios: a,
    cordova: s,
    electron: o,
    chrome: r,
    edge: l,
    firefox: c,
    opera: u,
    win: d,
    mac: f,
    linux: h,
    touch: qS,
    ssr: t === 'ssr'
  }
}
function Rk(e, t) {
  const { thresholds: n, mobileBreakpoint: i } = Fk(e),
    a = Ce(Jv(t)),
    s = Ce(Qv(t)),
    o = yn({}),
    r = Ce(Zv(t))
  function l() {
    ;(a.value = Jv()), (r.value = Zv())
  }
  function c() {
    l(), (s.value = Qv())
  }
  return (
    Ut(() => {
      const u = r.value < n.sm,
        d = r.value < n.md && !u,
        f = r.value < n.lg && !(d || u),
        h = r.value < n.xl && !(f || d || u),
        v = r.value < n.xxl && !(h || f || d || u),
        g = r.value >= n.xxl,
        p = u ? 'xs' : d ? 'sm' : f ? 'md' : h ? 'lg' : v ? 'xl' : 'xxl',
        y = typeof i == 'number' ? i : n[i],
        b = r.value < y
      ;(o.xs = u),
        (o.sm = d),
        (o.md = f),
        (o.lg = h),
        (o.xl = v),
        (o.xxl = g),
        (o.smAndUp = !u),
        (o.mdAndUp = !(u || d)),
        (o.lgAndUp = !(u || d || f)),
        (o.xlAndUp = !(u || d || f || h)),
        (o.smAndDown = !(f || h || v || g)),
        (o.mdAndDown = !(h || v || g)),
        (o.lgAndDown = !(v || g)),
        (o.xlAndDown = !g),
        (o.name = p),
        (o.height = a.value),
        (o.width = r.value),
        (o.mobile = b),
        (o.mobileBreakpoint = i),
        (o.platform = s.value),
        (o.thresholds = n)
    }),
    yt && window.addEventListener('resize', l, { passive: !0 }),
    { ...Sf(o), update: c, ssr: !!t }
  )
}
function bs() {
  const e = st(hd)
  if (!e) throw new Error('Could not find Vuetify display injection')
  return e
}
const Bk = {
    collapse: 'mdi-chevron-up',
    complete: 'mdi-check',
    cancel: 'mdi-close-circle',
    close: 'mdi-close',
    delete: 'mdi-close-circle',
    clear: 'mdi-close-circle',
    success: 'mdi-check-circle',
    info: 'mdi-information',
    warning: 'mdi-alert-circle',
    error: 'mdi-close-circle',
    prev: 'mdi-chevron-left',
    next: 'mdi-chevron-right',
    checkboxOn: 'mdi-checkbox-marked',
    checkboxOff: 'mdi-checkbox-blank-outline',
    checkboxIndeterminate: 'mdi-minus-box',
    delimiter: 'mdi-circle',
    sortAsc: 'mdi-arrow-up',
    sortDesc: 'mdi-arrow-down',
    expand: 'mdi-chevron-down',
    menu: 'mdi-menu',
    subgroup: 'mdi-menu-down',
    dropdown: 'mdi-menu-down',
    radioOn: 'mdi-radiobox-marked',
    radioOff: 'mdi-radiobox-blank',
    edit: 'mdi-pencil',
    ratingEmpty: 'mdi-star-outline',
    ratingFull: 'mdi-star',
    ratingHalf: 'mdi-star-half-full',
    loading: 'mdi-cached',
    first: 'mdi-page-first',
    last: 'mdi-page-last',
    unfold: 'mdi-unfold-more-horizontal',
    file: 'mdi-paperclip',
    plus: 'mdi-plus',
    minus: 'mdi-minus',
    calendar: 'mdi-calendar'
  },
  Nk = { component: (e) => Ei(Gf, { ...e, class: 'mdi' }) },
  Ye = [String, Function, Object, Array],
  vd = Symbol.for('vuetify:icons'),
  Nc = ee({ icon: { type: Ye }, tag: { type: String, required: !0 } }, 'icon'),
  gd = fe()({
    name: 'VComponentIcon',
    props: Nc(),
    setup(e, t) {
      let { slots: n } = t
      return () => {
        const i = e.icon
        return m(e.tag, null, {
          default: () => {
            var a
            return [e.icon ? m(i, null, null) : (a = n.default) == null ? void 0 : a.call(n)]
          }
        })
      }
    }
  }),
  Yf = Xn({
    name: 'VSvgIcon',
    inheritAttrs: !1,
    props: Nc(),
    setup(e, t) {
      let { attrs: n } = t
      return () =>
        m(e.tag, xe(n, { style: null }), {
          default: () => [
            m(
              'svg',
              {
                class: 'v-icon__svg',
                xmlns: 'http://www.w3.org/2000/svg',
                viewBox: '0 0 24 24',
                role: 'img',
                'aria-hidden': 'true'
              },
              [
                Array.isArray(e.icon)
                  ? e.icon.map((i) =>
                      Array.isArray(i)
                        ? m('path', { d: i[0], 'fill-opacity': i[1] }, null)
                        : m('path', { d: i }, null)
                    )
                  : m('path', { d: e.icon }, null)
              ]
            )
          ]
        })
    }
  }),
  $k = Xn({
    name: 'VLigatureIcon',
    props: Nc(),
    setup(e) {
      return () => m(e.tag, null, { default: () => [e.icon] })
    }
  }),
  Gf = Xn({
    name: 'VClassIcon',
    props: Nc(),
    setup(e) {
      return () => m(e.tag, { class: e.icon }, null)
    }
  }),
  zk = { svg: { component: Yf }, class: { component: Gf } }
function Hk(e) {
  return Wn(
    {
      defaultSet: 'mdi',
      sets: { ...zk, mdi: Nk },
      aliases: {
        ...Bk,
        vuetify: [
          'M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z',
          ['M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z', 0.6]
        ],
        'vuetify-outline':
          'svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z'
      }
    },
    e
  )
}
const Wk = (e) => {
    const t = st(vd)
    if (!t) throw new Error('Missing Vuetify Icons provide!')
    return {
      iconData: A(() => {
        var l
        const i = Xe(e)
        if (!i) return { component: gd }
        let a = i
        if (
          (typeof a == 'string' &&
            ((a = a.trim()), a.startsWith('$') && (a = (l = t.aliases) == null ? void 0 : l[a.slice(1)])),
          !a)
        )
          throw new Error(`Could not find aliased icon "${i}"`)
        if (Array.isArray(a)) return { component: Yf, icon: a }
        if (typeof a != 'string') return { component: gd, icon: a }
        const s = Object.keys(t.sets).find((c) => typeof a == 'string' && a.startsWith(`${c}:`)),
          o = s ? a.slice(s.length + 1) : a
        return { component: t.sets[s ?? t.defaultSet].component, icon: o }
      })
    }
  },
  jk = {
    badge: 'Badge',
    open: 'Open',
    close: 'Close',
    dataIterator: { noResultsText: 'No matching records found', loadingText: 'Loading items...' },
    dataTable: {
      itemsPerPageText: 'Rows per page:',
      ariaLabel: {
        sortDescending: 'Sorted descending.',
        sortAscending: 'Sorted ascending.',
        sortNone: 'Not sorted.',
        activateNone: 'Activate to remove sorting.',
        activateDescending: 'Activate to sort descending.',
        activateAscending: 'Activate to sort ascending.'
      },
      sortBy: 'Sort by'
    },
    dataFooter: {
      itemsPerPageText: 'Items per page:',
      itemsPerPageAll: 'All',
      nextPage: 'Next page',
      prevPage: 'Previous page',
      firstPage: 'First page',
      lastPage: 'Last page',
      pageText: '{0}-{1} of {2}'
    },
    dateRangeInput: { divider: 'to' },
    datePicker: {
      ok: 'OK',
      cancel: 'Cancel',
      range: { title: 'Select dates', header: 'Enter dates' },
      title: 'Select date',
      header: 'Enter date',
      input: { placeholder: 'Enter date' }
    },
    noDataText: 'No data available',
    carousel: {
      prev: 'Previous visual',
      next: 'Next visual',
      ariaLabel: { delimiter: 'Carousel slide {0} of {1}' }
    },
    calendar: { moreEvents: '{0} more' },
    input: {
      clear: 'Clear {0}',
      prependAction: '{0} prepended action',
      appendAction: '{0} appended action',
      otp: 'Please enter OTP character {0}'
    },
    fileInput: { counter: '{0} files', counterSize: '{0} files ({1} in total)' },
    timePicker: { am: 'AM', pm: 'PM' },
    pagination: {
      ariaLabel: {
        root: 'Pagination Navigation',
        next: 'Next page',
        previous: 'Previous page',
        page: 'Go to page {0}',
        currentPage: 'Page {0}, Current page',
        first: 'First page',
        last: 'Last page'
      }
    },
    stepper: { next: 'Next', prev: 'Previous' },
    rating: { ariaLabel: { item: 'Rating {0} of {1}' } },
    loading: 'Loading...',
    infiniteScroll: { loadMore: 'Load more', empty: 'No more' }
  },
  Uk = {
    af: !1,
    ar: !0,
    bg: !1,
    ca: !1,
    ckb: !1,
    cs: !1,
    de: !1,
    el: !1,
    en: !1,
    es: !1,
    et: !1,
    fa: !0,
    fi: !1,
    fr: !1,
    hr: !1,
    hu: !1,
    he: !0,
    id: !1,
    it: !1,
    ja: !1,
    ko: !1,
    lv: !1,
    lt: !1,
    nl: !1,
    no: !1,
    pl: !1,
    pt: !1,
    ro: !1,
    ru: !1,
    sk: !1,
    sl: !1,
    srCyrl: !1,
    srLatn: !1,
    sv: !1,
    th: !1,
    tr: !1,
    az: !1,
    uk: !1,
    vi: !1,
    zhHans: !1,
    zhHant: !1
  }
function Aa(e, t) {
  let n
  function i() {
    ;(n = Ac()),
      n.run(() =>
        t.length
          ? t(() => {
              n == null || n.stop(), i()
            })
          : t()
      )
  }
  Pe(
    e,
    (a) => {
      a && !n ? i() : a || (n == null || n.stop(), (n = void 0))
    },
    { immediate: !0 }
  ),
    Mn(() => {
      n == null || n.stop()
    })
}
function Ge(e, t, n) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (d) => d,
    a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (d) => d
  const s = Jt('useProxiedModel'),
    o = te(e[t] !== void 0 ? e[t] : n),
    r = rs(t),
    c = A(
      r !== t
        ? () => {
            var d, f, h, v
            return (
              e[t],
              !!(
                (((d = s.vnode.props) != null && d.hasOwnProperty(t)) ||
                  ((f = s.vnode.props) != null && f.hasOwnProperty(r))) &&
                (((h = s.vnode.props) != null && h.hasOwnProperty(`onUpdate:${t}`)) ||
                  ((v = s.vnode.props) != null && v.hasOwnProperty(`onUpdate:${r}`)))
              )
            )
          }
        : () => {
            var d, f
            return (
              e[t],
              !!(
                (d = s.vnode.props) != null &&
                d.hasOwnProperty(t) &&
                (f = s.vnode.props) != null &&
                f.hasOwnProperty(`onUpdate:${t}`)
              )
            )
          }
    )
  Aa(
    () => !c.value,
    () => {
      Pe(
        () => e[t],
        (d) => {
          o.value = d
        }
      )
    }
  )
  const u = A({
    get() {
      const d = e[t]
      return i(c.value ? d : o.value)
    },
    set(d) {
      const f = a(d),
        h = Qe(c.value ? e[t] : o.value)
      h === f || i(h) === d || ((o.value = f), s == null || s.emit(`update:${t}`, f))
    }
  })
  return Object.defineProperty(u, 'externalValue', { get: () => (c.value ? e[t] : o.value) }), u
}
const eg = '$vuetify.',
  tg = (e, t) => e.replace(/\{(\d+)\}/g, (n, i) => String(t[+i])),
  uy = (e, t, n) =>
    function (i) {
      for (var a = arguments.length, s = new Array(a > 1 ? a - 1 : 0), o = 1; o < a; o++)
        s[o - 1] = arguments[o]
      if (!i.startsWith(eg)) return tg(i, s)
      const r = i.replace(eg, ''),
        l = e.value && n.value[e.value],
        c = t.value && n.value[t.value]
      let u = rd(l, r, null)
      return (
        u || (`${i}${e.value}`, (u = rd(c, r, null))), u || (u = i), typeof u != 'string' && (u = i), tg(u, s)
      )
    }
function dy(e, t) {
  return (n, i) => new Intl.NumberFormat([e.value, t.value], i).format(n)
}
function xu(e, t, n) {
  const i = Ge(e, t, e[t] ?? n.value)
  return (
    (i.value = e[t] ?? n.value),
    Pe(n, (a) => {
      e[t] == null && (i.value = n.value)
    }),
    i
  )
}
function fy(e) {
  return (t) => {
    const n = xu(t, 'locale', e.current),
      i = xu(t, 'fallback', e.fallback),
      a = xu(t, 'messages', e.messages)
    return {
      name: 'vuetify',
      current: n,
      fallback: i,
      messages: a,
      t: uy(n, i, a),
      n: dy(n, i),
      provide: fy({ current: n, fallback: i, messages: a })
    }
  }
}
function Yk(e) {
  const t = Ce((e == null ? void 0 : e.locale) ?? 'en'),
    n = Ce((e == null ? void 0 : e.fallback) ?? 'en'),
    i = te({ en: jk, ...(e == null ? void 0 : e.messages) })
  return {
    name: 'vuetify',
    current: t,
    fallback: n,
    messages: i,
    t: uy(t, n, i),
    n: dy(t, n),
    provide: fy({ current: t, fallback: n, messages: i })
  }
}
const Js = Symbol.for('vuetify:locale')
function Gk(e) {
  return e.name != null
}
function Xk(e) {
  const t =
      e != null && e.adapter && Gk(e == null ? void 0 : e.adapter) ? (e == null ? void 0 : e.adapter) : Yk(e),
    n = qk(t, e)
  return { ...t, ...n }
}
function Kn() {
  const e = st(Js)
  if (!e) throw new Error('[Vuetify] Could not find injected locale instance')
  return e
}
function Kk(e) {
  const t = st(Js)
  if (!t) throw new Error('[Vuetify] Could not find injected locale instance')
  const n = t.provide(e),
    i = Zk(n, t.rtl, e),
    a = { ...n, ...i }
  return Vt(Js, a), a
}
function qk(e, t) {
  const n = te((t == null ? void 0 : t.rtl) ?? Uk),
    i = A(() => n.value[e.current.value] ?? !1)
  return { isRtl: i, rtl: n, rtlClasses: A(() => `v-locale--is-${i.value ? 'rtl' : 'ltr'}`) }
}
function Zk(e, t, n) {
  const i = A(() => n.rtl ?? t.value[e.current.value] ?? !1)
  return { isRtl: i, rtl: t, rtlClasses: A(() => `v-locale--is-${i.value ? 'rtl' : 'ltr'}`) }
}
function Qt() {
  const e = st(Js)
  if (!e) throw new Error('[Vuetify] Could not find injected rtl instance')
  return { isRtl: e.isRtl, rtlClasses: e.rtlClasses }
}
const wr = Symbol.for('vuetify:theme'),
  ot = ee({ theme: String }, 'theme'),
  Lo = {
    defaultTheme: 'light',
    variations: { colors: [], lighten: 0, darken: 0 },
    themes: {
      light: {
        dark: !1,
        colors: {
          background: '#FFFFFF',
          surface: '#FFFFFF',
          'surface-bright': '#FFFFFF',
          'surface-variant': '#424242',
          'on-surface-variant': '#EEEEEE',
          primary: '#6200EE',
          'primary-darken-1': '#3700B3',
          secondary: '#03DAC6',
          'secondary-darken-1': '#018786',
          error: '#B00020',
          info: '#2196F3',
          success: '#4CAF50',
          warning: '#FB8C00'
        },
        variables: {
          'border-color': '#000000',
          'border-opacity': 0.12,
          'high-emphasis-opacity': 0.87,
          'medium-emphasis-opacity': 0.6,
          'disabled-opacity': 0.38,
          'idle-opacity': 0.04,
          'hover-opacity': 0.04,
          'focus-opacity': 0.12,
          'selected-opacity': 0.08,
          'activated-opacity': 0.12,
          'pressed-opacity': 0.12,
          'dragged-opacity': 0.08,
          'theme-kbd': '#212529',
          'theme-on-kbd': '#FFFFFF',
          'theme-code': '#F5F5F5',
          'theme-on-code': '#000000'
        }
      },
      dark: {
        dark: !0,
        colors: {
          background: '#121212',
          surface: '#212121',
          'surface-bright': '#ccbfd6',
          'surface-variant': '#a3a3a3',
          'on-surface-variant': '#424242',
          primary: '#BB86FC',
          'primary-darken-1': '#3700B3',
          secondary: '#03DAC5',
          'secondary-darken-1': '#03DAC5',
          error: '#CF6679',
          info: '#2196F3',
          success: '#4CAF50',
          warning: '#FB8C00'
        },
        variables: {
          'border-color': '#FFFFFF',
          'border-opacity': 0.12,
          'high-emphasis-opacity': 1,
          'medium-emphasis-opacity': 0.7,
          'disabled-opacity': 0.5,
          'idle-opacity': 0.1,
          'hover-opacity': 0.04,
          'focus-opacity': 0.12,
          'selected-opacity': 0.08,
          'activated-opacity': 0.12,
          'pressed-opacity': 0.16,
          'dragged-opacity': 0.08,
          'theme-kbd': '#212529',
          'theme-on-kbd': '#FFFFFF',
          'theme-code': '#343434',
          'theme-on-code': '#CCCCCC'
        }
      }
    }
  }
function Jk() {
  var n, i
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Lo
  if (!e) return { ...Lo, isDisabled: !0 }
  const t = {}
  for (const [a, s] of Object.entries(e.themes ?? {})) {
    const o =
      s.dark || a === 'dark'
        ? (n = Lo.themes) == null
          ? void 0
          : n.dark
        : (i = Lo.themes) == null
        ? void 0
        : i.light
    t[a] = Wn(o, s)
  }
  return Wn(Lo, { ...e, themes: t })
}
function Qk(e) {
  const t = Jk(e),
    n = te(t.defaultTheme),
    i = te(t.themes),
    a = A(() => {
      const u = {}
      for (const [d, f] of Object.entries(i.value)) {
        const h = (u[d] = { ...f, colors: { ...f.colors } })
        if (t.variations)
          for (const v of t.variations.colors) {
            const g = h.colors[v]
            if (g)
              for (const p of ['lighten', 'darken']) {
                const y = p === 'lighten' ? Ck : Mk
                for (const b of ji(t.variations[p], 1)) h.colors[`${v}-${p}-${b}`] = ay(y(jn(g), b))
              }
          }
        for (const v of Object.keys(h.colors)) {
          if (/^on-[a-z]/.test(v) || h.colors[`on-${v}`]) continue
          const g = `on-${v}`,
            p = jn(h.colors[v])
          h.colors[g] = ry(p)
        }
      }
      return u
    }),
    s = A(() => a.value[n.value]),
    o = A(() => {
      const u = []
      s.value.dark && ja(u, ':root', ['color-scheme: dark']), ja(u, ':root', ng(s.value))
      for (const [v, g] of Object.entries(a.value))
        ja(u, `.v-theme--${v}`, [`color-scheme: ${g.dark ? 'dark' : 'normal'}`, ...ng(g)])
      const d = [],
        f = [],
        h = new Set(Object.values(a.value).flatMap((v) => Object.keys(v.colors)))
      for (const v of h)
        /^on-[a-z]/.test(v)
          ? ja(f, `.${v}`, [`color: rgb(var(--v-theme-${v})) !important`])
          : (ja(d, `.bg-${v}`, [
              `--v-theme-overlay-multiplier: var(--v-theme-${v}-overlay-multiplier)`,
              `background-color: rgb(var(--v-theme-${v})) !important`,
              `color: rgb(var(--v-theme-on-${v})) !important`
            ]),
            ja(f, `.text-${v}`, [`color: rgb(var(--v-theme-${v})) !important`]),
            ja(f, `.border-${v}`, [`--v-border-color: var(--v-theme-${v})`]))
      return u.push(...d, ...f), u.map((v, g) => (g === 0 ? v : `    ${v}`)).join('')
    })
  function r() {
    return { style: [{ children: o.value, id: 'vuetify-theme-stylesheet', nonce: t.cspNonce || !1 }] }
  }
  function l(u) {
    if (t.isDisabled) return
    const d = u._context.provides.usehead
    if (d)
      if (d.push) {
        const h = d.push(r)
        yt &&
          Pe(o, () => {
            h.patch(r)
          })
      } else yt ? (d.addHeadObjs(A(r)), Ut(() => d.updateDOM())) : d.addHeadObjs(r())
    else {
      let v = function () {
        if (typeof document < 'u' && !h) {
          const g = document.createElement('style')
          ;(g.type = 'text/css'),
            (g.id = 'vuetify-theme-stylesheet'),
            t.cspNonce && g.setAttribute('nonce', t.cspNonce),
            (h = g),
            document.head.appendChild(h)
        }
        h && (h.innerHTML = o.value)
      }
      var f = v
      let h = yt ? document.getElementById('vuetify-theme-stylesheet') : null
      yt ? Pe(o, v, { immediate: !0 }) : v()
    }
  }
  const c = A(() => (t.isDisabled ? void 0 : `v-theme--${n.value}`))
  return {
    install: l,
    isDisabled: t.isDisabled,
    name: n,
    themes: i,
    current: s,
    computedThemes: a,
    themeClasses: c,
    styles: o,
    global: { name: n, current: s }
  }
}
function ut(e) {
  Jt('provideTheme')
  const t = st(wr, null)
  if (!t) throw new Error('Could not find Vuetify theme injection')
  const n = A(() => e.theme ?? t.name.value),
    i = A(() => t.themes.value[n.value]),
    a = A(() => (t.isDisabled ? void 0 : `v-theme--${n.value}`)),
    s = { ...t, name: n, current: i, themeClasses: a }
  return Vt(wr, s), s
}
function hy() {
  Jt('useTheme')
  const e = st(wr, null)
  if (!e) throw new Error('Could not find Vuetify theme injection')
  return e
}
function ja(e, t, n) {
  e.push(
    `${t} {
`,
    ...n.map(
      (i) => `  ${i};
`
    ),
    `}
`
  )
}
function ng(e) {
  const t = e.dark ? 2 : 1,
    n = e.dark ? 1 : 2,
    i = []
  for (const [a, s] of Object.entries(e.colors)) {
    const o = jn(s)
    i.push(`--v-theme-${a}: ${o.r},${o.g},${o.b}`),
      a.startsWith('on-') || i.push(`--v-theme-${a}-overlay-multiplier: ${fd(s) > 0.18 ? t : n}`)
  }
  for (const [a, s] of Object.entries(e.variables)) {
    const o = typeof s == 'string' && s.startsWith('#') ? jn(s) : void 0,
      r = o ? `${o.r}, ${o.g}, ${o.b}` : void 0
    i.push(`--v-${a}: ${r ?? s}`)
  }
  return i
}
const md = {
  '001': 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AG: 0,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AS: 0,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BD: 0,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BR: 0,
  BS: 0,
  BT: 0,
  BW: 0,
  BY: 1,
  BZ: 0,
  CA: 0,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CO: 0,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DM: 0,
  DO: 0,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  ET: 0,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  'GB-alt-variant': 0,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  GT: 0,
  GU: 0,
  HK: 0,
  HN: 0,
  HR: 1,
  HU: 1,
  ID: 0,
  IE: 1,
  IL: 0,
  IN: 0,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JM: 0,
  JO: 6,
  JP: 0,
  KE: 0,
  KG: 1,
  KH: 0,
  KR: 0,
  KW: 6,
  KZ: 1,
  LA: 0,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MH: 0,
  MK: 1,
  MM: 0,
  MN: 1,
  MO: 0,
  MQ: 1,
  MT: 0,
  MV: 5,
  MX: 0,
  MY: 1,
  MZ: 0,
  NI: 0,
  NL: 1,
  NO: 1,
  NP: 0,
  NZ: 1,
  OM: 6,
  PA: 0,
  PE: 0,
  PH: 0,
  PK: 0,
  PL: 1,
  PR: 0,
  PT: 0,
  PY: 0,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SA: 0,
  SD: 6,
  SE: 1,
  SG: 0,
  SI: 1,
  SK: 1,
  SM: 1,
  SV: 0,
  SY: 6,
  TH: 0,
  TJ: 1,
  TM: 1,
  TR: 1,
  TT: 0,
  TW: 0,
  UA: 1,
  UM: 0,
  US: 0,
  UY: 1,
  UZ: 1,
  VA: 1,
  VE: 0,
  VI: 0,
  VN: 1,
  WS: 0,
  XK: 1,
  YE: 0,
  ZA: 0,
  ZW: 0
}
function eC(e, t) {
  const n = []
  let i = []
  const a = vy(e),
    s = gy(e),
    o = a.getDay() - md[t.slice(-2).toUpperCase()],
    r = s.getDay() - md[t.slice(-2).toUpperCase()]
  for (let l = 0; l < o; l++) {
    const c = new Date(a)
    c.setDate(c.getDate() - (o - l)), i.push(c)
  }
  for (let l = 1; l <= s.getDate(); l++) {
    const c = new Date(e.getFullYear(), e.getMonth(), l)
    i.push(c), i.length === 7 && (n.push(i), (i = []))
  }
  for (let l = 1; l < 7 - r; l++) {
    const c = new Date(s)
    c.setDate(c.getDate() + l), i.push(c)
  }
  return n.push(i), n
}
function vy(e) {
  return new Date(e.getFullYear(), e.getMonth(), 1)
}
function gy(e) {
  return new Date(e.getFullYear(), e.getMonth() + 1, 0)
}
function tC(e) {
  const t = e.split('-').map(Number)
  return new Date(t[0], t[1] - 1, t[2])
}
const nC = /([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))/
function iC(e) {
  if (e == null) return new Date()
  if (e instanceof Date) return e
  if (typeof e == 'string') {
    let t
    if (nC.test(e)) return tC(e)
    if (((t = Date.parse(e)), !isNaN(t))) return new Date(t)
  }
  return null
}
const ig = new Date(2e3, 0, 2)
function aC(e) {
  const t = md[e.slice(-2).toUpperCase()]
  return ji(7).map((n) => {
    const i = new Date(ig)
    return i.setDate(ig.getDate() + t + n), new Intl.DateTimeFormat(e, { weekday: 'narrow' }).format(i)
  })
}
function sC(e, t, n) {
  const i = new Date(e)
  let a = {}
  switch (t) {
    case 'fullDateWithWeekday':
      a = { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' }
      break
    case 'normalDateWithWeekday':
      a = { weekday: 'short', day: 'numeric', month: 'short' }
      break
    case 'keyboardDate':
      a = {}
      break
    case 'monthAndDate':
      a = { month: 'long', day: 'numeric' }
      break
    case 'monthAndYear':
      a = { month: 'long', year: 'numeric' }
      break
    case 'dayOfMonth':
      a = { day: 'numeric' }
      break
    case 'shortDate':
      a = { year: 'numeric' }
      break
    default:
      a = { timeZone: 'UTC', timeZoneName: 'short' }
  }
  return new Intl.DateTimeFormat(n, a).format(i)
}
function oC(e, t) {
  const n = new Date(e)
  return n.setDate(n.getDate() + t), n
}
function rC(e, t) {
  const n = new Date(e)
  return n.setMonth(n.getMonth() + t), n
}
function lC(e) {
  return e.getFullYear()
}
function cC(e) {
  return e.getMonth()
}
function uC(e) {
  return new Date(e.getFullYear(), 0, 1)
}
function dC(e) {
  return new Date(e.getFullYear(), 11, 31)
}
function fC(e, t) {
  return pd(e, t[0]) && vC(e, t[1])
}
function hC(e) {
  if (!e || e == null) return !1
  const t = new Date(e)
  return t instanceof Date && !isNaN(t.getTime())
}
function pd(e, t) {
  return e.getTime() > t.getTime()
}
function vC(e, t) {
  return e.getTime() < t.getTime()
}
function ag(e, t) {
  return e.getTime() === t.getTime()
}
function gC(e, t) {
  return e.getDate() === t.getDate() && e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear()
}
function mC(e, t) {
  return e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear()
}
function pC(e, t, n) {
  const i = new Date(e),
    a = new Date(t)
  return n === 'month'
    ? i.getMonth() - a.getMonth() + (i.getFullYear() - a.getFullYear()) * 12
    : Math.floor((i.getTime() - a.getTime()) / (1e3 * 60 * 60 * 24))
}
function yC(e, t) {
  const n = new Date(e)
  return n.setFullYear(t), n
}
function bC(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate())
}
function _C(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 23, 59, 59, 999)
}
class xC {
  constructor(t) {
    this.locale = t.locale
  }
  date(t) {
    return iC(t)
  }
  toJsDate(t) {
    return t
  }
  addDays(t, n) {
    return oC(t, n)
  }
  addMonths(t, n) {
    return rC(t, n)
  }
  getWeekArray(t) {
    return eC(t, this.locale)
  }
  startOfMonth(t) {
    return vy(t)
  }
  endOfMonth(t) {
    return gy(t)
  }
  format(t, n) {
    return sC(t, n, this.locale)
  }
  isEqual(t, n) {
    return ag(t, n)
  }
  isValid(t) {
    return hC(t)
  }
  isWithinRange(t, n) {
    return fC(t, n)
  }
  isAfter(t, n) {
    return pd(t, n)
  }
  isBefore(t, n) {
    return !pd(t, n) && !ag(t, n)
  }
  isSameDay(t, n) {
    return gC(t, n)
  }
  isSameMonth(t, n) {
    return mC(t, n)
  }
  setYear(t, n) {
    return yC(t, n)
  }
  getDiff(t, n, i) {
    return pC(t, n, i)
  }
  getWeekdays() {
    return aC(this.locale)
  }
  getYear(t) {
    return lC(t)
  }
  getMonth(t) {
    return cC(t)
  }
  startOfDay(t) {
    return bC(t)
  }
  endOfDay(t) {
    return _C(t)
  }
  startOfYear(t) {
    return uC(t)
  }
  endOfYear(t) {
    return dC(t)
  }
}
const sg = Symbol.for('vuetify:date-adapter')
function wC(e) {
  return Wn(
    {
      adapter: xC,
      locale: {
        af: 'af-ZA',
        bg: 'bg-BG',
        ca: 'ca-ES',
        ckb: '',
        cs: '',
        de: 'de-DE',
        el: 'el-GR',
        en: 'en-US',
        et: 'et-EE',
        fa: 'fa-IR',
        fi: 'fi-FI',
        hr: 'hr-HR',
        hu: 'hu-HU',
        he: 'he-IL',
        id: 'id-ID',
        it: 'it-IT',
        ja: 'ja-JP',
        ko: 'ko-KR',
        lv: 'lv-LV',
        lt: 'lt-LT',
        nl: 'nl-NL',
        no: 'nn-NO',
        pl: 'pl-PL',
        pt: 'pt-PT',
        ro: 'ro-RO',
        ru: 'ru-RU',
        sk: 'sk-SK',
        sl: 'sl-SI',
        srCyrl: 'sr-SP',
        srLatn: 'sr-SP',
        sv: 'sv-SE',
        th: 'th-TH',
        tr: 'tr-TR',
        az: 'az-AZ',
        uk: 'uk-UA',
        vi: 'vi-VN',
        zhHans: 'zh-CN',
        zhHant: 'zh-TW'
      }
    },
    e
  )
}
function Ti(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'content'
  const n = te(),
    i = te()
  if (yt) {
    const a = new ResizeObserver((s) => {
      e == null || e(s, a),
        s.length &&
          (t === 'content' ? (i.value = s[0].contentRect) : (i.value = s[0].target.getBoundingClientRect()))
    })
    _n(() => {
      a.disconnect()
    }),
      Pe(
        n,
        (s, o) => {
          o && (a.unobserve(ld(o)), (i.value = void 0)), s && a.observe(ld(s))
        },
        { flush: 'post' }
      )
  }
  return { resizeRef: n, contentRect: $r(i) }
}
const lc = Symbol.for('vuetify:layout'),
  my = Symbol.for('vuetify:layout-item'),
  og = 1e3,
  py = ee({ overlaps: { type: Array, default: () => [] }, fullHeight: Boolean }, 'layout'),
  uo = ee(
    { name: { type: String }, order: { type: [Number, String], default: 0 }, absolute: Boolean },
    'layout-item'
  )
function SC() {
  const e = st(lc)
  if (!e) throw new Error('[Vuetify] Could not find injected layout')
  return { getLayoutItem: e.getLayoutItem, mainRect: e.mainRect, mainStyles: e.mainStyles }
}
function fo(e) {
  const t = st(lc)
  if (!t) throw new Error('[Vuetify] Could not find injected layout')
  const n = e.id ?? `layout-item-${vn()}`,
    i = Jt('useLayoutItem')
  Vt(my, { id: n })
  const a = Ce(!1)
  y0(() => (a.value = !0)), p0(() => (a.value = !1))
  const { layoutItemStyles: s, layoutItemScrimStyles: o } = t.register(i, {
    ...e,
    active: A(() => (a.value ? !1 : e.active.value)),
    id: n
  })
  return (
    _n(() => t.unregister(n)), { layoutItemStyles: s, layoutRect: t.layoutRect, layoutItemScrimStyles: o }
  )
}
const kC = (e, t, n, i) => {
  let a = { top: 0, left: 0, right: 0, bottom: 0 }
  const s = [{ id: '', layer: { ...a } }]
  for (const o of e) {
    const r = t.get(o),
      l = n.get(o),
      c = i.get(o)
    if (!r || !l || !c) continue
    const u = { ...a, [r.value]: parseInt(a[r.value], 10) + (c.value ? parseInt(l.value, 10) : 0) }
    s.push({ id: o, layer: u }), (a = u)
  }
  return s
}
function yy(e) {
  const t = st(lc, null),
    n = A(() => (t ? t.rootZIndex.value - 100 : og)),
    i = te([]),
    a = yn(new Map()),
    s = yn(new Map()),
    o = yn(new Map()),
    r = yn(new Map()),
    l = yn(new Map()),
    { resizeRef: c, contentRect: u } = Ti(),
    d = A(() => {
      const P = new Map(),
        k = e.overlaps ?? []
      for (const S of k.filter((_) => _.includes(':'))) {
        const [_, T] = S.split(':')
        if (!i.value.includes(_) || !i.value.includes(T)) continue
        const B = a.get(_),
          O = a.get(T),
          N = s.get(_),
          Q = s.get(T)
        !B ||
          !O ||
          !N ||
          !Q ||
          (P.set(T, { position: B.value, amount: parseInt(N.value, 10) }),
          P.set(_, { position: O.value, amount: -parseInt(Q.value, 10) }))
      }
      return P
    }),
    f = A(() => {
      const P = [...new Set([...o.values()].map((S) => S.value))].sort((S, _) => S - _),
        k = []
      for (const S of P) {
        const _ = i.value.filter((T) => {
          var B
          return ((B = o.get(T)) == null ? void 0 : B.value) === S
        })
        k.push(..._)
      }
      return kC(k, a, s, r)
    }),
    h = A(() => !Array.from(l.values()).some((P) => P.value)),
    v = A(() => f.value[f.value.length - 1].layer),
    g = A(() => ({
      '--v-layout-left': Ve(v.value.left),
      '--v-layout-right': Ve(v.value.right),
      '--v-layout-top': Ve(v.value.top),
      '--v-layout-bottom': Ve(v.value.bottom),
      ...(h.value ? void 0 : { transition: 'none' })
    })),
    p = A(() =>
      f.value.slice(1).map((P, k) => {
        let { id: S } = P
        const { layer: _ } = f.value[k],
          T = s.get(S),
          B = a.get(S)
        return { id: S, ..._, size: Number(T.value), position: B.value }
      })
    ),
    y = (P) => p.value.find((k) => k.id === P),
    b = Jt('createLayout'),
    x = Ce(!1)
  tn(() => {
    x.value = !0
  }),
    Vt(lc, {
      register: (P, k) => {
        let {
          id: S,
          order: _,
          position: T,
          layoutSize: B,
          elementSize: O,
          active: N,
          disableTransitions: Q,
          absolute: ue
        } = k
        o.set(S, _), a.set(S, T), s.set(S, B), r.set(S, N), Q && l.set(S, Q)
        const U = er(my, b == null ? void 0 : b.vnode).indexOf(P)
        U > -1 ? i.value.splice(U, 0, S) : i.value.push(S)
        const X = A(() => p.value.findIndex((Te) => Te.id === S)),
          oe = A(() => n.value + f.value.length * 2 - X.value * 2),
          de = A(() => {
            const Te = T.value === 'left' || T.value === 'right',
              $e = T.value === 'right',
              He = T.value === 'bottom',
              Ue = {
                [T.value]: 0,
                zIndex: oe.value,
                transform: `translate${Te ? 'X' : 'Y'}(${(N.value ? 0 : -110) * ($e || He ? -1 : 1)}%)`,
                position: ue.value || n.value !== og ? 'absolute' : 'fixed',
                ...(h.value ? void 0 : { transition: 'none' })
              }
            if (!x.value) return Ue
            const ie = p.value[X.value]
            if (!ie) throw new Error(`[Vuetify] Could not find layout item "${S}"`)
            const Y = d.value.get(S)
            return (
              Y && (ie[Y.position] += Y.amount),
              {
                ...Ue,
                height: Te ? `calc(100% - ${ie.top}px - ${ie.bottom}px)` : O.value ? `${O.value}px` : void 0,
                left: $e ? void 0 : `${ie.left}px`,
                right: $e ? `${ie.right}px` : void 0,
                top: T.value !== 'bottom' ? `${ie.top}px` : void 0,
                bottom: T.value !== 'top' ? `${ie.bottom}px` : void 0,
                width: Te ? (O.value ? `${O.value}px` : void 0) : `calc(100% - ${ie.left}px - ${ie.right}px)`
              }
            )
          }),
          ce = A(() => ({ zIndex: oe.value - 1 }))
        return { layoutItemStyles: de, layoutItemScrimStyles: ce, zIndex: oe }
      },
      unregister: (P) => {
        o.delete(P),
          a.delete(P),
          s.delete(P),
          r.delete(P),
          l.delete(P),
          (i.value = i.value.filter((k) => k !== P))
      },
      mainRect: v,
      mainStyles: g,
      getLayoutItem: y,
      items: p,
      layoutRect: u,
      rootZIndex: n
    })
  const w = A(() => ['v-layout', { 'v-layout--full-height': e.fullHeight }]),
    C = A(() => ({
      zIndex: t ? n.value : void 0,
      position: t ? 'relative' : void 0,
      overflow: t ? 'hidden' : void 0
    }))
  return { layoutClasses: w, layoutStyles: C, getLayoutItem: y, items: p, layoutRect: u, layoutRef: c }
}
function by() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
  const { blueprint: t, ...n } = e,
    i = Wn(t, n),
    { aliases: a = {}, components: s = {}, directives: o = {} } = i,
    r = Ok(i.defaults),
    l = Rk(i.display, i.ssr),
    c = Qk(i.theme),
    u = Hk(i.icons),
    d = Xk(i.locale),
    f = wC(i.date)
  return {
    install: (v) => {
      for (const g in o) v.directive(g, o[g])
      for (const g in s) v.component(g, s[g])
      for (const g in a) v.component(g, Xn({ ...a[g], name: g, aliasName: a[g].name }))
      if (
        (c.install(v),
        v.provide(Zs, r),
        v.provide(hd, l),
        v.provide(wr, c),
        v.provide(vd, u),
        v.provide(Js, d),
        v.provide(sg, f),
        yt && i.ssr)
      )
        if (v.$nuxt)
          v.$nuxt.hook('app:suspense:resolve', () => {
            l.update()
          })
        else {
          const { mount: g } = v
          v.mount = function () {
            const p = g(...arguments)
            return mt(() => l.update()), (v.mount = g), p
          }
        }
      vn.reset(),
        v.mixin({
          computed: {
            $vuetify() {
              return yn({
                defaults: Vs.call(this, Zs),
                display: Vs.call(this, hd),
                theme: Vs.call(this, wr),
                icons: Vs.call(this, vd),
                locale: Vs.call(this, Js),
                date: Vs.call(this, sg)
              })
            }
          }
        })
    },
    defaults: r,
    display: l,
    theme: c,
    icons: u,
    locale: d,
    date: f
  }
}
const CC = '3.3.17'
by.version = CC
function Vs(e) {
  var i, a
  const t = this.$,
    n =
      ((i = t.parent) == null ? void 0 : i.provides) ??
      ((a = t.vnode.appContext) == null ? void 0 : a.provides)
  if (n && e in n) return n[e]
}
const MC = ee({ ...Me(), ...py({ fullHeight: !0 }), ...ot() }, 'VApp'),
  AC = fe()({
    name: 'VApp',
    props: MC(),
    setup(e, t) {
      let { slots: n } = t
      const i = ut(e),
        { layoutClasses: a, getLayoutItem: s, items: o, layoutRef: r } = yy(e),
        { rtlClasses: l } = Qt()
      return (
        ge(() => {
          var c
          return m(
            'div',
            {
              ref: r,
              class: ['v-application', i.themeClasses.value, a.value, l.value, e.class],
              style: [e.style]
            },
            [m('div', { class: 'v-application__wrap' }, [(c = n.default) == null ? void 0 : c.call(n)])]
          )
        }),
        { getLayoutItem: s, items: o, theme: i }
      )
    }
  })
const Ke = ee({ tag: { type: String, default: 'div' } }, 'tag'),
  _y = ee({ text: String, ...Me(), ...Ke() }, 'VToolbarTitle'),
  Xf = fe()({
    name: 'VToolbarTitle',
    props: _y(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ge(() => {
          const i = !!(n.default || n.text || e.text)
          return m(
            e.tag,
            { class: ['v-toolbar-title', e.class], style: e.style },
            {
              default: () => {
                var a
                return [
                  i &&
                    m('div', { class: 'v-toolbar-title__placeholder' }, [
                      n.text ? n.text() : e.text,
                      (a = n.default) == null ? void 0 : a.call(n)
                    ])
                ]
              }
            }
          )
        }),
        {}
      )
    }
  }),
  PC = ee(
    {
      disabled: Boolean,
      group: Boolean,
      hideOnLeave: Boolean,
      leaveAbsolute: Boolean,
      mode: String,
      origin: String
    },
    'transition'
  )
function Rn(e, t, n) {
  return fe()({
    name: e,
    props: PC({ mode: n, origin: t }),
    setup(i, a) {
      let { slots: s } = a
      const o = {
        onBeforeEnter(r) {
          i.origin && (r.style.transformOrigin = i.origin)
        },
        onLeave(r) {
          if (i.leaveAbsolute) {
            const { offsetTop: l, offsetLeft: c, offsetWidth: u, offsetHeight: d } = r
            ;(r._transitionInitialStyles = {
              position: r.style.position,
              top: r.style.top,
              left: r.style.left,
              width: r.style.width,
              height: r.style.height
            }),
              (r.style.position = 'absolute'),
              (r.style.top = `${l}px`),
              (r.style.left = `${c}px`),
              (r.style.width = `${u}px`),
              (r.style.height = `${d}px`)
          }
          i.hideOnLeave && r.style.setProperty('display', 'none', 'important')
        },
        onAfterLeave(r) {
          if (i.leaveAbsolute && r != null && r._transitionInitialStyles) {
            const { position: l, top: c, left: u, width: d, height: f } = r._transitionInitialStyles
            delete r._transitionInitialStyles,
              (r.style.position = l || ''),
              (r.style.top = c || ''),
              (r.style.left = u || ''),
              (r.style.width = d || ''),
              (r.style.height = f || '')
          }
        }
      }
      return () => {
        const r = i.group ? FS : Pi
        return Ei(
          r,
          {
            name: i.disabled ? '' : e,
            css: !i.disabled,
            ...(i.group ? void 0 : { mode: i.mode }),
            ...(i.disabled ? {} : o)
          },
          s.default
        )
      }
    }
  })
}
function xy(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'in-out'
  return fe()({
    name: e,
    props: { mode: { type: String, default: n }, disabled: Boolean },
    setup(i, a) {
      let { slots: s } = a
      return () =>
        Ei(Pi, { name: i.disabled ? '' : e, css: !i.disabled, ...(i.disabled ? {} : t) }, s.default)
    }
  })
}
function wy() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ''
  const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) ? 'width' : 'height',
    i = Yn(`offset-${n}`)
  return {
    onBeforeEnter(o) {
      ;(o._parent = o.parentNode),
        (o._initialStyle = { transition: o.style.transition, overflow: o.style.overflow, [n]: o.style[n] })
    },
    onEnter(o) {
      const r = o._initialStyle
      o.style.setProperty('transition', 'none', 'important'), (o.style.overflow = 'hidden')
      const l = `${o[i]}px`
      ;(o.style[n] = '0'),
        o.offsetHeight,
        (o.style.transition = r.transition),
        e && o._parent && o._parent.classList.add(e),
        requestAnimationFrame(() => {
          o.style[n] = l
        })
    },
    onAfterEnter: s,
    onEnterCancelled: s,
    onLeave(o) {
      ;(o._initialStyle = { transition: '', overflow: o.style.overflow, [n]: o.style[n] }),
        (o.style.overflow = 'hidden'),
        (o.style[n] = `${o[i]}px`),
        o.offsetHeight,
        requestAnimationFrame(() => (o.style[n] = '0'))
    },
    onAfterLeave: a,
    onLeaveCancelled: a
  }
  function a(o) {
    e && o._parent && o._parent.classList.remove(e), s(o)
  }
  function s(o) {
    const r = o._initialStyle[n]
    ;(o.style.overflow = o._initialStyle.overflow), r != null && (o.style[n] = r), delete o._initialStyle
  }
}
const TC = ee({ target: Object }, 'v-dialog-transition'),
  $c = fe()({
    name: 'VDialogTransition',
    props: TC(),
    setup(e, t) {
      let { slots: n } = t
      const i = {
        onBeforeEnter(a) {
          ;(a.style.pointerEvents = 'none'), (a.style.visibility = 'hidden')
        },
        async onEnter(a, s) {
          var f
          await new Promise((h) => requestAnimationFrame(h)),
            await new Promise((h) => requestAnimationFrame(h)),
            (a.style.visibility = '')
          const { x: o, y: r, sx: l, sy: c, speed: u } = lg(e.target, a),
            d = ns(a, [{ transform: `translate(${o}px, ${r}px) scale(${l}, ${c})`, opacity: 0 }, {}], {
              duration: 225 * u,
              easing: Pk
            })
          ;(f = rg(a)) == null ||
            f.forEach((h) => {
              ns(h, [{ opacity: 0 }, { opacity: 0, offset: 0.33 }, {}], { duration: 225 * 2 * u, easing: xr })
            }),
            d.finished.then(() => s())
        },
        onAfterEnter(a) {
          a.style.removeProperty('pointer-events')
        },
        onBeforeLeave(a) {
          a.style.pointerEvents = 'none'
        },
        async onLeave(a, s) {
          var f
          await new Promise((h) => requestAnimationFrame(h))
          const { x: o, y: r, sx: l, sy: c, speed: u } = lg(e.target, a)
          ns(a, [{}, { transform: `translate(${o}px, ${r}px) scale(${l}, ${c})`, opacity: 0 }], {
            duration: 125 * u,
            easing: Tk
          }).finished.then(() => s()),
            (f = rg(a)) == null ||
              f.forEach((h) => {
                ns(h, [{}, { opacity: 0, offset: 0.2 }, { opacity: 0 }], {
                  duration: 125 * 2 * u,
                  easing: xr
                })
              })
        },
        onAfterLeave(a) {
          a.style.removeProperty('pointer-events')
        }
      }
      return () =>
        e.target
          ? m(Pi, xe({ name: 'dialog-transition' }, i, { css: !1 }), n)
          : m(Pi, { name: 'dialog-transition' }, n)
    }
  })
function rg(e) {
  var n
  const t =
    (n = e.querySelector(':scope > .v-card, :scope > .v-sheet, :scope > .v-list')) == null
      ? void 0
      : n.children
  return t && [...t]
}
function lg(e, t) {
  const n = e.getBoundingClientRect(),
    i = $f(t),
    [a, s] = getComputedStyle(t)
      .transformOrigin.split(' ')
      .map((y) => parseFloat(y)),
    [o, r] = getComputedStyle(t).getPropertyValue('--v-overlay-anchor-origin').split(' ')
  let l = n.left + n.width / 2
  o === 'left' || r === 'left' ? (l -= n.width / 2) : (o === 'right' || r === 'right') && (l += n.width / 2)
  let c = n.top + n.height / 2
  o === 'top' || r === 'top' ? (c -= n.height / 2) : (o === 'bottom' || r === 'bottom') && (c += n.height / 2)
  const u = n.width / i.width,
    d = n.height / i.height,
    f = Math.max(1, u, d),
    h = u / f || 0,
    v = d / f || 0,
    g = (i.width * i.height) / (window.innerWidth * window.innerHeight),
    p = g > 0.12 ? Math.min(1.5, (g - 0.12) * 10 + 1) : 1
  return { x: l - (a + i.left), y: c - (s + i.top), sx: h, sy: v, speed: p }
}
const VC = Rn('fab-transition', 'center center', 'out-in'),
  EC = Rn('dialog-bottom-transition'),
  LC = Rn('dialog-top-transition'),
  yd = Rn('fade-transition'),
  Kf = Rn('scale-transition'),
  OC = Rn('scroll-x-transition'),
  IC = Rn('scroll-x-reverse-transition'),
  DC = Rn('scroll-y-transition'),
  FC = Rn('scroll-y-reverse-transition'),
  RC = Rn('slide-x-transition'),
  BC = Rn('slide-x-reverse-transition'),
  qf = Rn('slide-y-transition'),
  NC = Rn('slide-y-reverse-transition'),
  zc = xy('expand-transition', wy()),
  Zf = xy('expand-x-transition', wy('', !0)),
  $C = ee(
    {
      defaults: Object,
      disabled: Boolean,
      reset: [Number, String],
      root: [Boolean, String],
      scoped: Boolean
    },
    'VDefaultsProvider'
  ),
  vt = fe(!1)({
    name: 'VDefaultsProvider',
    props: $C(),
    setup(e, t) {
      let { slots: n } = t
      const { defaults: i, disabled: a, reset: s, root: o, scoped: r } = Sf(e)
      return (
        zt(i, { reset: s, root: o, scoped: r, disabled: a }),
        () => {
          var l
          return (l = n.default) == null ? void 0 : l.call(n)
        }
      )
    }
  })
const qn = ee(
  {
    height: [Number, String],
    maxHeight: [Number, String],
    maxWidth: [Number, String],
    minHeight: [Number, String],
    minWidth: [Number, String],
    width: [Number, String]
  },
  'dimension'
)
function Zn(e) {
  return {
    dimensionStyles: A(() => ({
      height: Ve(e.height),
      maxHeight: Ve(e.maxHeight),
      maxWidth: Ve(e.maxWidth),
      minHeight: Ve(e.minHeight),
      minWidth: Ve(e.minWidth),
      width: Ve(e.width)
    }))
  }
}
function zC(e) {
  return {
    aspectStyles: A(() => {
      const t = Number(e.aspectRatio)
      return t ? { paddingBottom: String((1 / t) * 100) + '%' } : void 0
    })
  }
}
const Sy = ee(
    { aspectRatio: [String, Number], contentClass: String, inline: Boolean, ...Me(), ...qn() },
    'VResponsive'
  ),
  bd = fe()({
    name: 'VResponsive',
    props: Sy(),
    setup(e, t) {
      let { slots: n } = t
      const { aspectStyles: i } = zC(e),
        { dimensionStyles: a } = Zn(e)
      return (
        ge(() => {
          var s
          return m(
            'div',
            {
              class: ['v-responsive', { 'v-responsive--inline': e.inline }, e.class],
              style: [a.value, e.style]
            },
            [
              m('div', { class: 'v-responsive__sizer', style: i.value }, null),
              (s = n.additional) == null ? void 0 : s.call(n),
              n.default && m('div', { class: ['v-responsive__content', e.contentClass] }, [n.default()])
            ]
          )
        }),
        {}
      )
    }
  }),
  sa = ee(
    {
      transition: { type: [Boolean, String, Object], default: 'fade-transition', validator: (e) => e !== !0 }
    },
    'transition'
  ),
  ii = (e, t) => {
    let { slots: n } = t
    const { transition: i, disabled: a, ...s } = e,
      { component: o = Pi, ...r } = typeof i == 'object' ? i : {}
    return Ei(o, xe(typeof i == 'string' ? { name: a ? '' : i } : r, s, { disabled: a }), n)
  }
function HC(e, t) {
  if (!Ff) return
  const n = t.modifiers || {},
    i = t.value,
    { handler: a, options: s } = typeof i == 'object' ? i : { handler: i, options: {} },
    o = new IntersectionObserver(function () {
      var d
      let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
        l = arguments.length > 1 ? arguments[1] : void 0
      const c = (d = e._observe) == null ? void 0 : d[t.instance.$.uid]
      if (!c) return
      const u = r.some((f) => f.isIntersecting)
      a && (!n.quiet || c.init) && (!n.once || u || c.init) && a(u, r, l),
        u && n.once ? ky(e, t) : (c.init = !0)
    }, s)
  ;(e._observe = Object(e._observe)), (e._observe[t.instance.$.uid] = { init: !1, observer: o }), o.observe(e)
}
function ky(e, t) {
  var i
  const n = (i = e._observe) == null ? void 0 : i[t.instance.$.uid]
  n && (n.observer.unobserve(e), delete e._observe[t.instance.$.uid])
}
const Hr = { mounted: HC, unmounted: ky },
  Cy = ee(
    {
      alt: String,
      cover: Boolean,
      eager: Boolean,
      gradient: String,
      lazySrc: String,
      options: { type: Object, default: () => ({ root: void 0, rootMargin: void 0, threshold: void 0 }) },
      sizes: String,
      src: { type: [String, Object], default: '' },
      srcset: String,
      ...Sy(),
      ...Me(),
      ...sa()
    },
    'VImg'
  ),
  fs = fe()({
    name: 'VImg',
    directives: { intersect: Hr },
    props: Cy(),
    emits: { loadstart: (e) => !0, load: (e) => !0, error: (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: i } = t
      const a = Ce(''),
        s = te(),
        o = Ce(e.eager ? 'loading' : 'idle'),
        r = Ce(),
        l = Ce(),
        c = A(() =>
          e.src && typeof e.src == 'object'
            ? {
                src: e.src.src,
                srcset: e.srcset || e.src.srcset,
                lazySrc: e.lazySrc || e.src.lazySrc,
                aspect: Number(e.aspectRatio || e.src.aspect || 0)
              }
            : { src: e.src, srcset: e.srcset, lazySrc: e.lazySrc, aspect: Number(e.aspectRatio || 0) }
        ),
        u = A(() => c.value.aspect || r.value / l.value || 0)
      Pe(
        () => e.src,
        () => {
          d(o.value !== 'idle')
        }
      ),
        Pe(u, (S, _) => {
          !S && _ && s.value && p(s.value)
        }),
        Ic(() => d())
      function d(S) {
        if (!(e.eager && S) && !(Ff && !S && !e.eager)) {
          if (((o.value = 'loading'), c.value.lazySrc)) {
            const _ = new Image()
            ;(_.src = c.value.lazySrc), p(_, null)
          }
          c.value.src &&
            mt(() => {
              var _, T
              if (
                (n('loadstart', ((_ = s.value) == null ? void 0 : _.currentSrc) || c.value.src),
                (T = s.value) != null && T.complete)
              ) {
                if ((s.value.naturalWidth || h(), o.value === 'error')) return
                u.value || p(s.value, null), f()
              } else u.value || p(s.value), v()
            })
        }
      }
      function f() {
        var S
        v(), (o.value = 'loaded'), n('load', ((S = s.value) == null ? void 0 : S.currentSrc) || c.value.src)
      }
      function h() {
        var S
        ;(o.value = 'error'), n('error', ((S = s.value) == null ? void 0 : S.currentSrc) || c.value.src)
      }
      function v() {
        const S = s.value
        S && (a.value = S.currentSrc || S.src)
      }
      let g = -1
      function p(S) {
        let _ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100
        const T = () => {
          clearTimeout(g)
          const { naturalHeight: B, naturalWidth: O } = S
          B || O
            ? ((r.value = O), (l.value = B))
            : !S.complete && o.value === 'loading' && _ != null
            ? (g = window.setTimeout(T, _))
            : (S.currentSrc.endsWith('.svg') || S.currentSrc.startsWith('data:image/svg+xml')) &&
              ((r.value = 1), (l.value = 1))
        }
        T()
      }
      const y = A(() => ({ 'v-img__img--cover': e.cover, 'v-img__img--contain': !e.cover })),
        b = () => {
          var T
          if (!c.value.src || o.value === 'idle') return null
          const S = m(
              'img',
              {
                class: ['v-img__img', y.value],
                src: c.value.src,
                srcset: c.value.srcset,
                alt: e.alt,
                sizes: e.sizes,
                ref: s,
                onLoad: f,
                onError: h
              },
              null
            ),
            _ = (T = i.sources) == null ? void 0 : T.call(i)
          return m(
            ii,
            { transition: e.transition, appear: !0 },
            {
              default: () => [
                Et(_ ? m('picture', { class: 'v-img__picture' }, [_, S]) : S, [[Li, o.value === 'loaded']])
              ]
            }
          )
        },
        x = () =>
          m(
            ii,
            { transition: e.transition },
            {
              default: () => [
                c.value.lazySrc &&
                  o.value !== 'loaded' &&
                  m(
                    'img',
                    {
                      class: ['v-img__img', 'v-img__img--preload', y.value],
                      src: c.value.lazySrc,
                      alt: e.alt
                    },
                    null
                  )
              ]
            }
          ),
        w = () =>
          i.placeholder
            ? m(
                ii,
                { transition: e.transition, appear: !0 },
                {
                  default: () => [
                    (o.value === 'loading' || (o.value === 'error' && !i.error)) &&
                      m('div', { class: 'v-img__placeholder' }, [i.placeholder()])
                  ]
                }
              )
            : null,
        C = () =>
          i.error
            ? m(
                ii,
                { transition: e.transition, appear: !0 },
                { default: () => [o.value === 'error' && m('div', { class: 'v-img__error' }, [i.error()])] }
              )
            : null,
        P = () =>
          e.gradient
            ? m(
                'div',
                { class: 'v-img__gradient', style: { backgroundImage: `linear-gradient(${e.gradient})` } },
                null
              )
            : null,
        k = Ce(!1)
      {
        const S = Pe(u, (_) => {
          _ &&
            (requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                k.value = !0
              })
            }),
            S())
        })
      }
      return (
        ge(() => {
          const [S] = bd.filterProps(e)
          return Et(
            m(
              bd,
              xe(
                {
                  class: ['v-img', { 'v-img--booting': !k.value }, e.class],
                  style: [{ width: Ve(e.width === 'auto' ? r.value : e.width) }, e.style]
                },
                S,
                { aspectRatio: u.value, 'aria-label': e.alt, role: e.alt ? 'img' : void 0 }
              ),
              {
                additional: () =>
                  m(Oe, null, [
                    m(b, null, null),
                    m(x, null, null),
                    m(P, null, null),
                    m(w, null, null),
                    m(C, null, null)
                  ]),
                default: i.default
              }
            ),
            [[Fn('intersect'), { handler: d, options: e.options }, null, { once: !0 }]]
          )
        }),
        { currentSrc: a, image: s, state: o, naturalWidth: r, naturalHeight: l }
      )
    }
  }),
  Bn = ee({ border: [Boolean, Number, String] }, 'border')
function Jn(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : aa()
  return {
    borderClasses: A(() => {
      const i = Tt(e) ? e.value : e.border,
        a = []
      if (i === !0 || i === '') a.push(`${t}--border`)
      else if (typeof i == 'string' || i === 0) for (const s of String(i).split(' ')) a.push(`border-${s}`)
      return a
    })
  }
}
function Jf(e) {
  return Bf(() => {
    const t = [],
      n = {}
    if (e.value.background)
      if (Gv(e.value.background)) {
        if (((n.backgroundColor = e.value.background), !e.value.text)) {
          const i = jn(e.value.background)
          if (i.a == null || i.a === 1) {
            const a = ry(i)
            ;(n.color = a), (n.caretColor = a)
          }
        }
      } else t.push(`bg-${e.value.background}`)
    return (
      e.value.text &&
        (Gv(e.value.text)
          ? ((n.color = e.value.text), (n.caretColor = e.value.text))
          : t.push(`text-${e.value.text}`)),
      { colorClasses: t, colorStyles: n }
    )
  })
}
function dn(e, t) {
  const n = A(() => ({ text: Tt(e) ? e.value : t ? e[t] : null })),
    { colorClasses: i, colorStyles: a } = Jf(n)
  return { textColorClasses: i, textColorStyles: a }
}
function Rt(e, t) {
  const n = A(() => ({ background: Tt(e) ? e.value : t ? e[t] : null })),
    { colorClasses: i, colorStyles: a } = Jf(n)
  return { backgroundColorClasses: i, backgroundColorStyles: a }
}
const Yt = ee(
  {
    elevation: {
      type: [Number, String],
      validator(e) {
        const t = parseInt(e)
        return !isNaN(t) && t >= 0 && t <= 24
      }
    }
  },
  'elevation'
)
function nn(e) {
  return {
    elevationClasses: A(() => {
      const n = Tt(e) ? e.value : e.elevation,
        i = []
      return n == null || i.push(`elevation-${n}`), i
    })
  }
}
const kt = ee({ rounded: { type: [Boolean, Number, String], default: void 0 } }, 'rounded')
function Lt(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : aa()
  return {
    roundedClasses: A(() => {
      const i = Tt(e) ? e.value : e.rounded,
        a = []
      if (i === !0 || i === '') a.push(`${t}--rounded`)
      else if (typeof i == 'string' || i === 0) for (const s of String(i).split(' ')) a.push(`rounded-${s}`)
      return a
    })
  }
}
const WC = [null, 'prominent', 'default', 'comfortable', 'compact'],
  My = ee(
    {
      absolute: Boolean,
      collapse: Boolean,
      color: String,
      density: { type: String, default: 'default', validator: (e) => WC.includes(e) },
      extended: Boolean,
      extensionHeight: { type: [Number, String], default: 48 },
      flat: Boolean,
      floating: Boolean,
      height: { type: [Number, String], default: 64 },
      image: String,
      title: String,
      ...Bn(),
      ...Me(),
      ...Yt(),
      ...kt(),
      ...Ke({ tag: 'header' }),
      ...ot()
    },
    'VToolbar'
  ),
  _d = fe()({
    name: 'VToolbar',
    props: My(),
    setup(e, t) {
      var h
      let { slots: n } = t
      const { backgroundColorClasses: i, backgroundColorStyles: a } = Rt(ve(e, 'color')),
        { borderClasses: s } = Jn(e),
        { elevationClasses: o } = nn(e),
        { roundedClasses: r } = Lt(e),
        { themeClasses: l } = ut(e),
        { rtlClasses: c } = Qt(),
        u = Ce(!!(e.extended || ((h = n.extension) != null && h.call(n)))),
        d = A(() =>
          parseInt(
            Number(e.height) +
              (e.density === 'prominent' ? Number(e.height) : 0) -
              (e.density === 'comfortable' ? 8 : 0) -
              (e.density === 'compact' ? 16 : 0),
            10
          )
        ),
        f = A(() =>
          u.value
            ? parseInt(
                Number(e.extensionHeight) +
                  (e.density === 'prominent' ? Number(e.extensionHeight) : 0) -
                  (e.density === 'comfortable' ? 4 : 0) -
                  (e.density === 'compact' ? 8 : 0),
                10
              )
            : 0
        )
      return (
        zt({ VBtn: { variant: 'text' } }),
        ge(() => {
          var y
          const v = !!(e.title || n.title),
            g = !!(n.image || e.image),
            p = (y = n.extension) == null ? void 0 : y.call(n)
          return (
            (u.value = !!(e.extended || p)),
            m(
              e.tag,
              {
                class: [
                  'v-toolbar',
                  {
                    'v-toolbar--absolute': e.absolute,
                    'v-toolbar--collapse': e.collapse,
                    'v-toolbar--flat': e.flat,
                    'v-toolbar--floating': e.floating,
                    [`v-toolbar--density-${e.density}`]: !0
                  },
                  i.value,
                  s.value,
                  o.value,
                  r.value,
                  l.value,
                  c.value,
                  e.class
                ],
                style: [a.value, e.style]
              },
              {
                default: () => [
                  g &&
                    m('div', { key: 'image', class: 'v-toolbar__image' }, [
                      n.image
                        ? m(
                            vt,
                            {
                              key: 'image-defaults',
                              disabled: !e.image,
                              defaults: { VImg: { cover: !0, src: e.image } }
                            },
                            n.image
                          )
                        : m(fs, { key: 'image-img', cover: !0, src: e.image }, null)
                    ]),
                  m(
                    vt,
                    { defaults: { VTabs: { height: Ve(d.value) } } },
                    {
                      default: () => {
                        var b, x, w
                        return [
                          m('div', { class: 'v-toolbar__content', style: { height: Ve(d.value) } }, [
                            n.prepend &&
                              m('div', { class: 'v-toolbar__prepend' }, [
                                (b = n.prepend) == null ? void 0 : b.call(n)
                              ]),
                            v && m(Xf, { key: 'title', text: e.title }, { text: n.title }),
                            (x = n.default) == null ? void 0 : x.call(n),
                            n.append &&
                              m('div', { class: 'v-toolbar__append' }, [
                                (w = n.append) == null ? void 0 : w.call(n)
                              ])
                          ])
                        ]
                      }
                    }
                  ),
                  m(
                    vt,
                    { defaults: { VTabs: { height: Ve(f.value) } } },
                    {
                      default: () => [
                        m(zc, null, {
                          default: () => [
                            u.value &&
                              m('div', { class: 'v-toolbar__extension', style: { height: Ve(f.value) } }, [p])
                          ]
                        })
                      ]
                    }
                  )
                ]
              }
            )
          )
        }),
        { contentHeight: d, extensionHeight: f }
      )
    }
  }),
  jC = ee(
    { scrollTarget: { type: String }, scrollThreshold: { type: [String, Number], default: 300 } },
    'scroll'
  )
function UC(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
  const { canScroll: n } = t
  let i = 0
  const a = te(null),
    s = Ce(0),
    o = Ce(0),
    r = Ce(0),
    l = Ce(!1),
    c = Ce(!1),
    u = A(() => Number(e.scrollThreshold)),
    d = A(() => cn((u.value - s.value) / u.value || 0)),
    f = () => {
      const h = a.value
      !h ||
        (n && !n.value) ||
        ((i = s.value),
        (s.value = 'window' in h ? h.pageYOffset : h.scrollTop),
        (c.value = s.value < i),
        (r.value = Math.abs(s.value - u.value)))
    }
  return (
    Pe(c, () => {
      o.value = o.value || s.value
    }),
    Pe(l, () => {
      o.value = 0
    }),
    tn(() => {
      Pe(
        () => e.scrollTarget,
        (h) => {
          var g
          const v = h ? document.querySelector(h) : window
          v &&
            v !== a.value &&
            ((g = a.value) == null || g.removeEventListener('scroll', f),
            (a.value = v),
            a.value.addEventListener('scroll', f, { passive: !0 }))
        },
        { immediate: !0 }
      )
    }),
    _n(() => {
      var h
      ;(h = a.value) == null || h.removeEventListener('scroll', f)
    }),
    n && Pe(n, f, { immediate: !0 }),
    {
      scrollThreshold: u,
      currentScroll: s,
      currentThreshold: r,
      isScrollActive: l,
      scrollRatio: d,
      isScrollingUp: c,
      savedScroll: o
    }
  )
}
function _s() {
  const e = Ce(!1)
  return (
    tn(() => {
      window.requestAnimationFrame(() => {
        e.value = !0
      })
    }),
    { ssrBootStyles: A(() => (e.value ? void 0 : { transition: 'none !important' })), isBooted: $r(e) }
  )
}
const YC = ee(
    {
      scrollBehavior: String,
      modelValue: { type: Boolean, default: !0 },
      location: { type: String, default: 'top', validator: (e) => ['top', 'bottom'].includes(e) },
      ...My(),
      ...uo(),
      ...jC(),
      height: { type: [Number, String], default: 64 }
    },
    'VAppBar'
  ),
  GC = fe()({
    name: 'VAppBar',
    props: YC(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = te(),
        a = Ge(e, 'modelValue'),
        s = A(() => {
          var b
          const y = new Set(((b = e.scrollBehavior) == null ? void 0 : b.split(' ')) ?? [])
          return {
            hide: y.has('hide'),
            inverted: y.has('inverted'),
            collapse: y.has('collapse'),
            elevate: y.has('elevate'),
            fadeImage: y.has('fade-image')
          }
        }),
        o = A(() => {
          const y = s.value
          return y.hide || y.inverted || y.collapse || y.elevate || y.fadeImage || !a.value
        }),
        { currentScroll: r, scrollThreshold: l, isScrollingUp: c, scrollRatio: u } = UC(e, { canScroll: o }),
        d = A(() => e.collapse || (s.value.collapse && (s.value.inverted ? u.value > 0 : u.value === 0))),
        f = A(() => e.flat || (s.value.elevate && (s.value.inverted ? r.value > 0 : r.value === 0))),
        h = A(() => (s.value.fadeImage ? (s.value.inverted ? 1 - u.value : u.value) : void 0)),
        v = A(() => {
          var x, w
          if (s.value.hide && s.value.inverted) return 0
          const y = ((x = i.value) == null ? void 0 : x.contentHeight) ?? 0,
            b = ((w = i.value) == null ? void 0 : w.extensionHeight) ?? 0
          return y + b
        })
      Aa(
        A(() => !!e.scrollBehavior),
        () => {
          Ut(() => {
            s.value.hide
              ? s.value.inverted
                ? (a.value = r.value > l.value)
                : (a.value = c.value || r.value < l.value)
              : (a.value = !0)
          })
        }
      )
      const { ssrBootStyles: g } = _s(),
        { layoutItemStyles: p } = fo({
          id: e.name,
          order: A(() => parseInt(e.order, 10)),
          position: ve(e, 'location'),
          layoutSize: v,
          elementSize: Ce(void 0),
          active: a,
          absolute: ve(e, 'absolute')
        })
      return (
        ge(() => {
          const [y] = _d.filterProps(e)
          return m(
            _d,
            xe(
              {
                ref: i,
                class: ['v-app-bar', { 'v-app-bar--bottom': e.location === 'bottom' }, e.class],
                style: [
                  { ...p.value, '--v-toolbar-image-opacity': h.value, height: void 0, ...g.value },
                  e.style
                ]
              },
              y,
              { collapse: d.value, flat: f.value }
            ),
            n
          )
        }),
        {}
      )
    }
  })
const XC = [null, 'default', 'comfortable', 'compact'],
  Gt = ee({ density: { type: String, default: 'default', validator: (e) => XC.includes(e) } }, 'density')
function gn(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : aa()
  return { densityClasses: A(() => `${t}--density-${e.density}`) }
}
const KC = ['elevated', 'flat', 'tonal', 'outlined', 'text', 'plain']
function xs(e, t) {
  return m(Oe, null, [
    e && m('span', { key: 'overlay', class: `${t}__overlay` }, null),
    m('span', { key: 'underlay', class: `${t}__underlay` }, null)
  ])
}
const Qn = ee(
  { color: String, variant: { type: String, default: 'elevated', validator: (e) => KC.includes(e) } },
  'variant'
)
function ws(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : aa()
  const n = A(() => {
      const { variant: s } = Xe(e)
      return `${t}--variant-${s}`
    }),
    { colorClasses: i, colorStyles: a } = Jf(
      A(() => {
        const { variant: s, color: o } = Xe(e)
        return { [['elevated', 'flat'].includes(s) ? 'background' : 'text']: o }
      })
    )
  return { colorClasses: i, colorStyles: a, variantClasses: n }
}
const Ay = ee(
    { divided: Boolean, ...Bn(), ...Me(), ...Gt(), ...Yt(), ...kt(), ...Ke(), ...ot(), ...Qn() },
    'VBtnGroup'
  ),
  xd = fe()({
    name: 'VBtnGroup',
    props: Ay(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = ut(e),
        { densityClasses: a } = gn(e),
        { borderClasses: s } = Jn(e),
        { elevationClasses: o } = nn(e),
        { roundedClasses: r } = Lt(e)
      zt({
        VBtn: {
          height: 'auto',
          color: ve(e, 'color'),
          density: ve(e, 'density'),
          flat: !0,
          variant: ve(e, 'variant')
        }
      }),
        ge(() =>
          m(
            e.tag,
            {
              class: [
                'v-btn-group',
                { 'v-btn-group--divided': e.divided },
                i.value,
                s.value,
                a.value,
                o.value,
                r.value,
                e.class
              ],
              style: e.style
            },
            n
          )
        )
    }
  }),
  ho = ee(
    {
      modelValue: { type: null, default: void 0 },
      multiple: Boolean,
      mandatory: [Boolean, String],
      max: Number,
      selectedClass: String,
      disabled: Boolean
    },
    'group'
  ),
  vo = ee({ value: null, disabled: Boolean, selectedClass: String }, 'group-item')
function go(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0
  const i = Jt('useGroupItem')
  if (!i) throw new Error('[Vuetify] useGroupItem composable must be used inside a component setup function')
  const a = vn()
  Vt(Symbol.for(`${t.description}:id`), a)
  const s = st(t, null)
  if (!s) {
    if (!n) return s
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${t.description}`)
  }
  const o = ve(e, 'value'),
    r = A(() => !!(s.disabled.value || e.disabled))
  s.register({ id: a, value: o, disabled: r }, i),
    _n(() => {
      s.unregister(a)
    })
  const l = A(() => s.isSelected(a)),
    c = A(() => l.value && [s.selectedClass.value, e.selectedClass])
  return (
    Pe(l, (u) => {
      i.emit('group:selected', { value: u })
    }),
    {
      id: a,
      isSelected: l,
      toggle: () => s.select(a, !l.value),
      select: (u) => s.select(a, u),
      selectedClass: c,
      value: o,
      disabled: r,
      group: s
    }
  )
}
function Ss(e, t) {
  let n = !1
  const i = yn([]),
    a = Ge(
      e,
      'modelValue',
      [],
      (f) => (f == null ? [] : Py(i, Dn(f))),
      (f) => {
        const h = ZC(i, f)
        return e.multiple ? h : h[0]
      }
    ),
    s = Jt('useGroup')
  function o(f, h) {
    const v = f,
      g = Symbol.for(`${t.description}:id`),
      y = er(g, s == null ? void 0 : s.vnode).indexOf(h)
    y > -1 ? i.splice(y, 0, v) : i.push(v)
  }
  function r(f) {
    if (n) return
    l()
    const h = i.findIndex((v) => v.id === f)
    i.splice(h, 1)
  }
  function l() {
    const f = i.find((h) => !h.disabled)
    f && e.mandatory === 'force' && !a.value.length && (a.value = [f.id])
  }
  tn(() => {
    l()
  }),
    _n(() => {
      n = !0
    })
  function c(f, h) {
    const v = i.find((g) => g.id === f)
    if (!(h && v != null && v.disabled))
      if (e.multiple) {
        const g = a.value.slice(),
          p = g.findIndex((b) => b === f),
          y = ~p
        if (
          ((h = h ?? !y),
          (y && e.mandatory && g.length <= 1) || (!y && e.max != null && g.length + 1 > e.max))
        )
          return
        p < 0 && h ? g.push(f) : p >= 0 && !h && g.splice(p, 1), (a.value = g)
      } else {
        const g = a.value.includes(f)
        if (e.mandatory && g) return
        a.value = h ?? !g ? [f] : []
      }
  }
  function u(f) {
    if ((e.multiple, a.value.length)) {
      const h = a.value[0],
        v = i.findIndex((y) => y.id === h)
      let g = (v + f) % i.length,
        p = i[g]
      for (; p.disabled && g !== v; ) (g = (g + f) % i.length), (p = i[g])
      if (p.disabled) return
      a.value = [i[g].id]
    } else {
      const h = i.find((v) => !v.disabled)
      h && (a.value = [h.id])
    }
  }
  const d = {
    register: o,
    unregister: r,
    selected: a,
    select: c,
    disabled: ve(e, 'disabled'),
    prev: () => u(i.length - 1),
    next: () => u(1),
    isSelected: (f) => a.value.includes(f),
    selectedClass: A(() => e.selectedClass),
    items: A(() => i),
    getItemIndex: (f) => qC(i, f)
  }
  return Vt(t, d), d
}
function qC(e, t) {
  const n = Py(e, [t])
  return n.length ? e.findIndex((i) => i.id === n[0]) : -1
}
function Py(e, t) {
  const n = []
  return (
    t.forEach((i) => {
      const a = e.find((o) => co(i, o.value)),
        s = e[i]
      ;(a == null ? void 0 : a.value) != null ? n.push(a.id) : s != null && n.push(s.id)
    }),
    n
  )
}
function ZC(e, t) {
  const n = []
  return (
    t.forEach((i) => {
      const a = e.findIndex((s) => s.id === i)
      if (~a) {
        const s = e[a]
        n.push(s.value != null ? s.value : a)
      }
    }),
    n
  )
}
const Qf = Symbol.for('vuetify:v-btn-toggle'),
  JC = ee({ ...Ay(), ...ho() }, 'VBtnToggle'),
  QC = fe()({
    name: 'VBtnToggle',
    props: JC(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { isSelected: i, next: a, prev: s, select: o, selected: r } = Ss(e, Qf)
      return (
        ge(() => {
          const [l] = xd.filterProps(e)
          return m(xd, xe({ class: ['v-btn-toggle', e.class] }, l, { style: e.style }), {
            default: () => {
              var c
              return [
                (c = n.default) == null
                  ? void 0
                  : c.call(n, { isSelected: i, next: a, prev: s, select: o, selected: r })
              ]
            }
          })
        }),
        { next: a, prev: s, select: o }
      )
    }
  })
const e2 = ['x-small', 'small', 'default', 'large', 'x-large'],
  oa = ee({ size: { type: [String, Number], default: 'default' } }, 'size')
function mo(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : aa()
  return Bf(() => {
    let n, i
    return (
      ac(e2, e.size)
        ? (n = `${t}--size-${e.size}`)
        : e.size && (i = { width: Ve(e.size), height: Ve(e.size) }),
      { sizeClasses: n, sizeStyles: i }
    )
  })
}
const t2 = ee(
    { color: String, start: Boolean, end: Boolean, icon: Ye, ...Me(), ...oa(), ...Ke({ tag: 'i' }), ...ot() },
    'VIcon'
  ),
  gt = fe()({
    name: 'VIcon',
    props: t2(),
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const a = te(),
        { themeClasses: s } = ut(e),
        { iconData: o } = Wk(A(() => a.value || e.icon)),
        { sizeClasses: r } = mo(e),
        { textColorClasses: l, textColorStyles: c } = dn(ve(e, 'color'))
      return (
        ge(() => {
          var d, f
          const u = (d = i.default) == null ? void 0 : d.call(i)
          return (
            u &&
              (a.value =
                (f = G0(u).filter((h) => h.type === zr && h.children && typeof h.children == 'string')[0]) ==
                null
                  ? void 0
                  : f.children),
            m(
              o.value.component,
              {
                tag: e.tag,
                icon: o.value.icon,
                class: [
                  'v-icon',
                  'notranslate',
                  s.value,
                  r.value,
                  l.value,
                  { 'v-icon--clickable': !!n.onClick, 'v-icon--start': e.start, 'v-icon--end': e.end },
                  e.class
                ],
                style: [
                  r.value ? void 0 : { fontSize: Ve(e.size), height: Ve(e.size), width: Ve(e.size) },
                  c.value,
                  e.style
                ],
                role: n.onClick ? 'button' : void 0,
                'aria-hidden': !n.onClick
              },
              { default: () => [u] }
            )
          )
        }),
        {}
      )
    }
  })
function eh(e, t) {
  const n = te(),
    i = Ce(!1)
  if (Ff) {
    const a = new IntersectionObserver((s) => {
      e == null || e(s, a), (i.value = !!s.find((o) => o.isIntersecting))
    }, t)
    _n(() => {
      a.disconnect()
    }),
      Pe(
        n,
        (s, o) => {
          o && (a.unobserve(o), (i.value = !1)), s && a.observe(s)
        },
        { flush: 'post' }
      )
  }
  return { intersectionRef: n, isIntersecting: i }
}
const n2 = ee(
    {
      bgColor: String,
      color: String,
      indeterminate: [Boolean, String],
      modelValue: { type: [Number, String], default: 0 },
      rotate: { type: [Number, String], default: 0 },
      width: { type: [Number, String], default: 4 },
      ...Me(),
      ...oa(),
      ...Ke({ tag: 'div' }),
      ...ot()
    },
    'VProgressCircular'
  ),
  th = fe()({
    name: 'VProgressCircular',
    props: n2(),
    setup(e, t) {
      let { slots: n } = t
      const i = 20,
        a = 2 * Math.PI * i,
        s = te(),
        { themeClasses: o } = ut(e),
        { sizeClasses: r, sizeStyles: l } = mo(e),
        { textColorClasses: c, textColorStyles: u } = dn(ve(e, 'color')),
        { textColorClasses: d, textColorStyles: f } = dn(ve(e, 'bgColor')),
        { intersectionRef: h, isIntersecting: v } = eh(),
        { resizeRef: g, contentRect: p } = Ti(),
        y = A(() => Math.max(0, Math.min(100, parseFloat(e.modelValue)))),
        b = A(() => Number(e.width)),
        x = A(() => (l.value ? Number(e.size) : p.value ? p.value.width : Math.max(b.value, 32))),
        w = A(() => (i / (1 - b.value / x.value)) * 2),
        C = A(() => (b.value / x.value) * w.value),
        P = A(() => Ve(((100 - y.value) / 100) * a))
      return (
        Ut(() => {
          ;(h.value = s.value), (g.value = s.value)
        }),
        ge(() =>
          m(
            e.tag,
            {
              ref: s,
              class: [
                'v-progress-circular',
                {
                  'v-progress-circular--indeterminate': !!e.indeterminate,
                  'v-progress-circular--visible': v.value,
                  'v-progress-circular--disable-shrink': e.indeterminate === 'disable-shrink'
                },
                o.value,
                r.value,
                c.value,
                e.class
              ],
              style: [l.value, u.value, e.style],
              role: 'progressbar',
              'aria-valuemin': '0',
              'aria-valuemax': '100',
              'aria-valuenow': e.indeterminate ? void 0 : y.value
            },
            {
              default: () => [
                m(
                  'svg',
                  {
                    style: { transform: `rotate(calc(-90deg + ${Number(e.rotate)}deg))` },
                    xmlns: 'http://www.w3.org/2000/svg',
                    viewBox: `0 0 ${w.value} ${w.value}`
                  },
                  [
                    m(
                      'circle',
                      {
                        class: ['v-progress-circular__underlay', d.value],
                        style: f.value,
                        fill: 'transparent',
                        cx: '50%',
                        cy: '50%',
                        r: i,
                        'stroke-width': C.value,
                        'stroke-dasharray': a,
                        'stroke-dashoffset': 0
                      },
                      null
                    ),
                    m(
                      'circle',
                      {
                        class: 'v-progress-circular__overlay',
                        fill: 'transparent',
                        cx: '50%',
                        cy: '50%',
                        r: i,
                        'stroke-width': C.value,
                        'stroke-dasharray': a,
                        'stroke-dashoffset': P.value
                      },
                      null
                    )
                  ]
                ),
                n.default &&
                  m('div', { class: 'v-progress-circular__content' }, [n.default({ value: y.value })])
              ]
            }
          )
        ),
        {}
      )
    }
  })
const cg = { center: 'center', top: 'bottom', bottom: 'top', left: 'right', right: 'left' },
  Oa = ee({ location: String }, 'location')
function Ia(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    n = arguments.length > 2 ? arguments[2] : void 0
  const { isRtl: i } = Qt()
  return {
    locationStyles: A(() => {
      if (!e.location) return {}
      const { side: s, align: o } = ud(
        e.location.split(' ').length > 1 ? e.location : `${e.location} center`,
        i.value
      )
      function r(c) {
        return n ? n(c) : 0
      }
      const l = {}
      return (
        s !== 'center' && (t ? (l[cg[s]] = `calc(100% - ${r(s)}px)`) : (l[s] = 0)),
        o !== 'center'
          ? t
            ? (l[cg[o]] = `calc(100% - ${r(o)}px)`)
            : (l[o] = 0)
          : (s === 'center'
              ? (l.top = l.left = '50%')
              : (l[{ top: 'left', bottom: 'left', left: 'top', right: 'top' }[s]] = '50%'),
            (l.transform = {
              top: 'translateX(-50%)',
              bottom: 'translateX(-50%)',
              left: 'translateY(-50%)',
              right: 'translateY(-50%)',
              center: 'translate(-50%, -50%)'
            }[s])),
        l
      )
    })
  }
}
const i2 = ee(
    {
      absolute: Boolean,
      active: { type: Boolean, default: !0 },
      bgColor: String,
      bgOpacity: [Number, String],
      bufferValue: { type: [Number, String], default: 0 },
      clickable: Boolean,
      color: String,
      height: { type: [Number, String], default: 4 },
      indeterminate: Boolean,
      max: { type: [Number, String], default: 100 },
      modelValue: { type: [Number, String], default: 0 },
      reverse: Boolean,
      stream: Boolean,
      striped: Boolean,
      roundedBar: Boolean,
      ...Me(),
      ...Oa({ location: 'top' }),
      ...kt(),
      ...Ke(),
      ...ot()
    },
    'VProgressLinear'
  ),
  nh = fe()({
    name: 'VProgressLinear',
    props: i2(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = Ge(e, 'modelValue'),
        { isRtl: a, rtlClasses: s } = Qt(),
        { themeClasses: o } = ut(e),
        { locationStyles: r } = Ia(e),
        { textColorClasses: l, textColorStyles: c } = dn(e, 'color'),
        { backgroundColorClasses: u, backgroundColorStyles: d } = Rt(A(() => e.bgColor || e.color)),
        { backgroundColorClasses: f, backgroundColorStyles: h } = Rt(e, 'color'),
        { roundedClasses: v } = Lt(e),
        { intersectionRef: g, isIntersecting: p } = eh(),
        y = A(() => parseInt(e.max, 10)),
        b = A(() => parseInt(e.height, 10)),
        x = A(() => (parseFloat(e.bufferValue) / y.value) * 100),
        w = A(() => (parseFloat(i.value) / y.value) * 100),
        C = A(() => a.value !== e.reverse),
        P = A(() => (e.indeterminate ? 'fade-transition' : 'slide-x-transition')),
        k = A(() => (e.bgOpacity == null ? e.bgOpacity : parseFloat(e.bgOpacity)))
      function S(_) {
        if (!g.value) return
        const { left: T, right: B, width: O } = g.value.getBoundingClientRect(),
          N = C.value ? O - _.clientX + (B - O) : _.clientX - T
        i.value = Math.round((N / O) * y.value)
      }
      return (
        ge(() =>
          m(
            e.tag,
            {
              ref: g,
              class: [
                'v-progress-linear',
                {
                  'v-progress-linear--absolute': e.absolute,
                  'v-progress-linear--active': e.active && p.value,
                  'v-progress-linear--reverse': C.value,
                  'v-progress-linear--rounded': e.rounded,
                  'v-progress-linear--rounded-bar': e.roundedBar,
                  'v-progress-linear--striped': e.striped
                },
                v.value,
                o.value,
                s.value,
                e.class
              ],
              style: [
                {
                  bottom: e.location === 'bottom' ? 0 : void 0,
                  top: e.location === 'top' ? 0 : void 0,
                  height: e.active ? Ve(b.value) : 0,
                  '--v-progress-linear-height': Ve(b.value),
                  ...r.value
                },
                e.style
              ],
              role: 'progressbar',
              'aria-hidden': e.active ? 'false' : 'true',
              'aria-valuemin': '0',
              'aria-valuemax': e.max,
              'aria-valuenow': e.indeterminate ? void 0 : w.value,
              onClick: e.clickable && S
            },
            {
              default: () => [
                e.stream &&
                  m(
                    'div',
                    {
                      key: 'stream',
                      class: ['v-progress-linear__stream', l.value],
                      style: {
                        ...c.value,
                        [C.value ? 'left' : 'right']: Ve(-b.value),
                        borderTop: `${Ve(b.value / 2)} dotted`,
                        opacity: k.value,
                        top: `calc(50% - ${Ve(b.value / 4)})`,
                        width: Ve(100 - x.value, '%'),
                        '--v-progress-linear-stream-to': Ve(b.value * (C.value ? 1 : -1))
                      }
                    },
                    null
                  ),
                m(
                  'div',
                  {
                    class: ['v-progress-linear__background', u.value],
                    style: [d.value, { opacity: k.value, width: Ve(e.stream ? x.value : 100, '%') }]
                  },
                  null
                ),
                m(
                  Pi,
                  { name: P.value },
                  {
                    default: () => [
                      e.indeterminate
                        ? m('div', { class: 'v-progress-linear__indeterminate' }, [
                            ['long', 'short'].map((_) =>
                              m(
                                'div',
                                {
                                  key: _,
                                  class: ['v-progress-linear__indeterminate', _, f.value],
                                  style: h.value
                                },
                                null
                              )
                            )
                          ])
                        : m(
                            'div',
                            {
                              class: ['v-progress-linear__determinate', f.value],
                              style: [h.value, { width: Ve(w.value, '%') }]
                            },
                            null
                          )
                    ]
                  }
                ),
                n.default &&
                  m('div', { class: 'v-progress-linear__content' }, [
                    n.default({ value: w.value, buffer: x.value })
                  ])
              ]
            }
          )
        ),
        {}
      )
    }
  }),
  ih = ee({ loading: [Boolean, String] }, 'loader')
function Hc(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : aa()
  return { loaderClasses: A(() => ({ [`${t}--loading`]: e.loading })) }
}
function ah(e, t) {
  var i
  let { slots: n } = t
  return m('div', { class: `${e.name}__loader` }, [
    ((i = n.default) == null ? void 0 : i.call(n, { color: e.color, isActive: e.active })) ||
      m(nh, { active: e.active, color: e.color, height: '2', indeterminate: !0 }, null)
  ])
}
const a2 = ['static', 'relative', 'fixed', 'absolute', 'sticky'],
  po = ee({ position: { type: String, validator: (e) => a2.includes(e) } }, 'position')
function yo(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : aa()
  return { positionClasses: A(() => (e.position ? `${t}--${e.position}` : void 0)) }
}
function Ty() {
  var e, t
  return (t = (e = Jt('useRouter')) == null ? void 0 : e.proxy) == null ? void 0 : t.$router
}
function Wr(e, t) {
  const n = Iw('RouterLink'),
    i = A(() => !!(e.href || e.to)),
    a = A(() => (i == null ? void 0 : i.value) || Dv(t, 'click') || Dv(e, 'click'))
  if (typeof n == 'string') return { isLink: i, isClickable: a, href: ve(e, 'href') }
  const s = e.to ? n.useLink(e) : void 0
  return {
    isLink: i,
    isClickable: a,
    route: s == null ? void 0 : s.route,
    navigate: s == null ? void 0 : s.navigate,
    isActive:
      s &&
      A(() => {
        var o, r
        return e.exact
          ? (o = s.isExactActive) == null
            ? void 0
            : o.value
          : (r = s.isActive) == null
          ? void 0
          : r.value
      }),
    href: A(() => (e.to ? (s == null ? void 0 : s.route.value.href) : e.href))
  }
}
const jr = ee({ href: String, replace: Boolean, to: [String, Object], exact: Boolean }, 'router')
let wu = !1
function s2(e, t) {
  let n = !1,
    i,
    a
  yt &&
    (mt(() => {
      window.addEventListener('popstate', s),
        (i =
          e == null
            ? void 0
            : e.beforeEach((o, r, l) => {
                wu ? (n ? t(l) : l()) : setTimeout(() => (n ? t(l) : l())), (wu = !0)
              })),
        (a =
          e == null
            ? void 0
            : e.afterEach(() => {
                wu = !1
              }))
    }),
    Mn(() => {
      window.removeEventListener('popstate', s), i == null || i(), a == null || a()
    }))
  function s(o) {
    var r
    ;((r = o.state) != null && r.replaced) || ((n = !0), setTimeout(() => (n = !1)))
  }
}
function o2(e, t) {
  Pe(
    () => {
      var n
      return (n = e.isActive) == null ? void 0 : n.value
    },
    (n) => {
      e.isLink.value &&
        n &&
        t &&
        mt(() => {
          t(!0)
        })
    },
    { immediate: !0 }
  )
}
const wd = Symbol('rippleStop'),
  r2 = 80
function ug(e, t) {
  ;(e.style.transform = t), (e.style.webkitTransform = t)
}
function Sd(e) {
  return e.constructor.name === 'TouchEvent'
}
function Vy(e) {
  return e.constructor.name === 'KeyboardEvent'
}
const l2 = function (e, t) {
    var d
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      i = 0,
      a = 0
    if (!Vy(e)) {
      const f = t.getBoundingClientRect(),
        h = Sd(e) ? e.touches[e.touches.length - 1] : e
      ;(i = h.clientX - f.left), (a = h.clientY - f.top)
    }
    let s = 0,
      o = 0.3
    ;(d = t._ripple) != null && d.circle
      ? ((o = 0.15),
        (s = t.clientWidth / 2),
        (s = n.center ? s : s + Math.sqrt((i - s) ** 2 + (a - s) ** 2) / 4))
      : (s = Math.sqrt(t.clientWidth ** 2 + t.clientHeight ** 2) / 2)
    const r = `${(t.clientWidth - s * 2) / 2}px`,
      l = `${(t.clientHeight - s * 2) / 2}px`,
      c = n.center ? r : `${i - s}px`,
      u = n.center ? l : `${a - s}px`
    return { radius: s, scale: o, x: c, y: u, centerX: r, centerY: l }
  },
  cc = {
    show(e, t) {
      var h
      let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
      if (!((h = t == null ? void 0 : t._ripple) != null && h.enabled)) return
      const i = document.createElement('span'),
        a = document.createElement('span')
      i.appendChild(a), (i.className = 'v-ripple__container'), n.class && (i.className += ` ${n.class}`)
      const { radius: s, scale: o, x: r, y: l, centerX: c, centerY: u } = l2(e, t, n),
        d = `${s * 2}px`
      ;(a.className = 'v-ripple__animation'), (a.style.width = d), (a.style.height = d), t.appendChild(i)
      const f = window.getComputedStyle(t)
      f &&
        f.position === 'static' &&
        ((t.style.position = 'relative'), (t.dataset.previousPosition = 'static')),
        a.classList.add('v-ripple__animation--enter'),
        a.classList.add('v-ripple__animation--visible'),
        ug(a, `translate(${r}, ${l}) scale3d(${o},${o},${o})`),
        (a.dataset.activated = String(performance.now())),
        setTimeout(() => {
          a.classList.remove('v-ripple__animation--enter'),
            a.classList.add('v-ripple__animation--in'),
            ug(a, `translate(${c}, ${u}) scale3d(1,1,1)`)
        }, 0)
    },
    hide(e) {
      var s
      if (!((s = e == null ? void 0 : e._ripple) != null && s.enabled)) return
      const t = e.getElementsByClassName('v-ripple__animation')
      if (t.length === 0) return
      const n = t[t.length - 1]
      if (n.dataset.isHiding) return
      n.dataset.isHiding = 'true'
      const i = performance.now() - Number(n.dataset.activated),
        a = Math.max(250 - i, 0)
      setTimeout(() => {
        n.classList.remove('v-ripple__animation--in'),
          n.classList.add('v-ripple__animation--out'),
          setTimeout(() => {
            var r
            e.getElementsByClassName('v-ripple__animation').length === 1 &&
              e.dataset.previousPosition &&
              ((e.style.position = e.dataset.previousPosition), delete e.dataset.previousPosition),
              ((r = n.parentNode) == null ? void 0 : r.parentNode) === e && e.removeChild(n.parentNode)
          }, 300)
      }, a)
    }
  }
function Ey(e) {
  return typeof e > 'u' || !!e
}
function Sr(e) {
  const t = {},
    n = e.currentTarget
  if (!(!(n != null && n._ripple) || n._ripple.touched || e[wd])) {
    if (((e[wd] = !0), Sd(e))) (n._ripple.touched = !0), (n._ripple.isTouch = !0)
    else if (n._ripple.isTouch) return
    if (((t.center = n._ripple.centered || Vy(e)), n._ripple.class && (t.class = n._ripple.class), Sd(e))) {
      if (n._ripple.showTimerCommit) return
      ;(n._ripple.showTimerCommit = () => {
        cc.show(e, n, t)
      }),
        (n._ripple.showTimer = window.setTimeout(() => {
          var i
          ;(i = n == null ? void 0 : n._ripple) != null &&
            i.showTimerCommit &&
            (n._ripple.showTimerCommit(), (n._ripple.showTimerCommit = null))
        }, r2))
    } else cc.show(e, n, t)
  }
}
function dg(e) {
  e[wd] = !0
}
function On(e) {
  const t = e.currentTarget
  if (t != null && t._ripple) {
    if ((window.clearTimeout(t._ripple.showTimer), e.type === 'touchend' && t._ripple.showTimerCommit)) {
      t._ripple.showTimerCommit(),
        (t._ripple.showTimerCommit = null),
        (t._ripple.showTimer = window.setTimeout(() => {
          On(e)
        }))
      return
    }
    window.setTimeout(() => {
      t._ripple && (t._ripple.touched = !1)
    }),
      cc.hide(t)
  }
}
function Ly(e) {
  const t = e.currentTarget
  t != null &&
    t._ripple &&
    (t._ripple.showTimerCommit && (t._ripple.showTimerCommit = null),
    window.clearTimeout(t._ripple.showTimer))
}
let kr = !1
function Oy(e) {
  !kr && (e.keyCode === Ev.enter || e.keyCode === Ev.space) && ((kr = !0), Sr(e))
}
function Iy(e) {
  ;(kr = !1), On(e)
}
function Dy(e) {
  kr && ((kr = !1), On(e))
}
function Fy(e, t, n) {
  const { value: i, modifiers: a } = t,
    s = Ey(i)
  if (
    (s || cc.hide(e),
    (e._ripple = e._ripple ?? {}),
    (e._ripple.enabled = s),
    (e._ripple.centered = a.center),
    (e._ripple.circle = a.circle),
    ic(i) && i.class && (e._ripple.class = i.class),
    s && !n)
  ) {
    if (a.stop) {
      e.addEventListener('touchstart', dg, { passive: !0 }), e.addEventListener('mousedown', dg)
      return
    }
    e.addEventListener('touchstart', Sr, { passive: !0 }),
      e.addEventListener('touchend', On, { passive: !0 }),
      e.addEventListener('touchmove', Ly, { passive: !0 }),
      e.addEventListener('touchcancel', On),
      e.addEventListener('mousedown', Sr),
      e.addEventListener('mouseup', On),
      e.addEventListener('mouseleave', On),
      e.addEventListener('keydown', Oy),
      e.addEventListener('keyup', Iy),
      e.addEventListener('blur', Dy),
      e.addEventListener('dragstart', On, { passive: !0 })
  } else !s && n && Ry(e)
}
function Ry(e) {
  e.removeEventListener('mousedown', Sr),
    e.removeEventListener('touchstart', Sr),
    e.removeEventListener('touchend', On),
    e.removeEventListener('touchmove', Ly),
    e.removeEventListener('touchcancel', On),
    e.removeEventListener('mouseup', On),
    e.removeEventListener('mouseleave', On),
    e.removeEventListener('keydown', Oy),
    e.removeEventListener('keyup', Iy),
    e.removeEventListener('dragstart', On),
    e.removeEventListener('blur', Dy)
}
function c2(e, t) {
  Fy(e, t, !1)
}
function u2(e) {
  delete e._ripple, Ry(e)
}
function d2(e, t) {
  if (t.value === t.oldValue) return
  const n = Ey(t.oldValue)
  Fy(e, t, n)
}
const Da = { mounted: c2, unmounted: u2, updated: d2 },
  sh = ee(
    {
      active: { type: Boolean, default: void 0 },
      symbol: { type: null, default: Qf },
      flat: Boolean,
      icon: [Boolean, String, Function, Object],
      prependIcon: Ye,
      appendIcon: Ye,
      block: Boolean,
      stacked: Boolean,
      ripple: { type: [Boolean, Object], default: !0 },
      text: String,
      ...Bn(),
      ...Me(),
      ...Gt(),
      ...qn(),
      ...Yt(),
      ...vo(),
      ...ih(),
      ...Oa(),
      ...po(),
      ...kt(),
      ...jr(),
      ...oa(),
      ...Ke({ tag: 'button' }),
      ...ot(),
      ...Qn({ variant: 'elevated' })
    },
    'VBtn'
  ),
  bn = fe()({
    name: 'VBtn',
    directives: { Ripple: Da },
    props: sh(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const { themeClasses: a } = ut(e),
        { borderClasses: s } = Jn(e),
        { colorClasses: o, colorStyles: r, variantClasses: l } = ws(e),
        { densityClasses: c } = gn(e),
        { dimensionStyles: u } = Zn(e),
        { elevationClasses: d } = nn(e),
        { loaderClasses: f } = Hc(e),
        { locationStyles: h } = Ia(e),
        { positionClasses: v } = yo(e),
        { roundedClasses: g } = Lt(e),
        { sizeClasses: p, sizeStyles: y } = mo(e),
        b = go(e, e.symbol, !1),
        x = Wr(e, n),
        w = A(() => {
          var _
          return e.active !== void 0
            ? e.active
            : x.isLink.value
            ? (_ = x.isActive) == null
              ? void 0
              : _.value
            : b == null
            ? void 0
            : b.isSelected.value
        }),
        C = A(() => (b == null ? void 0 : b.disabled.value) || e.disabled),
        P = A(() => e.variant === 'elevated' && !(e.disabled || e.flat || e.border)),
        k = A(() => {
          if (e.value !== void 0)
            return Object(e.value) === e.value ? JSON.stringify(e.value, null, 0) : e.value
        })
      function S(_) {
        var T
        C.value ||
          (x.isLink.value &&
            (_.metaKey || _.ctrlKey || _.shiftKey || _.button !== 0 || n.target === '_blank')) ||
          ((T = x.navigate) == null || T.call(x, _), b == null || b.toggle())
      }
      return (
        o2(x, b == null ? void 0 : b.select),
        ge(() => {
          var Q, ue
          const _ = x.isLink.value ? 'a' : e.tag,
            T = !!(e.prependIcon || i.prepend),
            B = !!(e.appendIcon || i.append),
            O = !!(e.icon && e.icon !== !0),
            N =
              ((b == null ? void 0 : b.isSelected.value) &&
                (!x.isLink.value || ((Q = x.isActive) == null ? void 0 : Q.value))) ||
              !b ||
              ((ue = x.isActive) == null ? void 0 : ue.value)
          return Et(
            m(
              _,
              {
                type: _ === 'a' ? void 0 : 'button',
                class: [
                  'v-btn',
                  b == null ? void 0 : b.selectedClass.value,
                  {
                    'v-btn--active': w.value,
                    'v-btn--block': e.block,
                    'v-btn--disabled': C.value,
                    'v-btn--elevated': P.value,
                    'v-btn--flat': e.flat,
                    'v-btn--icon': !!e.icon,
                    'v-btn--loading': e.loading,
                    'v-btn--stacked': e.stacked
                  },
                  a.value,
                  s.value,
                  N ? o.value : void 0,
                  c.value,
                  d.value,
                  f.value,
                  v.value,
                  g.value,
                  p.value,
                  l.value,
                  e.class
                ],
                style: [N ? r.value : void 0, u.value, h.value, y.value, e.style],
                disabled: C.value || void 0,
                href: x.href.value,
                onClick: S,
                value: k.value
              },
              {
                default: () => {
                  var j
                  return [
                    xs(!0, 'v-btn'),
                    !e.icon &&
                      T &&
                      m('span', { key: 'prepend', class: 'v-btn__prepend' }, [
                        i.prepend
                          ? m(
                              vt,
                              {
                                key: 'prepend-defaults',
                                disabled: !e.prependIcon,
                                defaults: { VIcon: { icon: e.prependIcon } }
                              },
                              i.prepend
                            )
                          : m(gt, { key: 'prepend-icon', icon: e.prependIcon }, null)
                      ]),
                    m('span', { class: 'v-btn__content', 'data-no-activator': '' }, [
                      !i.default && O
                        ? m(gt, { key: 'content-icon', icon: e.icon }, null)
                        : m(
                            vt,
                            { key: 'content-defaults', disabled: !O, defaults: { VIcon: { icon: e.icon } } },
                            {
                              default: () => {
                                var U
                                return [((U = i.default) == null ? void 0 : U.call(i)) ?? e.text]
                              }
                            }
                          )
                    ]),
                    !e.icon &&
                      B &&
                      m('span', { key: 'append', class: 'v-btn__append' }, [
                        i.append
                          ? m(
                              vt,
                              {
                                key: 'append-defaults',
                                disabled: !e.appendIcon,
                                defaults: { VIcon: { icon: e.appendIcon } }
                              },
                              i.append
                            )
                          : m(gt, { key: 'append-icon', icon: e.appendIcon }, null)
                      ]),
                    !!e.loading &&
                      m('span', { key: 'loader', class: 'v-btn__loader' }, [
                        ((j = i.loader) == null ? void 0 : j.call(i)) ??
                          m(
                            th,
                            {
                              color: typeof e.loading == 'boolean' ? void 0 : e.loading,
                              indeterminate: !0,
                              size: '23',
                              width: '2'
                            },
                            null
                          )
                      ])
                  ]
                }
              }
            ),
            [[Fn('ripple'), !C.value && e.ripple, null]]
          )
        }),
        {}
      )
    }
  }),
  f2 = ee({ ...sh({ icon: '$menu', variant: 'text' }) }, 'VAppBarNavIcon'),
  h2 = fe()({
    name: 'VAppBarNavIcon',
    props: f2(),
    setup(e, t) {
      let { slots: n } = t
      return ge(() => m(bn, xe(e, { class: ['v-app-bar-nav-icon'] }), n)), {}
    }
  }),
  v2 = fe()({
    name: 'VAppBarTitle',
    props: _y(),
    setup(e, t) {
      let { slots: n } = t
      return ge(() => m(Xf, xe(e, { class: 'v-app-bar-title' }), n)), {}
    }
  })
const By = hi('v-alert-title'),
  g2 = ['success', 'info', 'warning', 'error'],
  m2 = ee(
    {
      border: {
        type: [Boolean, String],
        validator: (e) => typeof e == 'boolean' || ['top', 'end', 'bottom', 'start'].includes(e)
      },
      borderColor: String,
      closable: Boolean,
      closeIcon: { type: Ye, default: '$close' },
      closeLabel: { type: String, default: '$vuetify.close' },
      icon: { type: [Boolean, String, Function, Object], default: null },
      modelValue: { type: Boolean, default: !0 },
      prominent: Boolean,
      title: String,
      text: String,
      type: { type: String, validator: (e) => g2.includes(e) },
      ...Me(),
      ...Gt(),
      ...qn(),
      ...Yt(),
      ...Oa(),
      ...po(),
      ...kt(),
      ...Ke(),
      ...ot(),
      ...Qn({ variant: 'flat' })
    },
    'VAlert'
  ),
  p2 = fe()({
    name: 'VAlert',
    props: m2(),
    emits: { 'click:close': (e) => !0, 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: i } = t
      const a = Ge(e, 'modelValue'),
        s = A(() => {
          if (e.icon !== !1) return e.type ? e.icon ?? `$${e.type}` : e.icon
        }),
        o = A(() => ({ color: e.color ?? e.type, variant: e.variant })),
        { themeClasses: r } = ut(e),
        { colorClasses: l, colorStyles: c, variantClasses: u } = ws(o),
        { densityClasses: d } = gn(e),
        { dimensionStyles: f } = Zn(e),
        { elevationClasses: h } = nn(e),
        { locationStyles: v } = Ia(e),
        { positionClasses: g } = yo(e),
        { roundedClasses: p } = Lt(e),
        { textColorClasses: y, textColorStyles: b } = dn(ve(e, 'borderColor')),
        { t: x } = Kn(),
        w = A(() => ({
          'aria-label': x(e.closeLabel),
          onClick(C) {
            ;(a.value = !1), n('click:close', C)
          }
        }))
      return () => {
        const C = !!(i.prepend || s.value),
          P = !!(i.title || e.title),
          k = !!(i.close || e.closable)
        return (
          a.value &&
          m(
            e.tag,
            {
              class: [
                'v-alert',
                e.border && {
                  'v-alert--border': !!e.border,
                  [`v-alert--border-${e.border === !0 ? 'start' : e.border}`]: !0
                },
                { 'v-alert--prominent': e.prominent },
                r.value,
                l.value,
                d.value,
                h.value,
                g.value,
                p.value,
                u.value,
                e.class
              ],
              style: [c.value, f.value, v.value, e.style],
              role: 'alert'
            },
            {
              default: () => {
                var S, _
                return [
                  xs(!1, 'v-alert'),
                  e.border &&
                    m('div', { key: 'border', class: ['v-alert__border', y.value], style: b.value }, null),
                  C &&
                    m('div', { key: 'prepend', class: 'v-alert__prepend' }, [
                      i.prepend
                        ? m(
                            vt,
                            {
                              key: 'prepend-defaults',
                              disabled: !s.value,
                              defaults: {
                                VIcon: { density: e.density, icon: s.value, size: e.prominent ? 44 : 28 }
                              }
                            },
                            i.prepend
                          )
                        : m(
                            gt,
                            {
                              key: 'prepend-icon',
                              density: e.density,
                              icon: s.value,
                              size: e.prominent ? 44 : 28
                            },
                            null
                          )
                    ]),
                  m('div', { class: 'v-alert__content' }, [
                    P &&
                      m(
                        By,
                        { key: 'title' },
                        {
                          default: () => {
                            var T
                            return [((T = i.title) == null ? void 0 : T.call(i)) ?? e.title]
                          }
                        }
                      ),
                    ((S = i.text) == null ? void 0 : S.call(i)) ?? e.text,
                    (_ = i.default) == null ? void 0 : _.call(i)
                  ]),
                  i.append && m('div', { key: 'append', class: 'v-alert__append' }, [i.append()]),
                  k &&
                    m('div', { key: 'close', class: 'v-alert__close' }, [
                      i.close
                        ? m(
                            vt,
                            {
                              key: 'close-defaults',
                              defaults: { VBtn: { icon: e.closeIcon, size: 'x-small', variant: 'text' } }
                            },
                            {
                              default: () => {
                                var T
                                return [(T = i.close) == null ? void 0 : T.call(i, { props: w.value })]
                              }
                            }
                          )
                        : m(
                            bn,
                            xe(
                              { key: 'close-btn', icon: e.closeIcon, size: 'x-small', variant: 'text' },
                              w.value
                            ),
                            null
                          )
                    ])
                ]
              }
            }
          )
        )
      }
    }
  })
const y2 = ee({ text: String, clickable: Boolean, ...Me(), ...ot() }, 'VLabel'),
  bo = fe()({
    name: 'VLabel',
    props: y2(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ge(() => {
          var i
          return m(
            'label',
            { class: ['v-label', { 'v-label--clickable': e.clickable }, e.class], style: e.style },
            [e.text, (i = n.default) == null ? void 0 : i.call(n)]
          )
        }),
        {}
      )
    }
  })
const Ny = Symbol.for('vuetify:selection-control-group'),
  oh = ee(
    {
      color: String,
      disabled: { type: Boolean, default: null },
      defaultsTarget: String,
      error: Boolean,
      id: String,
      inline: Boolean,
      falseIcon: Ye,
      trueIcon: Ye,
      ripple: { type: Boolean, default: !0 },
      multiple: { type: Boolean, default: null },
      name: String,
      readonly: Boolean,
      modelValue: null,
      type: String,
      valueComparator: { type: Function, default: co },
      ...Me(),
      ...Gt(),
      ...ot()
    },
    'SelectionControlGroup'
  ),
  b2 = ee({ ...oh({ defaultsTarget: 'VSelectionControl' }) }, 'VSelectionControlGroup'),
  $y = fe()({
    name: 'VSelectionControlGroup',
    props: b2(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = Ge(e, 'modelValue'),
        a = vn(),
        s = A(() => e.id || `v-selection-control-group-${a}`),
        o = A(() => e.name || s.value),
        r = new Set()
      return (
        Vt(Ny, {
          modelValue: i,
          forceUpdate: () => {
            r.forEach((l) => l())
          },
          onForceUpdate: (l) => {
            r.add(l),
              Mn(() => {
                r.delete(l)
              })
          }
        }),
        zt({
          [e.defaultsTarget]: {
            color: ve(e, 'color'),
            disabled: ve(e, 'disabled'),
            density: ve(e, 'density'),
            error: ve(e, 'error'),
            inline: ve(e, 'inline'),
            modelValue: i,
            multiple: A(() => !!e.multiple || (e.multiple == null && Array.isArray(i.value))),
            name: o,
            falseIcon: ve(e, 'falseIcon'),
            trueIcon: ve(e, 'trueIcon'),
            readonly: ve(e, 'readonly'),
            ripple: ve(e, 'ripple'),
            type: ve(e, 'type'),
            valueComparator: ve(e, 'valueComparator')
          }
        }),
        ge(() => {
          var l
          return m(
            'div',
            {
              class: [
                'v-selection-control-group',
                { 'v-selection-control-group--inline': e.inline },
                e.class
              ],
              style: e.style,
              role: e.type === 'radio' ? 'radiogroup' : void 0
            },
            [(l = n.default) == null ? void 0 : l.call(n)]
          )
        }),
        {}
      )
    }
  }),
  Wc = ee(
    { label: String, trueValue: null, falseValue: null, value: null, ...Me(), ...oh() },
    'VSelectionControl'
  )
function _2(e) {
  const t = st(Ny, void 0),
    { densityClasses: n } = gn(e),
    i = Ge(e, 'modelValue'),
    a = A(() => (e.trueValue !== void 0 ? e.trueValue : e.value !== void 0 ? e.value : !0)),
    s = A(() => (e.falseValue !== void 0 ? e.falseValue : !1)),
    o = A(() => !!e.multiple || (e.multiple == null && Array.isArray(i.value))),
    r = A({
      get() {
        const h = t ? t.modelValue.value : i.value
        return o.value ? h.some((v) => e.valueComparator(v, a.value)) : e.valueComparator(h, a.value)
      },
      set(h) {
        if (e.readonly) return
        const v = h ? a.value : s.value
        let g = v
        o.value && (g = h ? [...Dn(i.value), v] : Dn(i.value).filter((p) => !e.valueComparator(p, a.value))),
          t ? (t.modelValue.value = g) : (i.value = g)
      }
    }),
    { textColorClasses: l, textColorStyles: c } = dn(
      A(() => (r.value && !e.error && !e.disabled ? e.color : void 0))
    ),
    { backgroundColorClasses: u, backgroundColorStyles: d } = Rt(
      A(() => (r.value && !e.error && !e.disabled ? e.color : void 0))
    ),
    f = A(() => (r.value ? e.trueIcon : e.falseIcon))
  return {
    group: t,
    densityClasses: n,
    trueValue: a,
    falseValue: s,
    model: r,
    textColorClasses: l,
    textColorStyles: c,
    backgroundColorClasses: u,
    backgroundColorStyles: d,
    icon: f
  }
}
const hs = fe()({
    name: 'VSelectionControl',
    directives: { Ripple: Da },
    inheritAttrs: !1,
    props: Wc(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const {
          group: a,
          densityClasses: s,
          icon: o,
          model: r,
          textColorClasses: l,
          textColorStyles: c,
          backgroundColorClasses: u,
          backgroundColorStyles: d,
          trueValue: f
        } = _2(e),
        h = vn(),
        v = A(() => e.id || `input-${h}`),
        g = Ce(!1),
        p = Ce(!1),
        y = te()
      a == null ||
        a.onForceUpdate(() => {
          y.value && (y.value.checked = r.value)
        })
      function b(C) {
        ;(g.value = !0), qs(C.target, ':focus-visible') !== !1 && (p.value = !0)
      }
      function x() {
        ;(g.value = !1), (p.value = !1)
      }
      function w(C) {
        e.readonly && a && mt(() => a.forceUpdate()), (r.value = C.target.checked)
      }
      return (
        ge(() => {
          var _, T
          const C = i.label ? i.label({ label: e.label, props: { for: v.value } }) : e.label,
            [P, k] = ys(n),
            S = m(
              'input',
              xe(
                {
                  ref: y,
                  checked: r.value,
                  disabled: !!(e.readonly || e.disabled),
                  id: v.value,
                  onBlur: x,
                  onFocus: b,
                  onInput: w,
                  'aria-disabled': !!(e.readonly || e.disabled),
                  type: e.type,
                  value: f.value,
                  name: e.name,
                  'aria-checked': e.type === 'checkbox' ? r.value : void 0
                },
                k
              ),
              null
            )
          return m(
            'div',
            xe(
              {
                class: [
                  'v-selection-control',
                  {
                    'v-selection-control--dirty': r.value,
                    'v-selection-control--disabled': e.disabled,
                    'v-selection-control--error': e.error,
                    'v-selection-control--focused': g.value,
                    'v-selection-control--focus-visible': p.value,
                    'v-selection-control--inline': e.inline
                  },
                  s.value,
                  e.class
                ]
              },
              P,
              { style: e.style }
            ),
            [
              m('div', { class: ['v-selection-control__wrapper', l.value], style: c.value }, [
                (_ = i.default) == null
                  ? void 0
                  : _.call(i, { backgroundColorClasses: u, backgroundColorStyles: d }),
                Et(
                  m('div', { class: ['v-selection-control__input'] }, [
                    ((T = i.input) == null
                      ? void 0
                      : T.call(i, {
                          model: r,
                          textColorClasses: l,
                          textColorStyles: c,
                          backgroundColorClasses: u,
                          backgroundColorStyles: d,
                          inputNode: S,
                          icon: o.value,
                          props: { onFocus: b, onBlur: x, id: v.value }
                        })) ?? m(Oe, null, [o.value && m(gt, { key: 'icon', icon: o.value }, null), S])
                  ]),
                  [[Fn('ripple'), e.ripple && [!e.disabled && !e.readonly, null, ['center', 'circle']]]]
                )
              ]),
              C &&
                m(
                  bo,
                  { for: v.value, clickable: !0, onClick: (B) => B.stopPropagation() },
                  { default: () => [C] }
                )
            ]
          )
        }),
        { isFocused: g, input: y }
      )
    }
  }),
  zy = ee(
    {
      indeterminate: Boolean,
      indeterminateIcon: { type: Ye, default: '$checkboxIndeterminate' },
      ...Wc({ falseIcon: '$checkboxOff', trueIcon: '$checkboxOn' })
    },
    'VCheckboxBtn'
  ),
  Qs = fe()({
    name: 'VCheckboxBtn',
    props: zy(),
    emits: { 'update:modelValue': (e) => !0, 'update:indeterminate': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = Ge(e, 'indeterminate'),
        a = Ge(e, 'modelValue')
      function s(l) {
        i.value && (i.value = !1)
      }
      const o = A(() => (i.value ? e.indeterminateIcon : e.falseIcon)),
        r = A(() => (i.value ? e.indeterminateIcon : e.trueIcon))
      return (
        ge(() => {
          const l = Gn(hs.filterProps(e)[0], ['modelValue'])
          return m(
            hs,
            xe(l, {
              modelValue: a.value,
              'onUpdate:modelValue': [(c) => (a.value = c), s],
              class: ['v-checkbox-btn', e.class],
              style: e.style,
              type: 'checkbox',
              falseIcon: o.value,
              trueIcon: r.value,
              'aria-checked': i.value ? 'mixed' : void 0
            }),
            n
          )
        }),
        {}
      )
    }
  })
function Hy(e) {
  const { t } = Kn()
  function n(i) {
    let { name: a } = i
    const s = {
        prepend: 'prependAction',
        prependInner: 'prependAction',
        append: 'appendAction',
        appendInner: 'appendAction',
        clear: 'clear'
      }[a],
      o = e[`onClick:${a}`],
      r = o && s ? t(`$vuetify.input.${s}`, e.label ?? '') : void 0
    return m(gt, { icon: e[`${a}Icon`], 'aria-label': r, onClick: o }, null)
  }
  return { InputIcon: n }
}
const x2 = ee(
    {
      active: Boolean,
      color: String,
      messages: { type: [Array, String], default: () => [] },
      ...Me(),
      ...sa({ transition: { component: qf, leaveAbsolute: !0, group: !0 } })
    },
    'VMessages'
  ),
  Wy = fe()({
    name: 'VMessages',
    props: x2(),
    setup(e, t) {
      let { slots: n } = t
      const i = A(() => Dn(e.messages)),
        { textColorClasses: a, textColorStyles: s } = dn(A(() => e.color))
      return (
        ge(() =>
          m(
            ii,
            {
              transition: e.transition,
              tag: 'div',
              class: ['v-messages', a.value, e.class],
              style: [s.value, e.style],
              role: 'alert',
              'aria-live': 'polite'
            },
            {
              default: () => [
                e.active &&
                  i.value.map((o, r) =>
                    m('div', { class: 'v-messages__message', key: `${r}-${i.value}` }, [
                      n.message ? n.message({ message: o }) : o
                    ])
                  )
              ]
            }
          )
        ),
        {}
      )
    }
  }),
  jc = ee({ focused: Boolean, 'onUpdate:focused': Mi() }, 'focus')
function Fa(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : aa()
  const n = Ge(e, 'focused'),
    i = A(() => ({ [`${t}--focused`]: n.value }))
  function a() {
    n.value = !0
  }
  function s() {
    n.value = !1
  }
  return { focusClasses: i, isFocused: n, focus: a, blur: s }
}
const jy = Symbol.for('vuetify:form'),
  w2 = ee(
    {
      disabled: Boolean,
      fastFail: Boolean,
      readonly: Boolean,
      modelValue: { type: Boolean, default: null },
      validateOn: { type: String, default: 'input' }
    },
    'form'
  )
function S2(e) {
  const t = Ge(e, 'modelValue'),
    n = A(() => e.disabled),
    i = A(() => e.readonly),
    a = Ce(!1),
    s = te([]),
    o = te([])
  async function r() {
    const u = []
    let d = !0
    ;(o.value = []), (a.value = !0)
    for (const f of s.value) {
      const h = await f.validate()
      if ((h.length > 0 && ((d = !1), u.push({ id: f.id, errorMessages: h })), !d && e.fastFail)) break
    }
    return (o.value = u), (a.value = !1), { valid: d, errors: o.value }
  }
  function l() {
    s.value.forEach((u) => u.reset())
  }
  function c() {
    s.value.forEach((u) => u.resetValidation())
  }
  return (
    Pe(
      s,
      () => {
        let u = 0,
          d = 0
        const f = []
        for (const h of s.value)
          h.isValid === !1
            ? (d++, f.push({ id: h.id, errorMessages: h.errorMessages }))
            : h.isValid === !0 && u++
        ;(o.value = f), (t.value = d > 0 ? !1 : u === s.value.length ? !0 : null)
      },
      { deep: !0 }
    ),
    Vt(jy, {
      register: (u) => {
        let { id: d, validate: f, reset: h, resetValidation: v } = u
        s.value.some((g) => g.id === d),
          s.value.push({ id: d, validate: f, reset: h, resetValidation: v, isValid: null, errorMessages: [] })
      },
      unregister: (u) => {
        s.value = s.value.filter((d) => d.id !== u)
      },
      update: (u, d, f) => {
        const h = s.value.find((v) => v.id === u)
        h && ((h.isValid = d), (h.errorMessages = f))
      },
      isDisabled: n,
      isReadonly: i,
      isValidating: a,
      isValid: t,
      items: s,
      validateOn: ve(e, 'validateOn')
    }),
    {
      errors: o,
      isDisabled: n,
      isReadonly: i,
      isValidating: a,
      isValid: t,
      items: s,
      validate: r,
      reset: l,
      resetValidation: c
    }
  )
}
function Uc() {
  return st(jy, null)
}
const Uy = ee(
  {
    disabled: { type: Boolean, default: null },
    error: Boolean,
    errorMessages: { type: [Array, String], default: () => [] },
    maxErrors: { type: [Number, String], default: 1 },
    name: String,
    label: String,
    readonly: { type: Boolean, default: null },
    rules: { type: Array, default: () => [] },
    modelValue: null,
    validateOn: String,
    validationValue: null,
    ...jc()
  },
  'validation'
)
function Yy(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : aa(),
    n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : vn()
  const i = Ge(e, 'modelValue'),
    a = A(() => (e.validationValue === void 0 ? i.value : e.validationValue)),
    s = Uc(),
    o = te([]),
    r = Ce(!0),
    l = A(() => !!(Dn(i.value === '' ? null : i.value).length || Dn(a.value === '' ? null : a.value).length)),
    c = A(() => !!(e.disabled ?? (s == null ? void 0 : s.isDisabled.value))),
    u = A(() => !!(e.readonly ?? (s == null ? void 0 : s.isReadonly.value))),
    d = A(() => (e.errorMessages.length ? Dn(e.errorMessages).slice(0, Math.max(0, +e.maxErrors)) : o.value)),
    f = A(() => {
      let w = (e.validateOn ?? (s == null ? void 0 : s.validateOn.value)) || 'input'
      w === 'lazy' && (w = 'input lazy')
      const C = new Set((w == null ? void 0 : w.split(' ')) ?? [])
      return {
        blur: C.has('blur') || C.has('input'),
        input: C.has('input'),
        submit: C.has('submit'),
        lazy: C.has('lazy')
      }
    }),
    h = A(() =>
      e.error || e.errorMessages.length
        ? !1
        : e.rules.length
        ? r.value
          ? o.value.length || f.value.lazy
            ? null
            : !0
          : !o.value.length
        : !0
    ),
    v = Ce(!1),
    g = A(() => ({
      [`${t}--error`]: h.value === !1,
      [`${t}--dirty`]: l.value,
      [`${t}--disabled`]: c.value,
      [`${t}--readonly`]: u.value
    })),
    p = A(() => e.name ?? Xe(n))
  Ic(() => {
    s == null || s.register({ id: p.value, validate: x, reset: y, resetValidation: b })
  }),
    _n(() => {
      s == null || s.unregister(p.value)
    }),
    tn(async () => {
      f.value.lazy || (await x(!0)), s == null || s.update(p.value, h.value, d.value)
    }),
    Aa(
      () => f.value.input,
      () => {
        Pe(a, () => {
          if (a.value != null) x()
          else if (e.focused) {
            const w = Pe(
              () => e.focused,
              (C) => {
                C || x(), w()
              }
            )
          }
        })
      }
    ),
    Aa(
      () => f.value.blur,
      () => {
        Pe(
          () => e.focused,
          (w) => {
            w || x()
          }
        )
      }
    ),
    Pe(h, () => {
      s == null || s.update(p.value, h.value, d.value)
    })
  function y() {
    ;(i.value = null), mt(b)
  }
  function b() {
    ;(r.value = !0), f.value.lazy ? (o.value = []) : x(!0)
  }
  async function x() {
    let w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1
    const C = []
    v.value = !0
    for (const P of e.rules) {
      if (C.length >= +(e.maxErrors ?? 1)) break
      const S = await (typeof P == 'function' ? P : () => P)(a.value)
      if (S !== !0) {
        if (S !== !1 && typeof S != 'string') {
          console.warn(`${S} is not a valid value. Rule functions must return boolean true or a string.`)
          continue
        }
        C.push(S || '')
      }
    }
    return (o.value = C), (v.value = !1), (r.value = w), o.value
  }
  return {
    errorMessages: d,
    isDirty: l,
    isDisabled: c,
    isReadonly: u,
    isPristine: r,
    isValid: h,
    isValidating: v,
    reset: y,
    resetValidation: b,
    validate: x,
    validationClasses: g
  }
}
const ra = ee(
    {
      id: String,
      appendIcon: Ye,
      centerAffix: { type: Boolean, default: !0 },
      prependIcon: Ye,
      hideDetails: [Boolean, String],
      hint: String,
      persistentHint: Boolean,
      messages: { type: [Array, String], default: () => [] },
      direction: {
        type: String,
        default: 'horizontal',
        validator: (e) => ['horizontal', 'vertical'].includes(e)
      },
      'onClick:prepend': Mi(),
      'onClick:append': Mi(),
      ...Me(),
      ...Gt(),
      ...Uy()
    },
    'VInput'
  ),
  en = fe()({
    name: 'VInput',
    props: { ...ra() },
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: i, emit: a } = t
      const { densityClasses: s } = gn(e),
        { rtlClasses: o } = Qt(),
        { InputIcon: r } = Hy(e),
        l = vn(),
        c = A(() => e.id || `input-${l}`),
        u = A(() => `${c.value}-messages`),
        {
          errorMessages: d,
          isDirty: f,
          isDisabled: h,
          isReadonly: v,
          isPristine: g,
          isValid: p,
          isValidating: y,
          reset: b,
          resetValidation: x,
          validate: w,
          validationClasses: C
        } = Yy(e, 'v-input', c),
        P = A(() => ({
          id: c,
          messagesId: u,
          isDirty: f,
          isDisabled: h,
          isReadonly: v,
          isPristine: g,
          isValid: p,
          isValidating: y,
          reset: b,
          resetValidation: x,
          validate: w
        })),
        k = A(() => {
          var S
          return ((S = e.errorMessages) != null && S.length) || (!g.value && d.value.length)
            ? d.value
            : e.hint && (e.persistentHint || e.focused)
            ? e.hint
            : e.messages
        })
      return (
        ge(() => {
          var O, N, Q, ue
          const S = !!(i.prepend || e.prependIcon),
            _ = !!(i.append || e.appendIcon),
            T = k.value.length > 0,
            B = !e.hideDetails || (e.hideDetails === 'auto' && (T || !!i.details))
          return m(
            'div',
            {
              class: [
                'v-input',
                `v-input--${e.direction}`,
                { 'v-input--center-affix': e.centerAffix },
                s.value,
                o.value,
                C.value,
                e.class
              ],
              style: e.style
            },
            [
              S &&
                m('div', { key: 'prepend', class: 'v-input__prepend' }, [
                  (O = i.prepend) == null ? void 0 : O.call(i, P.value),
                  e.prependIcon && m(r, { key: 'prepend-icon', name: 'prepend' }, null)
                ]),
              i.default &&
                m('div', { class: 'v-input__control' }, [
                  (N = i.default) == null ? void 0 : N.call(i, P.value)
                ]),
              _ &&
                m('div', { key: 'append', class: 'v-input__append' }, [
                  e.appendIcon && m(r, { key: 'append-icon', name: 'append' }, null),
                  (Q = i.append) == null ? void 0 : Q.call(i, P.value)
                ]),
              B &&
                m('div', { class: 'v-input__details' }, [
                  m(Wy, { id: u.value, active: T, messages: k.value }, { message: i.message }),
                  (ue = i.details) == null ? void 0 : ue.call(i, P.value)
                ])
            ]
          )
        }),
        { reset: b, resetValidation: x, validate: w }
      )
    }
  }),
  k2 = ee({ ...ra(), ...Gn(zy(), ['inline']) }, 'VCheckbox'),
  C2 = fe()({
    name: 'VCheckbox',
    inheritAttrs: !1,
    props: k2(),
    emits: { 'update:modelValue': (e) => !0, 'update:focused': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const a = Ge(e, 'modelValue'),
        { isFocused: s, focus: o, blur: r } = Fa(e),
        l = vn(),
        c = A(() => e.id || `checkbox-${l}`)
      return (
        ge(() => {
          const [u, d] = ys(n),
            [f, h] = en.filterProps(e),
            [v, g] = Qs.filterProps(e)
          return m(
            en,
            xe({ class: ['v-checkbox', e.class] }, u, f, {
              modelValue: a.value,
              'onUpdate:modelValue': (p) => (a.value = p),
              id: c.value,
              focused: s.value,
              style: e.style
            }),
            {
              ...i,
              default: (p) => {
                let { id: y, messagesId: b, isDisabled: x, isReadonly: w } = p
                return m(
                  Qs,
                  xe(
                    v,
                    { id: y.value, 'aria-describedby': b.value, disabled: x.value, readonly: w.value },
                    d,
                    {
                      modelValue: a.value,
                      'onUpdate:modelValue': (C) => (a.value = C),
                      onFocus: o,
                      onBlur: r
                    }
                  ),
                  i
                )
              }
            }
          )
        }),
        {}
      )
    }
  })
const M2 = ee(
    {
      start: Boolean,
      end: Boolean,
      icon: Ye,
      image: String,
      ...Me(),
      ...Gt(),
      ...kt(),
      ...oa(),
      ...Ke(),
      ...ot(),
      ...Qn({ variant: 'flat' })
    },
    'VAvatar'
  ),
  Pa = fe()({
    name: 'VAvatar',
    props: M2(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = ut(e),
        { colorClasses: a, colorStyles: s, variantClasses: o } = ws(e),
        { densityClasses: r } = gn(e),
        { roundedClasses: l } = Lt(e),
        { sizeClasses: c, sizeStyles: u } = mo(e)
      return (
        ge(() =>
          m(
            e.tag,
            {
              class: [
                'v-avatar',
                { 'v-avatar--start': e.start, 'v-avatar--end': e.end },
                i.value,
                a.value,
                r.value,
                l.value,
                c.value,
                o.value,
                e.class
              ],
              style: [s.value, u.value, e.style]
            },
            {
              default: () => {
                var d
                return [
                  e.image
                    ? m(fs, { key: 'image', src: e.image, alt: '', cover: !0 }, null)
                    : e.icon
                    ? m(gt, { key: 'icon', icon: e.icon }, null)
                    : (d = n.default) == null
                    ? void 0
                    : d.call(n),
                  xs(!1, 'v-avatar')
                ]
              }
            }
          )
        ),
        {}
      )
    }
  })
const Gy = Symbol.for('vuetify:v-chip-group'),
  A2 = ee(
    {
      column: Boolean,
      filter: Boolean,
      valueComparator: { type: Function, default: co },
      ...Me(),
      ...ho({ selectedClass: 'v-chip--selected' }),
      ...Ke(),
      ...ot(),
      ...Qn({ variant: 'tonal' })
    },
    'VChipGroup'
  ),
  P2 = fe()({
    name: 'VChipGroup',
    props: A2(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = ut(e),
        { isSelected: a, select: s, next: o, prev: r, selected: l } = Ss(e, Gy)
      return (
        zt({
          VChip: {
            color: ve(e, 'color'),
            disabled: ve(e, 'disabled'),
            filter: ve(e, 'filter'),
            variant: ve(e, 'variant')
          }
        }),
        ge(() =>
          m(
            e.tag,
            {
              class: ['v-chip-group', { 'v-chip-group--column': e.column }, i.value, e.class],
              style: e.style
            },
            {
              default: () => {
                var c
                return [
                  (c = n.default) == null
                    ? void 0
                    : c.call(n, { isSelected: a, select: s, next: o, prev: r, selected: l.value })
                ]
              }
            }
          )
        ),
        {}
      )
    }
  }),
  T2 = ee(
    {
      activeClass: String,
      appendAvatar: String,
      appendIcon: Ye,
      closable: Boolean,
      closeIcon: { type: Ye, default: '$delete' },
      closeLabel: { type: String, default: '$vuetify.close' },
      draggable: Boolean,
      filter: Boolean,
      filterIcon: { type: String, default: '$complete' },
      label: Boolean,
      link: { type: Boolean, default: void 0 },
      pill: Boolean,
      prependAvatar: String,
      prependIcon: Ye,
      ripple: { type: [Boolean, Object], default: !0 },
      text: String,
      modelValue: { type: Boolean, default: !0 },
      onClick: Mi(),
      onClickOnce: Mi(),
      ...Bn(),
      ...Me(),
      ...Gt(),
      ...Yt(),
      ...vo(),
      ...kt(),
      ...jr(),
      ...oa(),
      ...Ke({ tag: 'span' }),
      ...ot(),
      ...Qn({ variant: 'tonal' })
    },
    'VChip'
  ),
  Ur = fe()({
    name: 'VChip',
    directives: { Ripple: Da },
    props: T2(),
    emits: {
      'click:close': (e) => !0,
      'update:modelValue': (e) => !0,
      'group:selected': (e) => !0,
      click: (e) => !0
    },
    setup(e, t) {
      let { attrs: n, emit: i, slots: a } = t
      const { t: s } = Kn(),
        { borderClasses: o } = Jn(e),
        { colorClasses: r, colorStyles: l, variantClasses: c } = ws(e),
        { densityClasses: u } = gn(e),
        { elevationClasses: d } = nn(e),
        { roundedClasses: f } = Lt(e),
        { sizeClasses: h } = mo(e),
        { themeClasses: v } = ut(e),
        g = Ge(e, 'modelValue'),
        p = go(e, Gy, !1),
        y = Wr(e, n),
        b = A(() => e.link !== !1 && y.isLink.value),
        x = A(() => !e.disabled && e.link !== !1 && (!!p || e.link || y.isClickable.value)),
        w = A(() => ({
          'aria-label': s(e.closeLabel),
          onClick(k) {
            k.stopPropagation(), (g.value = !1), i('click:close', k)
          }
        }))
      function C(k) {
        var S
        i('click', k), x.value && ((S = y.navigate) == null || S.call(y, k), p == null || p.toggle())
      }
      function P(k) {
        ;(k.key === 'Enter' || k.key === ' ') && (k.preventDefault(), C(k))
      }
      return () => {
        const k = y.isLink.value ? 'a' : e.tag,
          S = !!(e.appendIcon || e.appendAvatar),
          _ = !!(S || a.append),
          T = !!(a.close || e.closable),
          B = !!(a.filter || e.filter) && p,
          O = !!(e.prependIcon || e.prependAvatar),
          N = !!(O || a.prepend),
          Q = !p || p.isSelected.value
        return (
          g.value &&
          Et(
            m(
              k,
              {
                class: [
                  'v-chip',
                  {
                    'v-chip--disabled': e.disabled,
                    'v-chip--label': e.label,
                    'v-chip--link': x.value,
                    'v-chip--filter': B,
                    'v-chip--pill': e.pill
                  },
                  v.value,
                  o.value,
                  Q ? r.value : void 0,
                  u.value,
                  d.value,
                  f.value,
                  h.value,
                  c.value,
                  p == null ? void 0 : p.selectedClass.value,
                  e.class
                ],
                style: [Q ? l.value : void 0, e.style],
                disabled: e.disabled || void 0,
                draggable: e.draggable,
                href: y.href.value,
                tabindex: x.value ? 0 : void 0,
                onClick: C,
                onKeydown: x.value && !b.value && P
              },
              {
                default: () => {
                  var ue
                  return [
                    xs(x.value, 'v-chip'),
                    B &&
                      m(
                        Zf,
                        { key: 'filter' },
                        {
                          default: () => [
                            Et(
                              m('div', { class: 'v-chip__filter' }, [
                                a.filter
                                  ? m(
                                      vt,
                                      {
                                        key: 'filter-defaults',
                                        disabled: !e.filterIcon,
                                        defaults: { VIcon: { icon: e.filterIcon } }
                                      },
                                      a.filter
                                    )
                                  : m(gt, { key: 'filter-icon', icon: e.filterIcon }, null)
                              ]),
                              [[Li, p.isSelected.value]]
                            )
                          ]
                        }
                      ),
                    N &&
                      m('div', { key: 'prepend', class: 'v-chip__prepend' }, [
                        a.prepend
                          ? m(
                              vt,
                              {
                                key: 'prepend-defaults',
                                disabled: !O,
                                defaults: {
                                  VAvatar: { image: e.prependAvatar, start: !0 },
                                  VIcon: { icon: e.prependIcon, start: !0 }
                                }
                              },
                              a.prepend
                            )
                          : m(Oe, null, [
                              e.prependIcon &&
                                m(gt, { key: 'prepend-icon', icon: e.prependIcon, start: !0 }, null),
                              e.prependAvatar &&
                                m(Pa, { key: 'prepend-avatar', image: e.prependAvatar, start: !0 }, null)
                            ])
                      ]),
                    m('div', { class: 'v-chip__content' }, [
                      ((ue = a.default) == null
                        ? void 0
                        : ue.call(a, {
                            isSelected: p == null ? void 0 : p.isSelected.value,
                            selectedClass: p == null ? void 0 : p.selectedClass.value,
                            select: p == null ? void 0 : p.select,
                            toggle: p == null ? void 0 : p.toggle,
                            value: p == null ? void 0 : p.value.value,
                            disabled: e.disabled
                          })) ?? e.text
                    ]),
                    _ &&
                      m('div', { key: 'append', class: 'v-chip__append' }, [
                        a.append
                          ? m(
                              vt,
                              {
                                key: 'append-defaults',
                                disabled: !S,
                                defaults: {
                                  VAvatar: { end: !0, image: e.appendAvatar },
                                  VIcon: { end: !0, icon: e.appendIcon }
                                }
                              },
                              a.append
                            )
                          : m(Oe, null, [
                              e.appendIcon &&
                                m(gt, { key: 'append-icon', end: !0, icon: e.appendIcon }, null),
                              e.appendAvatar &&
                                m(Pa, { key: 'append-avatar', end: !0, image: e.appendAvatar }, null)
                            ])
                      ]),
                    T &&
                      m('div', xe({ key: 'close', class: 'v-chip__close' }, w.value), [
                        a.close
                          ? m(
                              vt,
                              {
                                key: 'close-defaults',
                                defaults: { VIcon: { icon: e.closeIcon, size: 'x-small' } }
                              },
                              a.close
                            )
                          : m(gt, { key: 'close-icon', icon: e.closeIcon, size: 'x-small' }, null)
                      ])
                  ]
                }
              }
            ),
            [[Fn('ripple'), x.value && e.ripple, null]]
          )
        )
      }
    }
  })
const kd = Symbol.for('vuetify:list')
function Xy() {
  const e = st(kd, { hasPrepend: Ce(!1), updateHasPrepend: () => null }),
    t = {
      hasPrepend: Ce(!1),
      updateHasPrepend: (n) => {
        n && (t.hasPrepend.value = n)
      }
    }
  return Vt(kd, t), e
}
function Ky() {
  return st(kd, null)
}
const V2 = {
    open: (e) => {
      let { id: t, value: n, opened: i, parents: a } = e
      if (n) {
        const s = new Set()
        s.add(t)
        let o = a.get(t)
        for (; o != null; ) s.add(o), (o = a.get(o))
        return s
      } else return i.delete(t), i
    },
    select: () => null
  },
  qy = {
    open: (e) => {
      let { id: t, value: n, opened: i, parents: a } = e
      if (n) {
        let s = a.get(t)
        for (i.add(t); s != null && s !== t; ) i.add(s), (s = a.get(s))
        return i
      } else i.delete(t)
      return i
    },
    select: () => null
  },
  E2 = {
    open: qy.open,
    select: (e) => {
      let { id: t, value: n, opened: i, parents: a } = e
      if (!n) return i
      const s = []
      let o = a.get(t)
      for (; o != null; ) s.push(o), (o = a.get(o))
      return new Set(s)
    }
  },
  rh = (e) => {
    const t = {
      select: (n) => {
        let { id: i, value: a, selected: s } = n
        if (((i = Qe(i)), e && !a)) {
          const o = Array.from(s.entries()).reduce((r, l) => {
            let [c, u] = l
            return u === 'on' ? [...r, c] : r
          }, [])
          if (o.length === 1 && o[0] === i) return s
        }
        return s.set(i, a ? 'on' : 'off'), s
      },
      in: (n, i, a) => {
        let s = new Map()
        for (const o of n || [])
          s = t.select({ id: o, value: !0, selected: new Map(s), children: i, parents: a })
        return s
      },
      out: (n) => {
        const i = []
        for (const [a, s] of n.entries()) s === 'on' && i.push(a)
        return i
      }
    }
    return t
  },
  Zy = (e) => {
    const t = rh(e)
    return {
      select: (i) => {
        let { selected: a, id: s, ...o } = i
        s = Qe(s)
        const r = a.has(s) ? new Map([[s, a.get(s)]]) : new Map()
        return t.select({ ...o, id: s, selected: r })
      },
      in: (i, a, s) => {
        let o = new Map()
        return i != null && i.length && (o = t.in(i.slice(0, 1), a, s)), o
      },
      out: (i, a, s) => t.out(i, a, s)
    }
  },
  L2 = (e) => {
    const t = rh(e)
    return {
      select: (i) => {
        let { id: a, selected: s, children: o, ...r } = i
        return (a = Qe(a)), o.has(a) ? s : t.select({ id: a, selected: s, children: o, ...r })
      },
      in: t.in,
      out: t.out
    }
  },
  O2 = (e) => {
    const t = Zy(e)
    return {
      select: (i) => {
        let { id: a, selected: s, children: o, ...r } = i
        return (a = Qe(a)), o.has(a) ? s : t.select({ id: a, selected: s, children: o, ...r })
      },
      in: t.in,
      out: t.out
    }
  },
  I2 = (e) => {
    const t = {
      select: (n) => {
        let { id: i, value: a, selected: s, children: o, parents: r } = n
        i = Qe(i)
        const l = new Map(s),
          c = [i]
        for (; c.length; ) {
          const d = c.shift()
          s.set(d, a ? 'on' : 'off'), o.has(d) && c.push(...o.get(d))
        }
        let u = r.get(i)
        for (; u; ) {
          const d = o.get(u),
            f = d.every((v) => s.get(v) === 'on'),
            h = d.every((v) => !s.has(v) || s.get(v) === 'off')
          s.set(u, f ? 'on' : h ? 'off' : 'indeterminate'), (u = r.get(u))
        }
        return e &&
          !a &&
          Array.from(s.entries()).reduce((f, h) => {
            let [v, g] = h
            return g === 'on' ? [...f, v] : f
          }, []).length === 0
          ? l
          : s
      },
      in: (n, i, a) => {
        let s = new Map()
        for (const o of n || [])
          s = t.select({ id: o, value: !0, selected: new Map(s), children: i, parents: a })
        return s
      },
      out: (n, i) => {
        const a = []
        for (const [s, o] of n.entries()) o === 'on' && !i.has(s) && a.push(s)
        return a
      }
    }
    return t
  },
  Cr = Symbol.for('vuetify:nested'),
  Jy = {
    id: Ce(),
    root: {
      register: () => null,
      unregister: () => null,
      parents: te(new Map()),
      children: te(new Map()),
      open: () => null,
      openOnSelect: () => null,
      select: () => null,
      opened: te(new Set()),
      selected: te(new Map()),
      selectedValues: te([])
    }
  },
  D2 = ee(
    {
      selectStrategy: [String, Function],
      openStrategy: [String, Object],
      opened: Array,
      selected: Array,
      mandatory: Boolean
    },
    'nested'
  ),
  F2 = (e) => {
    let t = !1
    const n = te(new Map()),
      i = te(new Map()),
      a = Ge(
        e,
        'opened',
        e.opened,
        (d) => new Set(d),
        (d) => [...d.values()]
      ),
      s = A(() => {
        if (typeof e.selectStrategy == 'object') return e.selectStrategy
        switch (e.selectStrategy) {
          case 'single-leaf':
            return O2(e.mandatory)
          case 'leaf':
            return L2(e.mandatory)
          case 'independent':
            return rh(e.mandatory)
          case 'single-independent':
            return Zy(e.mandatory)
          case 'classic':
          default:
            return I2(e.mandatory)
        }
      }),
      o = A(() => {
        if (typeof e.openStrategy == 'object') return e.openStrategy
        switch (e.openStrategy) {
          case 'list':
            return E2
          case 'single':
            return V2
          case 'multiple':
          default:
            return qy
        }
      }),
      r = Ge(
        e,
        'selected',
        e.selected,
        (d) => s.value.in(d, n.value, i.value),
        (d) => s.value.out(d, n.value, i.value)
      )
    _n(() => {
      t = !0
    })
    function l(d) {
      const f = []
      let h = d
      for (; h != null; ) f.unshift(h), (h = i.value.get(h))
      return f
    }
    const c = Jt('nested'),
      u = {
        id: Ce(),
        root: {
          opened: a,
          selected: r,
          selectedValues: A(() => {
            const d = []
            for (const [f, h] of r.value.entries()) h === 'on' && d.push(f)
            return d
          }),
          register: (d, f, h) => {
            f && d !== f && i.value.set(d, f),
              h && n.value.set(d, []),
              f != null && n.value.set(f, [...(n.value.get(f) || []), d])
          },
          unregister: (d) => {
            if (t) return
            n.value.delete(d)
            const f = i.value.get(d)
            if (f) {
              const h = n.value.get(f) ?? []
              n.value.set(
                f,
                h.filter((v) => v !== d)
              )
            }
            i.value.delete(d), a.value.delete(d)
          },
          open: (d, f, h) => {
            c.emit('click:open', { id: d, value: f, path: l(d), event: h })
            const v = o.value.open({
              id: d,
              value: f,
              opened: new Set(a.value),
              children: n.value,
              parents: i.value,
              event: h
            })
            v && (a.value = v)
          },
          openOnSelect: (d, f, h) => {
            const v = o.value.select({
              id: d,
              value: f,
              selected: new Map(r.value),
              opened: new Set(a.value),
              children: n.value,
              parents: i.value,
              event: h
            })
            v && (a.value = v)
          },
          select: (d, f, h) => {
            c.emit('click:select', { id: d, value: f, path: l(d), event: h })
            const v = s.value.select({
              id: d,
              value: f,
              selected: new Map(r.value),
              children: n.value,
              parents: i.value,
              event: h
            })
            v && (r.value = v), u.root.openOnSelect(d, f, h)
          },
          children: n,
          parents: i
        }
      }
    return Vt(Cr, u), u.root
  },
  Qy = (e, t) => {
    const n = st(Cr, Jy),
      i = Symbol(vn()),
      a = A(() => (e.value !== void 0 ? e.value : i)),
      s = {
        ...n,
        id: a,
        open: (o, r) => n.root.open(a.value, o, r),
        openOnSelect: (o, r) => n.root.openOnSelect(a.value, o, r),
        isOpen: A(() => n.root.opened.value.has(a.value)),
        parent: A(() => n.root.parents.value.get(a.value)),
        select: (o, r) => n.root.select(a.value, o, r),
        isSelected: A(() => n.root.selected.value.get(Qe(a.value)) === 'on'),
        isIndeterminate: A(() => n.root.selected.value.get(a.value) === 'indeterminate'),
        isLeaf: A(() => !n.root.children.value.get(a.value)),
        isGroupActivator: n.isGroupActivator
      }
    return (
      !n.isGroupActivator && n.root.register(a.value, n.id.value, t),
      _n(() => {
        !n.isGroupActivator && n.root.unregister(a.value)
      }),
      t && Vt(Cr, s),
      s
    )
  },
  R2 = () => {
    const e = st(Cr, Jy)
    Vt(Cr, { ...e, isGroupActivator: !0 })
  },
  B2 = Xn({
    name: 'VListGroupActivator',
    setup(e, t) {
      let { slots: n } = t
      return (
        R2(),
        () => {
          var i
          return (i = n.default) == null ? void 0 : i.call(n)
        }
      )
    }
  }),
  N2 = ee(
    {
      activeColor: String,
      baseColor: String,
      color: String,
      collapseIcon: { type: Ye, default: '$collapse' },
      expandIcon: { type: Ye, default: '$expand' },
      prependIcon: Ye,
      appendIcon: Ye,
      fluid: Boolean,
      subgroup: Boolean,
      title: String,
      value: null,
      ...Me(),
      ...Ke()
    },
    'VListGroup'
  ),
  Cd = fe()({
    name: 'VListGroup',
    props: N2(),
    setup(e, t) {
      let { slots: n } = t
      const { isOpen: i, open: a, id: s } = Qy(ve(e, 'value'), !0),
        o = A(() => `v-list-group--id-${String(s.value)}`),
        r = Ky(),
        { isBooted: l } = _s()
      function c(h) {
        a(!i.value, h)
      }
      const u = A(() => ({ onClick: c, class: 'v-list-group__header', id: o.value })),
        d = A(() => (i.value ? e.collapseIcon : e.expandIcon)),
        f = A(() => ({
          VListItem: {
            active: i.value,
            activeColor: e.activeColor,
            baseColor: e.baseColor,
            color: e.color,
            prependIcon: e.prependIcon || (e.subgroup && d.value),
            appendIcon: e.appendIcon || (!e.subgroup && d.value),
            title: e.title,
            value: e.value
          }
        }))
      return (
        ge(() =>
          m(
            e.tag,
            {
              class: [
                'v-list-group',
                {
                  'v-list-group--prepend': r == null ? void 0 : r.hasPrepend.value,
                  'v-list-group--fluid': e.fluid,
                  'v-list-group--subgroup': e.subgroup,
                  'v-list-group--open': i.value
                },
                e.class
              ],
              style: e.style
            },
            {
              default: () => [
                n.activator &&
                  m(
                    vt,
                    { defaults: f.value },
                    {
                      default: () => [
                        m(B2, null, { default: () => [n.activator({ props: u.value, isOpen: i.value })] })
                      ]
                    }
                  ),
                m(
                  ii,
                  { transition: { component: zc }, disabled: !l.value },
                  {
                    default: () => {
                      var h
                      return [
                        Et(
                          m(
                            'div',
                            { class: 'v-list-group__items', role: 'group', 'aria-labelledby': o.value },
                            [(h = n.default) == null ? void 0 : h.call(n)]
                          ),
                          [[Li, i.value]]
                        )
                      ]
                    }
                  }
                )
              ]
            }
          )
        ),
        {}
      )
    }
  })
const eb = hi('v-list-item-subtitle'),
  tb = hi('v-list-item-title'),
  $2 = ee(
    {
      active: { type: Boolean, default: void 0 },
      activeClass: String,
      activeColor: String,
      appendAvatar: String,
      appendIcon: Ye,
      baseColor: String,
      disabled: Boolean,
      lines: String,
      link: { type: Boolean, default: void 0 },
      nav: Boolean,
      prependAvatar: String,
      prependIcon: Ye,
      ripple: { type: [Boolean, Object], default: !0 },
      subtitle: [String, Number, Boolean],
      title: [String, Number, Boolean],
      value: null,
      onClick: Mi(),
      onClickOnce: Mi(),
      ...Bn(),
      ...Me(),
      ...Gt(),
      ...qn(),
      ...Yt(),
      ...kt(),
      ...jr(),
      ...Ke(),
      ...ot(),
      ...Qn({ variant: 'text' })
    },
    'VListItem'
  ),
  Qi = fe()({
    name: 'VListItem',
    directives: { Ripple: Da },
    props: $2(),
    emits: { click: (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: i, emit: a } = t
      const s = Wr(e, n),
        o = A(() => (e.value === void 0 ? s.href.value : e.value)),
        {
          select: r,
          isSelected: l,
          isIndeterminate: c,
          isGroupActivator: u,
          root: d,
          parent: f,
          openOnSelect: h
        } = Qy(o, !1),
        v = Ky(),
        g = A(() => {
          var X
          return e.active !== !1 && (e.active || ((X = s.isActive) == null ? void 0 : X.value) || l.value)
        }),
        p = A(() => e.link !== !1 && s.isLink.value),
        y = A(
          () => !e.disabled && e.link !== !1 && (e.link || s.isClickable.value || (e.value != null && !!v))
        ),
        b = A(() => e.rounded || e.nav),
        x = A(() => e.color ?? e.activeColor),
        w = A(() => ({ color: g.value ? x.value ?? e.baseColor : e.baseColor, variant: e.variant }))
      Pe(
        () => {
          var X
          return (X = s.isActive) == null ? void 0 : X.value
        },
        (X) => {
          X && f.value != null && d.open(f.value, !0), X && h(X)
        },
        { immediate: !0 }
      )
      const { themeClasses: C } = ut(e),
        { borderClasses: P } = Jn(e),
        { colorClasses: k, colorStyles: S, variantClasses: _ } = ws(w),
        { densityClasses: T } = gn(e),
        { dimensionStyles: B } = Zn(e),
        { elevationClasses: O } = nn(e),
        { roundedClasses: N } = Lt(b),
        Q = A(() => (e.lines ? `v-list-item--${e.lines}-line` : void 0)),
        ue = A(() => ({ isActive: g.value, select: r, isSelected: l.value, isIndeterminate: c.value }))
      function j(X) {
        var oe
        a('click', X),
          !(u || !y.value) && ((oe = s.navigate) == null || oe.call(s, X), e.value != null && r(!l.value, X))
      }
      function U(X) {
        ;(X.key === 'Enter' || X.key === ' ') && (X.preventDefault(), j(X))
      }
      return (
        ge(() => {
          const X = p.value ? 'a' : e.tag,
            oe = i.title || e.title,
            de = i.subtitle || e.subtitle,
            ce = !!(e.appendAvatar || e.appendIcon),
            Te = !!(ce || i.append),
            $e = !!(e.prependAvatar || e.prependIcon),
            He = !!($e || i.prepend)
          return (
            v == null || v.updateHasPrepend(He),
            e.activeColor && gk('active-color', ['color', 'base-color']),
            Et(
              m(
                X,
                {
                  class: [
                    'v-list-item',
                    {
                      'v-list-item--active': g.value,
                      'v-list-item--disabled': e.disabled,
                      'v-list-item--link': y.value,
                      'v-list-item--nav': e.nav,
                      'v-list-item--prepend': !He && (v == null ? void 0 : v.hasPrepend.value),
                      [`${e.activeClass}`]: e.activeClass && g.value
                    },
                    C.value,
                    P.value,
                    k.value,
                    T.value,
                    O.value,
                    Q.value,
                    N.value,
                    _.value,
                    e.class
                  ],
                  style: [S.value, B.value, e.style],
                  href: s.href.value,
                  tabindex: y.value ? (v ? -2 : 0) : void 0,
                  onClick: j,
                  onKeydown: y.value && !p.value && U
                },
                {
                  default: () => {
                    var Ue
                    return [
                      xs(y.value || g.value, 'v-list-item'),
                      He &&
                        m('div', { key: 'prepend', class: 'v-list-item__prepend' }, [
                          i.prepend
                            ? m(
                                vt,
                                {
                                  key: 'prepend-defaults',
                                  disabled: !$e,
                                  defaults: {
                                    VAvatar: { density: e.density, image: e.prependAvatar },
                                    VIcon: { density: e.density, icon: e.prependIcon },
                                    VListItemAction: { start: !0 }
                                  }
                                },
                                {
                                  default: () => {
                                    var ie
                                    return [(ie = i.prepend) == null ? void 0 : ie.call(i, ue.value)]
                                  }
                                }
                              )
                            : m(Oe, null, [
                                e.prependAvatar &&
                                  m(
                                    Pa,
                                    { key: 'prepend-avatar', density: e.density, image: e.prependAvatar },
                                    null
                                  ),
                                e.prependIcon &&
                                  m(
                                    gt,
                                    { key: 'prepend-icon', density: e.density, icon: e.prependIcon },
                                    null
                                  )
                              ]),
                          m('div', { class: 'v-list-item__spacer' }, null)
                        ]),
                      m('div', { class: 'v-list-item__content', 'data-no-activator': '' }, [
                        oe &&
                          m(
                            tb,
                            { key: 'title' },
                            {
                              default: () => {
                                var ie
                                return [
                                  ((ie = i.title) == null ? void 0 : ie.call(i, { title: e.title })) ??
                                    e.title
                                ]
                              }
                            }
                          ),
                        de &&
                          m(
                            eb,
                            { key: 'subtitle' },
                            {
                              default: () => {
                                var ie
                                return [
                                  ((ie = i.subtitle) == null
                                    ? void 0
                                    : ie.call(i, { subtitle: e.subtitle })) ?? e.subtitle
                                ]
                              }
                            }
                          ),
                        (Ue = i.default) == null ? void 0 : Ue.call(i, ue.value)
                      ]),
                      Te &&
                        m('div', { key: 'append', class: 'v-list-item__append' }, [
                          i.append
                            ? m(
                                vt,
                                {
                                  key: 'append-defaults',
                                  disabled: !ce,
                                  defaults: {
                                    VAvatar: { density: e.density, image: e.appendAvatar },
                                    VIcon: { density: e.density, icon: e.appendIcon },
                                    VListItemAction: { end: !0 }
                                  }
                                },
                                {
                                  default: () => {
                                    var ie
                                    return [(ie = i.append) == null ? void 0 : ie.call(i, ue.value)]
                                  }
                                }
                              )
                            : m(Oe, null, [
                                e.appendIcon &&
                                  m(gt, { key: 'append-icon', density: e.density, icon: e.appendIcon }, null),
                                e.appendAvatar &&
                                  m(
                                    Pa,
                                    { key: 'append-avatar', density: e.density, image: e.appendAvatar },
                                    null
                                  )
                              ]),
                          m('div', { class: 'v-list-item__spacer' }, null)
                        ])
                    ]
                  }
                }
              ),
              [[Fn('ripple'), y.value && e.ripple]]
            )
          )
        }),
        {}
      )
    }
  }),
  z2 = ee(
    { color: String, inset: Boolean, sticky: Boolean, title: String, ...Me(), ...Ke() },
    'VListSubheader'
  ),
  nb = fe()({
    name: 'VListSubheader',
    props: z2(),
    setup(e, t) {
      let { slots: n } = t
      const { textColorClasses: i, textColorStyles: a } = dn(ve(e, 'color'))
      return (
        ge(() => {
          const s = !!(n.default || e.title)
          return m(
            e.tag,
            {
              class: [
                'v-list-subheader',
                { 'v-list-subheader--inset': e.inset, 'v-list-subheader--sticky': e.sticky },
                i.value,
                e.class
              ],
              style: [{ textColorStyles: a }, e.style]
            },
            {
              default: () => {
                var o
                return [
                  s &&
                    m('div', { class: 'v-list-subheader__text' }, [
                      ((o = n.default) == null ? void 0 : o.call(n)) ?? e.title
                    ])
                ]
              }
            }
          )
        }),
        {}
      )
    }
  })
const H2 = ee(
    {
      color: String,
      inset: Boolean,
      length: [Number, String],
      thickness: [Number, String],
      vertical: Boolean,
      ...Me(),
      ...ot()
    },
    'VDivider'
  ),
  ib = fe()({
    name: 'VDivider',
    props: H2(),
    setup(e, t) {
      let { attrs: n } = t
      const { themeClasses: i } = ut(e),
        { textColorClasses: a, textColorStyles: s } = dn(ve(e, 'color')),
        o = A(() => {
          const r = {}
          return (
            e.length && (r[e.vertical ? 'maxHeight' : 'maxWidth'] = Ve(e.length)),
            e.thickness && (r[e.vertical ? 'borderRightWidth' : 'borderTopWidth'] = Ve(e.thickness)),
            r
          )
        })
      return (
        ge(() =>
          m(
            'hr',
            {
              class: [
                { 'v-divider': !0, 'v-divider--inset': e.inset, 'v-divider--vertical': e.vertical },
                i.value,
                a.value,
                e.class
              ],
              style: [o.value, s.value, e.style],
              'aria-orientation':
                !n.role || n.role === 'separator' ? (e.vertical ? 'vertical' : 'horizontal') : void 0,
              role: `${n.role || 'separator'}`
            },
            null
          )
        ),
        {}
      )
    }
  }),
  W2 = ee({ items: Array }, 'VListChildren'),
  ab = fe()({
    name: 'VListChildren',
    props: W2(),
    setup(e, t) {
      let { slots: n } = t
      return (
        Xy(),
        () => {
          var i, a
          return (
            ((i = n.default) == null ? void 0 : i.call(n)) ??
            ((a = e.items) == null
              ? void 0
              : a.map((s) => {
                  var h, v
                  let { children: o, props: r, type: l, raw: c } = s
                  if (l === 'divider')
                    return ((h = n.divider) == null ? void 0 : h.call(n, { props: r })) ?? m(ib, r, null)
                  if (l === 'subheader')
                    return ((v = n.subheader) == null ? void 0 : v.call(n, { props: r })) ?? m(nb, r, null)
                  const u = {
                      subtitle: n.subtitle
                        ? (g) => {
                            var p
                            return (p = n.subtitle) == null ? void 0 : p.call(n, { ...g, item: c })
                          }
                        : void 0,
                      prepend: n.prepend
                        ? (g) => {
                            var p
                            return (p = n.prepend) == null ? void 0 : p.call(n, { ...g, item: c })
                          }
                        : void 0,
                      append: n.append
                        ? (g) => {
                            var p
                            return (p = n.append) == null ? void 0 : p.call(n, { ...g, item: c })
                          }
                        : void 0,
                      title: n.title
                        ? (g) => {
                            var p
                            return (p = n.title) == null ? void 0 : p.call(n, { ...g, item: c })
                          }
                        : void 0
                    },
                    [d, f] = Cd.filterProps(r)
                  return o
                    ? m(Cd, xe({ value: r == null ? void 0 : r.value }, d), {
                        activator: (g) => {
                          let { props: p } = g
                          return n.header ? n.header({ props: { ...r, ...p } }) : m(Qi, xe(r, p), u)
                        },
                        default: () => m(ab, { items: o }, n)
                      })
                    : n.item
                    ? n.item({ props: r })
                    : m(Qi, r, u)
                }))
          )
        }
      )
    }
  }),
  sb = ee(
    {
      items: { type: Array, default: () => [] },
      itemTitle: { type: [String, Array, Function], default: 'title' },
      itemValue: { type: [String, Array, Function], default: 'value' },
      itemChildren: { type: [Boolean, String, Array, Function], default: 'children' },
      itemProps: { type: [Boolean, String, Array, Function], default: 'props' },
      returnObject: Boolean,
      valueComparator: { type: Function, default: co }
    },
    'list-items'
  )
function is(e, t) {
  const n = Si(t, e.itemTitle, t),
    i = Si(t, e.itemValue, n),
    a = Si(t, e.itemChildren),
    s =
      e.itemProps === !0
        ? typeof t == 'object' && t != null && !Array.isArray(t)
          ? 'children' in t
            ? ds(t, ['children'])[1]
            : t
          : void 0
        : Si(t, e.itemProps),
    o = { title: n, value: i, ...s }
  return {
    title: String(o.title ?? ''),
    value: o.value,
    props: o,
    children: Array.isArray(a) ? ob(e, a) : void 0,
    raw: t
  }
}
function ob(e, t) {
  const n = []
  for (const i of t) n.push(is(e, i))
  return n
}
function lh(e) {
  const t = A(() => ob(e, e.items)),
    n = A(() => t.value.some((s) => s.value === null))
  function i(s) {
    return (
      n.value || (s = s.filter((o) => o !== null)),
      s.map((o) =>
        e.returnObject && typeof o == 'string'
          ? is(e, o)
          : t.value.find((r) => e.valueComparator(o, r.value)) || is(e, o)
      )
    )
  }
  function a(s) {
    return e.returnObject
      ? s.map((o) => {
          let { raw: r } = o
          return r
        })
      : s.map((o) => {
          let { value: r } = o
          return r
        })
  }
  return { items: t, transformIn: i, transformOut: a }
}
function j2(e) {
  return typeof e == 'string' || typeof e == 'number' || typeof e == 'boolean'
}
function U2(e, t) {
  const n = Si(t, e.itemType, 'item'),
    i = j2(t) ? t : Si(t, e.itemTitle),
    a = Si(t, e.itemValue, void 0),
    s = Si(t, e.itemChildren),
    o = e.itemProps === !0 ? ds(t, ['children'])[1] : Si(t, e.itemProps),
    r = { title: i, value: a, ...o }
  return {
    type: n,
    title: r.title,
    value: r.value,
    props: r,
    children: n === 'item' && s ? rb(e, s) : void 0,
    raw: t
  }
}
function rb(e, t) {
  const n = []
  for (const i of t) n.push(U2(e, i))
  return n
}
function Y2(e) {
  return { items: A(() => rb(e, e.items)) }
}
const G2 = ee(
    {
      baseColor: String,
      activeColor: String,
      activeClass: String,
      bgColor: String,
      disabled: Boolean,
      lines: { type: [Boolean, String], default: 'one' },
      nav: Boolean,
      ...D2({ selectStrategy: 'single-leaf', openStrategy: 'list' }),
      ...Bn(),
      ...Me(),
      ...Gt(),
      ...qn(),
      ...Yt(),
      itemType: { type: String, default: 'type' },
      ...sb(),
      ...kt(),
      ...Ke(),
      ...ot(),
      ...Qn({ variant: 'text' })
    },
    'VList'
  ),
  Yc = fe()({
    name: 'VList',
    props: G2(),
    emits: {
      'update:selected': (e) => !0,
      'update:opened': (e) => !0,
      'click:open': (e) => !0,
      'click:select': (e) => !0
    },
    setup(e, t) {
      let { slots: n } = t
      const { items: i } = Y2(e),
        { themeClasses: a } = ut(e),
        { backgroundColorClasses: s, backgroundColorStyles: o } = Rt(ve(e, 'bgColor')),
        { borderClasses: r } = Jn(e),
        { densityClasses: l } = gn(e),
        { dimensionStyles: c } = Zn(e),
        { elevationClasses: u } = nn(e),
        { roundedClasses: d } = Lt(e),
        { open: f, select: h } = F2(e),
        v = A(() => (e.lines ? `v-list--${e.lines}-line` : void 0)),
        g = ve(e, 'activeColor'),
        p = ve(e, 'baseColor'),
        y = ve(e, 'color')
      Xy(),
        zt({
          VListGroup: { activeColor: g, baseColor: p, color: y },
          VListItem: {
            activeClass: ve(e, 'activeClass'),
            activeColor: g,
            baseColor: p,
            color: y,
            density: ve(e, 'density'),
            disabled: ve(e, 'disabled'),
            lines: ve(e, 'lines'),
            nav: ve(e, 'nav'),
            variant: ve(e, 'variant')
          }
        })
      const b = Ce(!1),
        x = te()
      function w(_) {
        b.value = !0
      }
      function C(_) {
        b.value = !1
      }
      function P(_) {
        var T
        !b.value && !(_.relatedTarget && (T = x.value) != null && T.contains(_.relatedTarget)) && S()
      }
      function k(_) {
        if (x.value) {
          if (_.key === 'ArrowDown') S('next')
          else if (_.key === 'ArrowUp') S('prev')
          else if (_.key === 'Home') S('first')
          else if (_.key === 'End') S('last')
          else return
          _.preventDefault()
        }
      }
      function S(_) {
        if (x.value) return sc(x.value, _)
      }
      return (
        ge(() =>
          m(
            e.tag,
            {
              ref: x,
              class: [
                'v-list',
                { 'v-list--disabled': e.disabled, 'v-list--nav': e.nav },
                a.value,
                s.value,
                r.value,
                l.value,
                u.value,
                v.value,
                d.value,
                e.class
              ],
              style: [o.value, c.value, e.style],
              tabindex: e.disabled || b.value ? -1 : 0,
              role: 'listbox',
              'aria-activedescendant': void 0,
              onFocusin: w,
              onFocusout: C,
              onFocus: P,
              onKeydown: k
            },
            { default: () => [m(ab, { items: i.value }, n)] }
          )
        ),
        { open: f, select: h, focus: S }
      )
    }
  }),
  X2 = hi('v-list-img'),
  K2 = ee({ start: Boolean, end: Boolean, ...Me(), ...Ke() }, 'VListItemAction'),
  q2 = fe()({
    name: 'VListItemAction',
    props: K2(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ge(() =>
          m(
            e.tag,
            {
              class: [
                'v-list-item-action',
                { 'v-list-item-action--start': e.start, 'v-list-item-action--end': e.end },
                e.class
              ],
              style: e.style
            },
            n
          )
        ),
        {}
      )
    }
  }),
  Z2 = ee({ start: Boolean, end: Boolean, ...Me(), ...Ke() }, 'VListItemMedia'),
  J2 = fe()({
    name: 'VListItemMedia',
    props: Z2(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ge(() =>
          m(
            e.tag,
            {
              class: [
                'v-list-item-media',
                { 'v-list-item-media--start': e.start, 'v-list-item-media--end': e.end },
                e.class
              ],
              style: e.style
            },
            n
          )
        ),
        {}
      )
    }
  })
function Su(e, t) {
  return { x: e.x + t.x, y: e.y + t.y }
}
function Q2(e, t) {
  return { x: e.x - t.x, y: e.y - t.y }
}
function fg(e, t) {
  if (e.side === 'top' || e.side === 'bottom') {
    const { side: n, align: i } = e,
      a = i === 'left' ? 0 : i === 'center' ? t.width / 2 : i === 'right' ? t.width : i,
      s = n === 'top' ? 0 : n === 'bottom' ? t.height : n
    return Su({ x: a, y: s }, t)
  } else if (e.side === 'left' || e.side === 'right') {
    const { side: n, align: i } = e,
      a = n === 'left' ? 0 : n === 'right' ? t.width : n,
      s = i === 'top' ? 0 : i === 'center' ? t.height / 2 : i === 'bottom' ? t.height : i
    return Su({ x: a, y: s }, t)
  }
  return Su({ x: t.width / 2, y: t.height / 2 }, t)
}
const lb = { static: nM, connected: aM },
  eM = ee(
    {
      locationStrategy: {
        type: [String, Function],
        default: 'static',
        validator: (e) => typeof e == 'function' || e in lb
      },
      location: { type: String, default: 'bottom' },
      origin: { type: String, default: 'auto' },
      offset: [Number, String, Array]
    },
    'VOverlay-location-strategies'
  )
function tM(e, t) {
  const n = te({}),
    i = te()
  yt &&
    (Aa(
      () => !!(t.isActive.value && e.locationStrategy),
      (s) => {
        var o, r
        Pe(() => e.locationStrategy, s),
          Mn(() => {
            i.value = void 0
          }),
          typeof e.locationStrategy == 'function'
            ? (i.value = (o = e.locationStrategy(t, e, n)) == null ? void 0 : o.updateLocation)
            : (i.value = (r = lb[e.locationStrategy](t, e, n)) == null ? void 0 : r.updateLocation)
      }
    ),
    window.addEventListener('resize', a, { passive: !0 }),
    Mn(() => {
      window.removeEventListener('resize', a), (i.value = void 0)
    }))
  function a(s) {
    var o
    ;(o = i.value) == null || o.call(i, s)
  }
  return { contentStyles: n, updateLocation: i }
}
function nM() {}
function iM(e, t) {
  t ? e.style.removeProperty('left') : e.style.removeProperty('right')
  const n = $f(e)
  return (
    t ? (n.x += parseFloat(e.style.right || 0)) : (n.x -= parseFloat(e.style.left || 0)),
    (n.y -= parseFloat(e.style.top || 0)),
    n
  )
}
function aM(e, t, n) {
  Lk(e.activatorEl.value) &&
    Object.assign(n.value, { position: 'fixed', top: 0, [e.isRtl.value ? 'right' : 'left']: 0 })
  const { preferredAnchor: a, preferredOrigin: s } = Bf(() => {
      const v = ud(t.location, e.isRtl.value),
        g = t.origin === 'overlap' ? v : t.origin === 'auto' ? bu(v) : ud(t.origin, e.isRtl.value)
      return v.side === g.side && v.align === _u(g).align
        ? { preferredAnchor: Fv(v), preferredOrigin: Fv(g) }
        : { preferredAnchor: v, preferredOrigin: g }
    }),
    [o, r, l, c] = ['minWidth', 'minHeight', 'maxWidth', 'maxHeight'].map((v) =>
      A(() => {
        const g = parseFloat(t[v])
        return isNaN(g) ? 1 / 0 : g
      })
    ),
    u = A(() => {
      if (Array.isArray(t.offset)) return t.offset
      if (typeof t.offset == 'string') {
        const v = t.offset.split(' ').map(parseFloat)
        return v.length < 2 && v.push(0), v
      }
      return typeof t.offset == 'number' ? [t.offset, 0] : [0, 0]
    })
  let d = !1
  const f = new ResizeObserver(() => {
    d && h()
  })
  Pe(
    [e.activatorEl, e.contentEl],
    (v, g) => {
      let [p, y] = v,
        [b, x] = g
      b && f.unobserve(b), p && f.observe(p), x && f.unobserve(x), y && f.observe(y)
    },
    { immediate: !0 }
  ),
    Mn(() => {
      f.disconnect()
    })
  function h() {
    if (
      ((d = !1),
      requestAnimationFrame(() => {
        requestAnimationFrame(() => (d = !0))
      }),
      !e.activatorEl.value || !e.contentEl.value)
    )
      return
    const v = e.activatorEl.value.getBoundingClientRect(),
      g = iM(e.contentEl.value, e.isRtl.value),
      p = rc(e.contentEl.value),
      y = 12
    p.length ||
      (p.push(document.documentElement),
      (e.contentEl.value.style.top && e.contentEl.value.style.left) ||
        ((g.x -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-x') || 0)),
        (g.y -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-y') || 0))))
    const b = p.reduce(
      (B, O) => {
        const N = O.getBoundingClientRect(),
          Q = new Us({
            x: O === document.documentElement ? 0 : N.x,
            y: O === document.documentElement ? 0 : N.y,
            width: O.clientWidth,
            height: O.clientHeight
          })
        return B
          ? new Us({
              x: Math.max(B.left, Q.left),
              y: Math.max(B.top, Q.top),
              width: Math.min(B.right, Q.right) - Math.max(B.left, Q.left),
              height: Math.min(B.bottom, Q.bottom) - Math.max(B.top, Q.top)
            })
          : Q
      },
      void 0
    )
    ;(b.x += y), (b.y += y), (b.width -= y * 2), (b.height -= y * 2)
    let x = { anchor: a.value, origin: s.value }
    function w(B) {
      const O = new Us(g),
        N = fg(B.anchor, v),
        Q = fg(B.origin, O)
      let { x: ue, y: j } = Q2(N, Q)
      switch (B.anchor.side) {
        case 'top':
          j -= u.value[0]
          break
        case 'bottom':
          j += u.value[0]
          break
        case 'left':
          ue -= u.value[0]
          break
        case 'right':
          ue += u.value[0]
          break
      }
      switch (B.anchor.align) {
        case 'top':
          j -= u.value[1]
          break
        case 'bottom':
          j += u.value[1]
          break
        case 'left':
          ue -= u.value[1]
          break
        case 'right':
          ue += u.value[1]
          break
      }
      return (
        (O.x += ue),
        (O.y += j),
        (O.width = Math.min(O.width, l.value)),
        (O.height = Math.min(O.height, c.value)),
        { overflows: Bv(O, b), x: ue, y: j }
      )
    }
    let C = 0,
      P = 0
    const k = { x: 0, y: 0 },
      S = { x: !1, y: !1 }
    let _ = -1
    for (; !(_++ > 10); ) {
      const { x: B, y: O, overflows: N } = w(x)
      ;(C += B), (P += O), (g.x += B), (g.y += O)
      {
        const Q = Rv(x.anchor),
          ue = N.x.before || N.x.after,
          j = N.y.before || N.y.after
        let U = !1
        if (
          (['x', 'y'].forEach((X) => {
            if ((X === 'x' && ue && !S.x) || (X === 'y' && j && !S.y)) {
              const oe = { anchor: { ...x.anchor }, origin: { ...x.origin } },
                de = X === 'x' ? (Q === 'y' ? _u : bu) : Q === 'y' ? bu : _u
              ;(oe.anchor = de(oe.anchor)), (oe.origin = de(oe.origin))
              const { overflows: ce } = w(oe)
              ;((ce[X].before <= N[X].before && ce[X].after <= N[X].after) ||
                ce[X].before + ce[X].after < (N[X].before + N[X].after) / 2) &&
                ((x = oe), (U = S[X] = !0))
            }
          }),
          U)
        )
          continue
      }
      N.x.before && ((C += N.x.before), (g.x += N.x.before)),
        N.x.after && ((C -= N.x.after), (g.x -= N.x.after)),
        N.y.before && ((P += N.y.before), (g.y += N.y.before)),
        N.y.after && ((P -= N.y.after), (g.y -= N.y.after))
      {
        const Q = Bv(g, b)
        ;(k.x = b.width - Q.x.before - Q.x.after),
          (k.y = b.height - Q.y.before - Q.y.after),
          (C += Q.x.before),
          (g.x += Q.x.before),
          (P += Q.y.before),
          (g.y += Q.y.before)
      }
      break
    }
    const T = Rv(x.anchor)
    return (
      Object.assign(n.value, {
        '--v-overlay-anchor-origin': `${x.anchor.side} ${x.anchor.align}`,
        transformOrigin: `${x.origin.side} ${x.origin.align}`,
        top: Ve(ku(P)),
        left: e.isRtl.value ? void 0 : Ve(ku(C)),
        right: e.isRtl.value ? Ve(ku(-C)) : void 0,
        minWidth: Ve(T === 'y' ? Math.min(o.value, v.width) : o.value),
        maxWidth: Ve(hg(cn(k.x, o.value === 1 / 0 ? 0 : o.value, l.value))),
        maxHeight: Ve(hg(cn(k.y, r.value === 1 / 0 ? 0 : r.value, c.value)))
      }),
      { available: k, contentBox: g }
    )
  }
  return (
    Pe(
      () => [a.value, s.value, t.offset, t.minWidth, t.minHeight, t.maxWidth, t.maxHeight],
      () => h()
    ),
    mt(() => {
      const v = h()
      if (!v) return
      const { available: g, contentBox: p } = v
      p.height > g.y &&
        requestAnimationFrame(() => {
          h(),
            requestAnimationFrame(() => {
              h()
            })
        })
    }),
    { updateLocation: h }
  )
}
function ku(e) {
  return Math.round(e * devicePixelRatio) / devicePixelRatio
}
function hg(e) {
  return Math.ceil(e * devicePixelRatio) / devicePixelRatio
}
let Md = !0
const uc = []
function sM(e) {
  !Md || uc.length ? (uc.push(e), Ad()) : ((Md = !1), e(), Ad())
}
let vg = -1
function Ad() {
  cancelAnimationFrame(vg),
    (vg = requestAnimationFrame(() => {
      const e = uc.shift()
      e && e(), uc.length ? Ad() : (Md = !0)
    }))
}
const $l = { none: null, close: lM, block: cM, reposition: uM },
  oM = ee(
    {
      scrollStrategy: {
        type: [String, Function],
        default: 'block',
        validator: (e) => typeof e == 'function' || e in $l
      }
    },
    'VOverlay-scroll-strategies'
  )
function rM(e, t) {
  if (!yt) return
  let n
  Ut(async () => {
    n == null || n.stop(),
      t.isActive.value &&
        e.scrollStrategy &&
        ((n = Ac()),
        await mt(),
        n.active &&
          n.run(() => {
            var i
            typeof e.scrollStrategy == 'function'
              ? e.scrollStrategy(t, e, n)
              : (i = $l[e.scrollStrategy]) == null || i.call($l, t, e, n)
          }))
  }),
    Mn(() => {
      n == null || n.stop()
    })
}
function lM(e) {
  function t(n) {
    e.isActive.value = !1
  }
  cb(e.activatorEl.value ?? e.contentEl.value, t)
}
function cM(e, t) {
  var o
  const n = (o = e.root.value) == null ? void 0 : o.offsetParent,
    i = [
      ...new Set([
        ...rc(e.activatorEl.value, t.contained ? n : void 0),
        ...rc(e.contentEl.value, t.contained ? n : void 0)
      ])
    ].filter((r) => !r.classList.contains('v-overlay-scroll-blocked')),
    a = window.innerWidth - document.documentElement.offsetWidth,
    s = ((r) => jf(r) && r)(n || document.documentElement)
  s && e.root.value.classList.add('v-overlay--scroll-blocked'),
    i.forEach((r, l) => {
      r.style.setProperty('--v-body-scroll-x', Ve(-r.scrollLeft)),
        r.style.setProperty('--v-body-scroll-y', Ve(-r.scrollTop)),
        r !== document.documentElement && r.style.setProperty('--v-scrollbar-offset', Ve(a)),
        r.classList.add('v-overlay-scroll-blocked')
    }),
    Mn(() => {
      i.forEach((r, l) => {
        const c = parseFloat(r.style.getPropertyValue('--v-body-scroll-x')),
          u = parseFloat(r.style.getPropertyValue('--v-body-scroll-y'))
        r.style.removeProperty('--v-body-scroll-x'),
          r.style.removeProperty('--v-body-scroll-y'),
          r.style.removeProperty('--v-scrollbar-offset'),
          r.classList.remove('v-overlay-scroll-blocked'),
          (r.scrollLeft = -c),
          (r.scrollTop = -u)
      }),
        s && e.root.value.classList.remove('v-overlay--scroll-blocked')
    })
}
function uM(e, t, n) {
  let i = !1,
    a = -1,
    s = -1
  function o(r) {
    sM(() => {
      var u, d
      const l = performance.now()
      ;(d = (u = e.updateLocation).value) == null || d.call(u, r),
        (i = (performance.now() - l) / (1e3 / 60) > 2)
    })
  }
  ;(s = (typeof requestIdleCallback > 'u' ? (r) => r() : requestIdleCallback)(() => {
    n.run(() => {
      cb(e.activatorEl.value ?? e.contentEl.value, (r) => {
        i
          ? (cancelAnimationFrame(a),
            (a = requestAnimationFrame(() => {
              a = requestAnimationFrame(() => {
                o(r)
              })
            })))
          : o(r)
      })
    })
  })),
    Mn(() => {
      typeof cancelIdleCallback < 'u' && cancelIdleCallback(s), cancelAnimationFrame(a)
    })
}
function cb(e, t) {
  const n = [document, ...rc(e)]
  n.forEach((i) => {
    i.addEventListener('scroll', t, { passive: !0 })
  }),
    Mn(() => {
      n.forEach((i) => {
        i.removeEventListener('scroll', t)
      })
    })
}
const Pd = Symbol.for('vuetify:v-menu'),
  ub = ee({ closeDelay: [Number, String], openDelay: [Number, String] }, 'delay')
function db(e, t) {
  const n = {},
    i = (a) => () => {
      if (!yt) return Promise.resolve(!0)
      const s = a === 'openDelay'
      return (
        n.closeDelay && window.clearTimeout(n.closeDelay),
        delete n.closeDelay,
        n.openDelay && window.clearTimeout(n.openDelay),
        delete n.openDelay,
        new Promise((o) => {
          const r = parseInt(e[a] ?? 0, 10)
          n[a] = window.setTimeout(() => {
            t == null || t(s), o(s)
          }, r)
        })
      )
    }
  return { runCloseDelay: i('closeDelay'), runOpenDelay: i('openDelay') }
}
const dM = ee(
  {
    activator: [String, Object],
    activatorProps: { type: Object, default: () => ({}) },
    openOnClick: { type: Boolean, default: void 0 },
    openOnHover: Boolean,
    openOnFocus: { type: Boolean, default: void 0 },
    closeOnContentClick: Boolean,
    ...ub()
  },
  'VOverlay-activator'
)
function fM(e, t) {
  let { isActive: n, isTop: i } = t
  const a = te()
  let s = !1,
    o = !1,
    r = !0
  const l = A(() => e.openOnFocus || (e.openOnFocus == null && e.openOnHover)),
    c = A(() => e.openOnClick || (e.openOnClick == null && !e.openOnHover && !l.value)),
    { runOpenDelay: u, runCloseDelay: d } = db(e, (x) => {
      x === ((e.openOnHover && s) || (l.value && o)) &&
        !(e.openOnHover && n.value && !i.value) &&
        (n.value !== x && (r = !0), (n.value = x))
    }),
    f = {
      onClick: (x) => {
        x.stopPropagation(), (a.value = x.currentTarget || x.target), (n.value = !n.value)
      },
      onMouseenter: (x) => {
        var w
        ;((w = x.sourceCapabilities) != null && w.firesTouchEvents) ||
          ((s = !0), (a.value = x.currentTarget || x.target), u())
      },
      onMouseleave: (x) => {
        ;(s = !1), d()
      },
      onFocus: (x) => {
        qs(x.target, ':focus-visible') !== !1 &&
          ((o = !0), x.stopPropagation(), (a.value = x.currentTarget || x.target), u())
      },
      onBlur: (x) => {
        ;(o = !1), x.stopPropagation(), d()
      }
    },
    h = A(() => {
      const x = {}
      return (
        c.value && (x.onClick = f.onClick),
        e.openOnHover && ((x.onMouseenter = f.onMouseenter), (x.onMouseleave = f.onMouseleave)),
        l.value && ((x.onFocus = f.onFocus), (x.onBlur = f.onBlur)),
        x
      )
    }),
    v = A(() => {
      const x = {}
      if (
        (e.openOnHover &&
          ((x.onMouseenter = () => {
            ;(s = !0), u()
          }),
          (x.onMouseleave = () => {
            ;(s = !1), d()
          })),
        l.value &&
          ((x.onFocusin = () => {
            ;(o = !0), u()
          }),
          (x.onFocusout = () => {
            ;(o = !1), d()
          })),
        e.closeOnContentClick)
      ) {
        const w = st(Pd, null)
        x.onClick = () => {
          ;(n.value = !1), w == null || w.closeParents()
        }
      }
      return x
    }),
    g = A(() => {
      const x = {}
      return (
        e.openOnHover &&
          ((x.onMouseenter = () => {
            r && ((s = !0), (r = !1), u())
          }),
          (x.onMouseleave = () => {
            ;(s = !1), d()
          })),
        x
      )
    })
  Pe(i, (x) => {
    x &&
      ((e.openOnHover && !s && (!l.value || !o)) || (l.value && !o && (!e.openOnHover || !s))) &&
      (n.value = !1)
  })
  const p = te()
  Ut(() => {
    p.value &&
      mt(() => {
        a.value = ld(p.value)
      })
  })
  const y = Jt('useActivator')
  let b
  return (
    Pe(
      () => !!e.activator,
      (x) => {
        x && yt
          ? ((b = Ac()),
            b.run(() => {
              hM(e, y, { activatorEl: a, activatorEvents: h })
            }))
          : b && b.stop()
      },
      { flush: 'post', immediate: !0 }
    ),
    Mn(() => {
      b == null || b.stop()
    }),
    { activatorEl: a, activatorRef: p, activatorEvents: h, contentEvents: v, scrimEvents: g }
  )
}
function hM(e, t, n) {
  let { activatorEl: i, activatorEvents: a } = n
  Pe(
    () => e.activator,
    (l, c) => {
      if (c && l !== c) {
        const u = r(c)
        u && o(u)
      }
      l && mt(() => s())
    },
    { immediate: !0 }
  ),
    Pe(
      () => e.activatorProps,
      () => {
        s()
      }
    ),
    Mn(() => {
      o()
    })
  function s() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : r(),
      c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps
    l && ok(l, xe(a.value, c))
  }
  function o() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : r(),
      c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps
    l && rk(l, xe(a.value, c))
  }
  function r() {
    var u, d
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.activator,
      c
    if (l)
      if (l === 'parent') {
        let f =
          (d = (u = t == null ? void 0 : t.proxy) == null ? void 0 : u.$el) == null ? void 0 : d.parentNode
        for (; f != null && f.hasAttribute('data-no-activator'); ) f = f.parentNode
        c = f
      } else typeof l == 'string' ? (c = document.querySelector(l)) : '$el' in l ? (c = l.$el) : (c = l)
    return (i.value = (c == null ? void 0 : c.nodeType) === Node.ELEMENT_NODE ? c : null), i.value
  }
}
function fb() {
  if (!yt) return Ce(!1)
  const { ssr: e } = bs()
  if (e) {
    const t = Ce(!1)
    return (
      tn(() => {
        t.value = !0
      }),
      t
    )
  } else return Ce(!0)
}
const Gc = ee({ eager: Boolean }, 'lazy')
function ch(e, t) {
  const n = Ce(!1),
    i = A(() => n.value || e.eager || t.value)
  Pe(t, () => (n.value = !0))
  function a() {
    e.eager || (n.value = !1)
  }
  return { isBooted: n, hasContent: i, onAfterLeave: a }
}
function _o() {
  const t = Jt('useScopeId').vnode.scopeId
  return { scopeId: t ? { [t]: '' } : void 0 }
}
const gg = Symbol.for('vuetify:stack'),
  Oo = yn([])
function vM(e, t, n) {
  const i = Jt('useStack'),
    a = !n,
    s = st(gg, void 0),
    o = yn({ activeChildren: new Set() })
  Vt(gg, o)
  const r = Ce(+t.value)
  Aa(e, () => {
    var d
    const u = (d = Oo.at(-1)) == null ? void 0 : d[1]
    ;(r.value = u ? u + 10 : +t.value),
      a && Oo.push([i.uid, r.value]),
      s == null || s.activeChildren.add(i.uid),
      Mn(() => {
        if (a) {
          const f = Qe(Oo).findIndex((h) => h[0] === i.uid)
          Oo.splice(f, 1)
        }
        s == null || s.activeChildren.delete(i.uid)
      })
  })
  const l = Ce(!0)
  a &&
    Ut(() => {
      var d
      const u = ((d = Oo.at(-1)) == null ? void 0 : d[0]) === i.uid
      setTimeout(() => (l.value = u))
    })
  const c = A(() => !o.activeChildren.size)
  return { globalTop: $r(l), localTop: c, stackStyles: A(() => ({ zIndex: r.value })) }
}
function gM(e) {
  return {
    teleportTarget: A(() => {
      const n = e.value
      if (n === !0 || !yt) return
      const i = n === !1 ? document.body : typeof n == 'string' ? document.querySelector(n) : n
      if (i == null) return
      let a = i.querySelector(':scope > .v-overlay-container')
      return (
        a || ((a = document.createElement('div')), (a.className = 'v-overlay-container'), i.appendChild(a)), a
      )
    })
  }
}
function mM() {
  return !0
}
function hb(e, t, n) {
  if (!e || vb(e, n) === !1) return !1
  const i = ly(t)
  if (typeof ShadowRoot < 'u' && i instanceof ShadowRoot && i.host === e.target) return !1
  const a = ((typeof n.value == 'object' && n.value.include) || (() => []))()
  return a.push(t), !a.some((s) => (s == null ? void 0 : s.contains(e.target)))
}
function vb(e, t) {
  return ((typeof t.value == 'object' && t.value.closeConditional) || mM)(e)
}
function pM(e, t, n) {
  const i = typeof n.value == 'function' ? n.value : n.value.handler
  t._clickOutside.lastMousedownWasOutside &&
    hb(e, t, n) &&
    setTimeout(() => {
      vb(e, n) && i && i(e)
    }, 0)
}
function mg(e, t) {
  const n = ly(e)
  t(document), typeof ShadowRoot < 'u' && n instanceof ShadowRoot && t(n)
}
const gb = {
  mounted(e, t) {
    const n = (a) => pM(a, e, t),
      i = (a) => {
        e._clickOutside.lastMousedownWasOutside = hb(a, e, t)
      }
    mg(e, (a) => {
      a.addEventListener('click', n, !0), a.addEventListener('mousedown', i, !0)
    }),
      e._clickOutside || (e._clickOutside = { lastMousedownWasOutside: !1 }),
      (e._clickOutside[t.instance.$.uid] = { onClick: n, onMousedown: i })
  },
  unmounted(e, t) {
    e._clickOutside &&
      (mg(e, (n) => {
        var s
        if (!n || !((s = e._clickOutside) != null && s[t.instance.$.uid])) return
        const { onClick: i, onMousedown: a } = e._clickOutside[t.instance.$.uid]
        n.removeEventListener('click', i, !0), n.removeEventListener('mousedown', a, !0)
      }),
      delete e._clickOutside[t.instance.$.uid])
  }
}
function yM(e) {
  const { modelValue: t, color: n, ...i } = e
  return m(
    Pi,
    { name: 'fade-transition', appear: !0 },
    {
      default: () => [
        e.modelValue &&
          m(
            'div',
            xe(
              {
                class: ['v-overlay__scrim', e.color.backgroundColorClasses.value],
                style: e.color.backgroundColorStyles.value
              },
              i
            ),
            null
          )
      ]
    }
  )
}
const Yr = ee(
    {
      absolute: Boolean,
      attach: [Boolean, String, Object],
      closeOnBack: { type: Boolean, default: !0 },
      contained: Boolean,
      contentClass: null,
      contentProps: null,
      disabled: Boolean,
      noClickAnimation: Boolean,
      modelValue: Boolean,
      persistent: Boolean,
      scrim: { type: [Boolean, String], default: !0 },
      zIndex: { type: [Number, String], default: 2e3 },
      ...dM(),
      ...Me(),
      ...qn(),
      ...Gc(),
      ...eM(),
      ...oM(),
      ...ot(),
      ...sa()
    },
    'VOverlay'
  ),
  ea = fe()({
    name: 'VOverlay',
    directives: { ClickOutside: gb },
    inheritAttrs: !1,
    props: { _disableGlobalStack: Boolean, ...Yr() },
    emits: { 'click:outside': (e) => !0, 'update:modelValue': (e) => !0, afterLeave: () => !0 },
    setup(e, t) {
      let { slots: n, attrs: i, emit: a } = t
      const s = Ge(e, 'modelValue'),
        o = A({
          get: () => s.value,
          set: (oe) => {
            ;(oe && e.disabled) || (s.value = oe)
          }
        }),
        { teleportTarget: r } = gM(A(() => e.attach || e.contained)),
        { themeClasses: l } = ut(e),
        { rtlClasses: c, isRtl: u } = Qt(),
        { hasContent: d, onAfterLeave: f } = ch(e, o),
        h = Rt(A(() => (typeof e.scrim == 'string' ? e.scrim : null))),
        { globalTop: v, localTop: g, stackStyles: p } = vM(o, ve(e, 'zIndex'), e._disableGlobalStack),
        {
          activatorEl: y,
          activatorRef: b,
          activatorEvents: x,
          contentEvents: w,
          scrimEvents: C
        } = fM(e, { isActive: o, isTop: g }),
        { dimensionStyles: P } = Zn(e),
        k = fb(),
        { scopeId: S } = _o()
      Pe(
        () => e.disabled,
        (oe) => {
          oe && (o.value = !1)
        }
      )
      const _ = te(),
        T = te(),
        { contentStyles: B, updateLocation: O } = tM(e, {
          isRtl: u,
          contentEl: T,
          activatorEl: y,
          isActive: o
        })
      rM(e, { root: _, contentEl: T, activatorEl: y, isActive: o, updateLocation: O })
      function N(oe) {
        a('click:outside', oe), e.persistent ? X() : (o.value = !1)
      }
      function Q() {
        return o.value && v.value
      }
      yt &&
        Pe(
          o,
          (oe) => {
            oe ? window.addEventListener('keydown', ue) : window.removeEventListener('keydown', ue)
          },
          { immediate: !0 }
        )
      function ue(oe) {
        var de, ce
        oe.key === 'Escape' &&
          v.value &&
          (e.persistent
            ? X()
            : ((o.value = !1),
              (de = T.value) != null &&
                de.contains(document.activeElement) &&
                ((ce = y.value) == null || ce.focus())))
      }
      const j = Ty()
      Aa(
        () => e.closeOnBack,
        () => {
          s2(j, (oe) => {
            v.value && o.value ? (oe(!1), e.persistent ? X() : (o.value = !1)) : oe()
          })
        }
      )
      const U = te()
      Pe(
        () => o.value && (e.absolute || e.contained) && r.value == null,
        (oe) => {
          if (oe) {
            const de = Wf(_.value)
            de && de !== document.scrollingElement && (U.value = de.scrollTop)
          }
        }
      )
      function X() {
        e.noClickAnimation ||
          (T.value &&
            ns(
              T.value,
              [{ transformOrigin: 'center' }, { transform: 'scale(1.03)' }, { transformOrigin: 'center' }],
              { duration: 150, easing: xr }
            ))
      }
      return (
        ge(() => {
          var oe
          return m(Oe, null, [
            (oe = n.activator) == null
              ? void 0
              : oe.call(n, { isActive: o.value, props: xe({ ref: b }, x.value, e.activatorProps) }),
            k.value &&
              d.value &&
              m(
                eS,
                { disabled: !r.value, to: r.value },
                {
                  default: () => [
                    m(
                      'div',
                      xe(
                        {
                          class: [
                            'v-overlay',
                            {
                              'v-overlay--absolute': e.absolute || e.contained,
                              'v-overlay--active': o.value,
                              'v-overlay--contained': e.contained
                            },
                            l.value,
                            c.value,
                            e.class
                          ],
                          style: [p.value, { top: Ve(U.value) }, e.style],
                          ref: _
                        },
                        S,
                        i
                      ),
                      [
                        m(yM, xe({ color: h, modelValue: o.value && !!e.scrim }, C.value), null),
                        m(
                          ii,
                          {
                            appear: !0,
                            persisted: !0,
                            transition: e.transition,
                            target: y.value,
                            onAfterLeave: () => {
                              f(), a('afterLeave')
                            }
                          },
                          {
                            default: () => {
                              var de
                              return [
                                Et(
                                  m(
                                    'div',
                                    xe(
                                      {
                                        ref: T,
                                        class: ['v-overlay__content', e.contentClass],
                                        style: [P.value, B.value]
                                      },
                                      w.value,
                                      e.contentProps
                                    ),
                                    [(de = n.default) == null ? void 0 : de.call(n, { isActive: o })]
                                  ),
                                  [
                                    [Li, o.value],
                                    [
                                      Fn('click-outside'),
                                      { handler: N, closeConditional: Q, include: () => [y.value] }
                                    ]
                                  ]
                                )
                              ]
                            }
                          }
                        )
                      ]
                    )
                  ]
                }
              )
          ])
        }),
        { activatorEl: y, animateClick: X, contentEl: T, globalTop: v, localTop: g, updateLocation: O }
      )
    }
  }),
  Cu = Symbol('Forwarded refs')
function Mu(e, t) {
  let n = e
  for (; n; ) {
    const i = Reflect.getOwnPropertyDescriptor(n, t)
    if (i) return i
    n = Object.getPrototypeOf(n)
  }
}
function vi(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i]
  return (
    (e[Cu] = n),
    new Proxy(e, {
      get(a, s) {
        if (Reflect.has(a, s)) return Reflect.get(a, s)
        if (!(typeof s == 'symbol' || s.startsWith('__'))) {
          for (const o of n)
            if (o.value && Reflect.has(o.value, s)) {
              const r = Reflect.get(o.value, s)
              return typeof r == 'function' ? r.bind(o.value) : r
            }
        }
      },
      has(a, s) {
        if (Reflect.has(a, s)) return !0
        if (typeof s == 'symbol' || s.startsWith('__')) return !1
        for (const o of n) if (o.value && Reflect.has(o.value, s)) return !0
        return !1
      },
      set(a, s, o) {
        if (Reflect.has(a, s)) return Reflect.set(a, s, o)
        if (typeof s == 'symbol' || s.startsWith('__')) return !1
        for (const r of n) if (r.value && Reflect.has(r.value, s)) return Reflect.set(r.value, s, o)
        return !1
      },
      getOwnPropertyDescriptor(a, s) {
        var r
        const o = Reflect.getOwnPropertyDescriptor(a, s)
        if (o) return o
        if (!(typeof s == 'symbol' || s.startsWith('__'))) {
          for (const l of n) {
            if (!l.value) continue
            const c =
              Mu(l.value, s) ??
              ('_' in l.value ? Mu((r = l.value._) == null ? void 0 : r.setupState, s) : void 0)
            if (c) return c
          }
          for (const l of n) {
            const c = l.value && l.value[Cu]
            if (!c) continue
            const u = c.slice()
            for (; u.length; ) {
              const d = u.shift(),
                f = Mu(d.value, s)
              if (f) return f
              const h = d.value && d.value[Cu]
              h && u.push(...h)
            }
          }
        }
      }
    })
  )
}
const bM = ee(
    {
      id: String,
      ...Gn(
        Yr({
          closeDelay: 250,
          closeOnContentClick: !0,
          locationStrategy: 'connected',
          openDelay: 300,
          scrim: !1,
          scrollStrategy: 'reposition',
          transition: { component: $c }
        }),
        ['absolute']
      )
    },
    'VMenu'
  ),
  Xc = fe()({
    name: 'VMenu',
    props: bM(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = Ge(e, 'modelValue'),
        { scopeId: a } = _o(),
        s = vn(),
        o = A(() => e.id || `v-menu-${s}`),
        r = te(),
        l = st(Pd, null),
        c = Ce(0)
      Vt(Pd, {
        register() {
          ++c.value
        },
        unregister() {
          --c.value
        },
        closeParents() {
          setTimeout(() => {
            c.value || ((i.value = !1), l == null || l.closeParents())
          }, 40)
        }
      })
      async function u(g) {
        var b, x, w
        const p = g.relatedTarget,
          y = g.target
        await mt(),
          i.value &&
            p !== y &&
            (b = r.value) != null &&
            b.contentEl &&
            (x = r.value) != null &&
            x.globalTop &&
            ![document, r.value.contentEl].includes(y) &&
            !r.value.contentEl.contains(y) &&
            ((w = _r(r.value.contentEl)[0]) == null || w.focus())
      }
      Pe(i, (g) => {
        g
          ? (l == null || l.register(), document.addEventListener('focusin', u, { once: !0 }))
          : (l == null || l.unregister(), document.removeEventListener('focusin', u))
      })
      function d() {
        l == null || l.closeParents()
      }
      function f(g) {
        var p, y, b
        e.disabled ||
          (g.key === 'Tab' &&
            (K0(
              _r((p = r.value) == null ? void 0 : p.contentEl, !1),
              g.shiftKey ? 'prev' : 'next',
              (w) => w.tabIndex >= 0
            ) ||
              ((i.value = !1), (b = (y = r.value) == null ? void 0 : y.activatorEl) == null || b.focus())))
      }
      function h(g) {
        var y
        if (e.disabled) return
        const p = (y = r.value) == null ? void 0 : y.contentEl
        p && i.value
          ? g.key === 'ArrowDown'
            ? (g.preventDefault(), sc(p, 'next'))
            : g.key === 'ArrowUp' && (g.preventDefault(), sc(p, 'prev'))
          : ['ArrowDown', 'ArrowUp'].includes(g.key) &&
            ((i.value = !0), g.preventDefault(), setTimeout(() => setTimeout(() => h(g))))
      }
      const v = A(() =>
        xe(
          { 'aria-haspopup': 'menu', 'aria-expanded': String(i.value), 'aria-owns': o.value, onKeydown: h },
          e.activatorProps
        )
      )
      return (
        ge(() => {
          const [g] = ea.filterProps(e)
          return m(
            ea,
            xe(
              { ref: r, class: ['v-menu', e.class], style: e.style },
              g,
              {
                modelValue: i.value,
                'onUpdate:modelValue': (p) => (i.value = p),
                absolute: !0,
                activatorProps: v.value,
                'onClick:outside': d,
                onKeydown: f
              },
              a
            ),
            {
              activator: n.activator,
              default: function () {
                for (var p = arguments.length, y = new Array(p), b = 0; b < p; b++) y[b] = arguments[b]
                return m(
                  vt,
                  { root: 'VMenu' },
                  {
                    default: () => {
                      var x
                      return [(x = n.default) == null ? void 0 : x.call(n, ...y)]
                    }
                  }
                )
              }
            }
          )
        }),
        vi({ id: o, ΨopenChildren: c }, r)
      )
    }
  })
const _M = ee(
    {
      active: Boolean,
      max: [Number, String],
      value: { type: [Number, String], default: 0 },
      ...Me(),
      ...sa({ transition: { component: qf } })
    },
    'VCounter'
  ),
  Kc = fe()({
    name: 'VCounter',
    functional: !0,
    props: _M(),
    setup(e, t) {
      let { slots: n } = t
      const i = A(() => (e.max ? `${e.value} / ${e.max}` : String(e.value)))
      return (
        ge(() =>
          m(
            ii,
            { transition: e.transition },
            {
              default: () => [
                Et(
                  m('div', { class: ['v-counter', e.class], style: e.style }, [
                    n.default ? n.default({ counter: i.value, max: e.max, value: e.value }) : i.value
                  ]),
                  [[Li, e.active]]
                )
              ]
            }
          )
        ),
        {}
      )
    }
  })
const xM = ee({ floating: Boolean, ...Me() }, 'VFieldLabel'),
  Ho = fe()({
    name: 'VFieldLabel',
    props: xM(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ge(() =>
          m(
            bo,
            {
              class: ['v-field-label', { 'v-field-label--floating': e.floating }, e.class],
              style: e.style,
              'aria-hidden': e.floating || void 0
            },
            n
          )
        ),
        {}
      )
    }
  }),
  wM = ['underlined', 'outlined', 'filled', 'solo', 'solo-inverted', 'solo-filled', 'plain'],
  qc = ee(
    {
      appendInnerIcon: Ye,
      bgColor: String,
      clearable: Boolean,
      clearIcon: { type: Ye, default: '$clear' },
      active: Boolean,
      centerAffix: { type: Boolean, default: void 0 },
      color: String,
      baseColor: String,
      dirty: Boolean,
      disabled: { type: Boolean, default: null },
      error: Boolean,
      flat: Boolean,
      label: String,
      persistentClear: Boolean,
      prependInnerIcon: Ye,
      reverse: Boolean,
      singleLine: Boolean,
      variant: { type: String, default: 'filled', validator: (e) => wM.includes(e) },
      'onClick:clear': Mi(),
      'onClick:appendInner': Mi(),
      'onClick:prependInner': Mi(),
      ...Me(),
      ...ih(),
      ...kt(),
      ...ot()
    },
    'VField'
  ),
  Gr = fe()({
    name: 'VField',
    inheritAttrs: !1,
    props: { id: String, ...jc(), ...qc() },
    emits: { 'update:focused': (e) => !0, 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, emit: i, slots: a } = t
      const { themeClasses: s } = ut(e),
        { loaderClasses: o } = Hc(e),
        { focusClasses: r, isFocused: l, focus: c, blur: u } = Fa(e),
        { InputIcon: d } = Hy(e),
        { roundedClasses: f } = Lt(e),
        { rtlClasses: h } = Qt(),
        v = A(() => e.dirty || e.active),
        g = A(() => !e.singleLine && !!(e.label || a.label)),
        p = vn(),
        y = A(() => e.id || `input-${p}`),
        b = A(() => `${y.value}-messages`),
        x = te(),
        w = te(),
        C = te(),
        P = A(() => ['plain', 'underlined'].includes(e.variant)),
        { backgroundColorClasses: k, backgroundColorStyles: S } = Rt(ve(e, 'bgColor')),
        { textColorClasses: _, textColorStyles: T } = dn(
          A(() => (e.error || e.disabled ? void 0 : v.value && l.value ? e.color : e.baseColor))
        )
      Pe(
        v,
        (N) => {
          if (g.value) {
            const Q = x.value.$el,
              ue = w.value.$el
            requestAnimationFrame(() => {
              const j = $f(Q),
                U = ue.getBoundingClientRect(),
                X = U.x - j.x,
                oe = U.y - j.y - (j.height / 2 - U.height / 2),
                de = U.width / 0.75,
                ce = Math.abs(de - j.width) > 1 ? { maxWidth: Ve(de) } : void 0,
                Te = getComputedStyle(Q),
                $e = getComputedStyle(ue),
                He = parseFloat(Te.transitionDuration) * 1e3 || 150,
                Ue = parseFloat($e.getPropertyValue('--v-field-label-scale')),
                ie = $e.getPropertyValue('color')
              ;(Q.style.visibility = 'visible'),
                (ue.style.visibility = 'hidden'),
                ns(
                  Q,
                  { transform: `translate(${X}px, ${oe}px) scale(${Ue})`, color: ie, ...ce },
                  { duration: He, easing: xr, direction: N ? 'normal' : 'reverse' }
                ).finished.then(() => {
                  Q.style.removeProperty('visibility'), ue.style.removeProperty('visibility')
                })
            })
          }
        },
        { flush: 'post' }
      )
      const B = A(() => ({ isActive: v, isFocused: l, controlRef: C, blur: u, focus: c }))
      function O(N) {
        N.target !== document.activeElement && N.preventDefault()
      }
      return (
        ge(() => {
          var X, oe, de
          const N = e.variant === 'outlined',
            Q = a['prepend-inner'] || e.prependInnerIcon,
            ue = !!(e.clearable || a.clear),
            j = !!(a['append-inner'] || e.appendInnerIcon || ue),
            U = a.label ? a.label({ ...B.value, label: e.label, props: { for: y.value } }) : e.label
          return m(
            'div',
            xe(
              {
                class: [
                  'v-field',
                  {
                    'v-field--active': v.value,
                    'v-field--appended': j,
                    'v-field--center-affix': e.centerAffix ?? !P.value,
                    'v-field--disabled': e.disabled,
                    'v-field--dirty': e.dirty,
                    'v-field--error': e.error,
                    'v-field--flat': e.flat,
                    'v-field--has-background': !!e.bgColor,
                    'v-field--persistent-clear': e.persistentClear,
                    'v-field--prepended': Q,
                    'v-field--reverse': e.reverse,
                    'v-field--single-line': e.singleLine,
                    'v-field--no-label': !U,
                    [`v-field--variant-${e.variant}`]: !0
                  },
                  s.value,
                  k.value,
                  r.value,
                  o.value,
                  f.value,
                  h.value,
                  e.class
                ],
                style: [S.value, e.style],
                onClick: O
              },
              n
            ),
            [
              m('div', { class: 'v-field__overlay' }, null),
              m(
                ah,
                {
                  name: 'v-field',
                  active: !!e.loading,
                  color: e.error ? 'error' : typeof e.loading == 'string' ? e.loading : e.color
                },
                { default: a.loader }
              ),
              Q &&
                m('div', { key: 'prepend', class: 'v-field__prepend-inner' }, [
                  e.prependInnerIcon && m(d, { key: 'prepend-icon', name: 'prependInner' }, null),
                  (X = a['prepend-inner']) == null ? void 0 : X.call(a, B.value)
                ]),
              m('div', { class: 'v-field__field', 'data-no-activator': '' }, [
                ['filled', 'solo', 'solo-inverted', 'solo-filled'].includes(e.variant) &&
                  g.value &&
                  m(
                    Ho,
                    {
                      key: 'floating-label',
                      ref: w,
                      class: [_.value],
                      floating: !0,
                      for: y.value,
                      style: T.value
                    },
                    { default: () => [U] }
                  ),
                m(Ho, { ref: x, for: y.value }, { default: () => [U] }),
                (oe = a.default) == null
                  ? void 0
                  : oe.call(a, {
                      ...B.value,
                      props: { id: y.value, class: 'v-field__input', 'aria-describedby': b.value },
                      focus: c,
                      blur: u
                    })
              ]),
              ue &&
                m(
                  Zf,
                  { key: 'clear' },
                  {
                    default: () => [
                      Et(
                        m(
                          'div',
                          {
                            class: 'v-field__clearable',
                            onMousedown: (ce) => {
                              ce.preventDefault(), ce.stopPropagation()
                            }
                          },
                          [a.clear ? a.clear() : m(d, { name: 'clear' }, null)]
                        ),
                        [[Li, e.dirty]]
                      )
                    ]
                  }
                ),
              j &&
                m('div', { key: 'append', class: 'v-field__append-inner' }, [
                  (de = a['append-inner']) == null ? void 0 : de.call(a, B.value),
                  e.appendInnerIcon && m(d, { key: 'append-icon', name: 'appendInner' }, null)
                ]),
              m('div', { class: ['v-field__outline', _.value], style: T.value }, [
                N &&
                  m(Oe, null, [
                    m('div', { class: 'v-field__outline__start' }, null),
                    g.value &&
                      m('div', { class: 'v-field__outline__notch' }, [
                        m(Ho, { ref: w, floating: !0, for: y.value }, { default: () => [U] })
                      ]),
                    m('div', { class: 'v-field__outline__end' }, null)
                  ]),
                P.value && g.value && m(Ho, { ref: w, floating: !0, for: y.value }, { default: () => [U] })
              ])
            ]
          )
        }),
        { controlRef: C }
      )
    }
  })
function uh(e) {
  const t = Object.keys(Gr.props).filter((n) => !Rf(n) && n !== 'class' && n !== 'style')
  return ds(e, t)
}
const SM = ['color', 'file', 'time', 'date', 'datetime-local', 'week', 'month'],
  Zc = ee(
    {
      autofocus: Boolean,
      counter: [Boolean, Number, String],
      counterValue: Function,
      prefix: String,
      placeholder: String,
      persistentPlaceholder: Boolean,
      persistentCounter: Boolean,
      suffix: String,
      role: String,
      type: { type: String, default: 'text' },
      modelModifiers: Object,
      ...ra(),
      ...qc()
    },
    'VTextField'
  ),
  vs = fe()({
    name: 'VTextField',
    directives: { Intersect: Hr },
    inheritAttrs: !1,
    props: Zc(),
    emits: {
      'click:control': (e) => !0,
      'mousedown:control': (e) => !0,
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0
    },
    setup(e, t) {
      let { attrs: n, emit: i, slots: a } = t
      const s = Ge(e, 'modelValue'),
        { isFocused: o, focus: r, blur: l } = Fa(e),
        c = A(() =>
          typeof e.counterValue == 'function' ? e.counterValue(s.value) : (s.value ?? '').toString().length
        ),
        u = A(() => {
          if (n.maxlength) return n.maxlength
          if (!(!e.counter || (typeof e.counter != 'number' && typeof e.counter != 'string')))
            return e.counter
        }),
        d = A(() => ['plain', 'underlined'].includes(e.variant))
      function f(P, k) {
        var S, _
        !e.autofocus || !P || (_ = (S = k[0].target) == null ? void 0 : S.focus) == null || _.call(S)
      }
      const h = te(),
        v = te(),
        g = te(),
        p = A(() => SM.includes(e.type) || e.persistentPlaceholder || o.value || e.active)
      function y() {
        var P
        g.value !== document.activeElement && ((P = g.value) == null || P.focus()), o.value || r()
      }
      function b(P) {
        i('mousedown:control', P), P.target !== g.value && (y(), P.preventDefault())
      }
      function x(P) {
        y(), i('click:control', P)
      }
      function w(P) {
        P.stopPropagation(),
          y(),
          mt(() => {
            ;(s.value = null), Nf(e['onClick:clear'], P)
          })
      }
      function C(P) {
        var S
        const k = P.target
        if (
          ((s.value = k.value),
          (S = e.modelModifiers) != null &&
            S.trim &&
            ['text', 'search', 'password', 'tel', 'url'].includes(e.type))
        ) {
          const _ = [k.selectionStart, k.selectionEnd]
          mt(() => {
            ;(k.selectionStart = _[0]), (k.selectionEnd = _[1])
          })
        }
      }
      return (
        ge(() => {
          const P = !!(a.counter || e.counter || e.counterValue),
            k = !!(P || a.details),
            [S, _] = ys(n),
            [{ modelValue: T, ...B }] = en.filterProps(e),
            [O] = uh(e)
          return m(
            en,
            xe(
              {
                ref: h,
                modelValue: s.value,
                'onUpdate:modelValue': (N) => (s.value = N),
                class: [
                  'v-text-field',
                  {
                    'v-text-field--prefixed': e.prefix,
                    'v-text-field--suffixed': e.suffix,
                    'v-text-field--plain-underlined': ['plain', 'underlined'].includes(e.variant)
                  },
                  e.class
                ],
                style: e.style
              },
              S,
              B,
              { centerAffix: !d.value, focused: o.value }
            ),
            {
              ...a,
              default: (N) => {
                let { id: Q, isDisabled: ue, isDirty: j, isReadonly: U, isValid: X } = N
                return m(
                  Gr,
                  xe(
                    {
                      ref: v,
                      onMousedown: b,
                      onClick: x,
                      'onClick:clear': w,
                      'onClick:prependInner': e['onClick:prependInner'],
                      'onClick:appendInner': e['onClick:appendInner'],
                      role: e.role
                    },
                    O,
                    {
                      id: Q.value,
                      active: p.value || j.value,
                      dirty: j.value || e.dirty,
                      disabled: ue.value,
                      focused: o.value,
                      error: X.value === !1
                    }
                  ),
                  {
                    ...a,
                    default: (oe) => {
                      let {
                        props: { class: de, ...ce }
                      } = oe
                      const Te = Et(
                        m(
                          'input',
                          xe(
                            {
                              ref: g,
                              value: s.value,
                              onInput: C,
                              autofocus: e.autofocus,
                              readonly: U.value,
                              disabled: ue.value,
                              name: e.name,
                              placeholder: e.placeholder,
                              size: 1,
                              type: e.type,
                              onFocus: y,
                              onBlur: l
                            },
                            ce,
                            _
                          ),
                          null
                        ),
                        [[Fn('intersect'), { handler: f }, null, { once: !0 }]]
                      )
                      return m(Oe, null, [
                        e.prefix &&
                          m('span', { class: 'v-text-field__prefix' }, [
                            m('span', { class: 'v-text-field__prefix__text' }, [e.prefix])
                          ]),
                        a.default
                          ? m('div', { class: de, 'data-no-activator': '' }, [a.default(), Te])
                          : Zi(Te, { class: de }),
                        e.suffix &&
                          m('span', { class: 'v-text-field__suffix' }, [
                            m('span', { class: 'v-text-field__suffix__text' }, [e.suffix])
                          ])
                      ])
                    }
                  }
                )
              },
              details: k
                ? (N) => {
                    var Q
                    return m(Oe, null, [
                      (Q = a.details) == null ? void 0 : Q.call(a, N),
                      P &&
                        m(Oe, null, [
                          m('span', null, null),
                          m(
                            Kc,
                            { active: e.persistentCounter || o.value, value: c.value, max: u.value },
                            a.counter
                          )
                        ])
                    ])
                  }
                : void 0
            }
          )
        }),
        vi({}, h, v, g)
      )
    }
  })
const kM = ee({ renderless: Boolean, ...Me() }, 'VVirtualScrollItem'),
  CM = fe()({
    name: 'VVirtualScrollItem',
    inheritAttrs: !1,
    props: kM(),
    emits: { 'update:height': (e) => !0 },
    setup(e, t) {
      let { attrs: n, emit: i, slots: a } = t
      const { resizeRef: s, contentRect: o } = Ti(void 0, 'border')
      Pe(
        () => {
          var r
          return (r = o.value) == null ? void 0 : r.height
        },
        (r) => {
          r != null && i('update:height', r)
        }
      ),
        ge(() => {
          var r, l
          return e.renderless
            ? m(Oe, null, [(r = a.default) == null ? void 0 : r.call(a, { itemRef: s })])
            : m('div', xe({ ref: s, class: ['v-virtual-scroll__item', e.class], style: e.style }, n), [
                (l = a.default) == null ? void 0 : l.call(a)
              ])
        })
    }
  }),
  pg = -1,
  yg = 1,
  MM = ee({ itemHeight: { type: [Number, String], default: 48 } }, 'virtual')
function AM(e, t, n) {
  const i = Ce(0),
    a = Ce(e.itemHeight),
    s = A({
      get: () => parseInt(a.value ?? 0, 10),
      set(k) {
        a.value = k
      }
    }),
    o = te(),
    { resizeRef: r, contentRect: l } = Ti()
  Ut(() => {
    r.value = o.value
  })
  const c = bs(),
    u = new Map()
  let d = Array.from({ length: t.value.length })
  const f = A(() => {
    const k =
      (!l.value || o.value === document.documentElement ? c.height.value : l.value.height) -
      ((n == null ? void 0 : n.value) ?? 0)
    return Math.ceil((k / s.value) * 1.7 + 1)
  })
  function h(k, S) {
    ;(s.value = Math.max(s.value, S)), (d[k] = S), u.set(t.value[k], S)
  }
  function v(k) {
    return d.slice(0, k).reduce((S, _) => S + (_ || s.value), 0)
  }
  function g(k) {
    const S = t.value.length
    let _ = 0,
      T = 0
    for (; T < k && _ < S; ) T += d[_++] || s.value
    return _ - 1
  }
  let p = 0
  function y() {
    if (!o.value || !l.value) return
    const k = l.value.height - 56,
      S = o.value.scrollTop,
      _ = S < p ? pg : yg,
      T = g(S + k / 2),
      B = Math.round(f.value / 3),
      O = T - B,
      N = i.value + B * 2 - 1
    _ === pg && T <= N
      ? (i.value = cn(O, 0, t.value.length))
      : _ === yg && T >= N && (i.value = cn(O, 0, t.value.length - f.value)),
      (p = S)
  }
  function b(k) {
    if (!o.value) return
    const S = v(k)
    o.value.scrollTop = S
  }
  const x = A(() => Math.min(t.value.length, i.value + f.value)),
    w = A(() => t.value.slice(i.value, x.value).map((k, S) => ({ raw: k, index: S + i.value }))),
    C = A(() => v(i.value)),
    P = A(() => v(t.value.length) - v(x.value))
  return (
    Pe(
      () => t.value.length,
      () => {
        ;(d = ji(t.value.length).map(() => s.value)),
          u.forEach((k, S) => {
            const _ = t.value.indexOf(S)
            _ === -1 ? u.delete(S) : (d[_] = k)
          })
      }
    ),
    {
      containerRef: o,
      computedItems: w,
      itemHeight: s,
      paddingTop: C,
      paddingBottom: P,
      scrollToIndex: b,
      handleScroll: y,
      handleItemResize: h
    }
  )
}
const PM = ee(
    { items: { type: Array, default: () => [] }, renderless: Boolean, ...MM(), ...Me(), ...qn() },
    'VVirtualScroll'
  ),
  Jc = fe()({
    name: 'VVirtualScroll',
    props: PM(),
    setup(e, t) {
      let { slots: n } = t
      const i = Jt('VVirtualScroll'),
        { dimensionStyles: a } = Zn(e),
        {
          containerRef: s,
          handleScroll: o,
          handleItemResize: r,
          scrollToIndex: l,
          paddingTop: c,
          paddingBottom: u,
          computedItems: d
        } = AM(e, ve(e, 'items'))
      return (
        Aa(
          () => e.renderless,
          () => {
            tn(() => {
              var f
              ;(s.value = Wf(i.vnode.el, !0)), (f = s.value) == null || f.addEventListener('scroll', o)
            }),
              Mn(() => {
                var f
                ;(f = s.value) == null || f.removeEventListener('scroll', o)
              })
          }
        ),
        ge(() => {
          const f = d.value.map((h) =>
            m(
              CM,
              { key: h.index, renderless: e.renderless, 'onUpdate:height': (v) => r(h.index, v) },
              {
                default: (v) => {
                  var g
                  return (g = n.default) == null ? void 0 : g.call(n, { item: h.raw, index: h.index, ...v })
                }
              }
            )
          )
          return e.renderless
            ? m(Oe, null, [
                m('div', { class: 'v-virtual-scroll__spacer', style: { paddingTop: Ve(c.value) } }, null),
                f,
                m('div', { class: 'v-virtual-scroll__spacer', style: { paddingBottom: Ve(u.value) } }, null)
              ])
            : m(
                'div',
                { ref: s, class: ['v-virtual-scroll', e.class], onScroll: o, style: [a.value, e.style] },
                [
                  m(
                    'div',
                    {
                      class: 'v-virtual-scroll__container',
                      style: { paddingTop: Ve(c.value), paddingBottom: Ve(u.value) }
                    },
                    [f]
                  )
                ]
              )
        }),
        { scrollToIndex: l }
      )
    }
  })
function dh(e, t) {
  const n = Ce(!1)
  let i
  function a(r) {
    cancelAnimationFrame(i),
      (n.value = !0),
      (i = requestAnimationFrame(() => {
        i = requestAnimationFrame(() => {
          n.value = !1
        })
      }))
  }
  async function s() {
    await new Promise((r) => requestAnimationFrame(r)),
      await new Promise((r) => requestAnimationFrame(r)),
      await new Promise((r) => requestAnimationFrame(r)),
      await new Promise((r) => {
        if (n.value) {
          const l = Pe(n, () => {
            l(), r()
          })
        } else r()
      })
  }
  async function o(r) {
    var u, d
    if (
      (r.key === 'Tab' && ((u = t.value) == null || u.focus()),
      !['PageDown', 'PageUp', 'Home', 'End'].includes(r.key))
    )
      return
    const l = (d = e.value) == null ? void 0 : d.$el
    if (!l) return
    ;(r.key === 'Home' || r.key === 'End') &&
      l.scrollTo({ top: r.key === 'Home' ? 0 : l.scrollHeight, behavior: 'smooth' }),
      await s()
    const c = l.querySelectorAll(':scope > :not(.v-virtual-scroll__spacer)')
    if (r.key === 'PageDown' || r.key === 'Home') {
      const f = l.getBoundingClientRect().top
      for (const h of c)
        if (h.getBoundingClientRect().top >= f) {
          h.focus()
          break
        }
    } else {
      const f = l.getBoundingClientRect().bottom
      for (const h of [...c].reverse())
        if (h.getBoundingClientRect().bottom <= f) {
          h.focus()
          break
        }
    }
  }
  return { onListScroll: a, onListKeydown: o }
}
const fh = ee(
    {
      chips: Boolean,
      closableChips: Boolean,
      closeText: { type: String, default: '$vuetify.close' },
      openText: { type: String, default: '$vuetify.open' },
      eager: Boolean,
      hideNoData: Boolean,
      hideSelected: Boolean,
      menu: Boolean,
      menuIcon: { type: Ye, default: '$dropdown' },
      menuProps: { type: Object },
      multiple: Boolean,
      noDataText: { type: String, default: '$vuetify.noDataText' },
      openOnClear: Boolean,
      itemColor: String,
      ...sb({ itemChildren: !1 })
    },
    'Select'
  ),
  TM = ee(
    {
      ...fh(),
      ...Gn(Zc({ modelValue: null, role: 'button' }), ['validationValue', 'dirty', 'appendInnerIcon']),
      ...sa({ transition: { component: $c } })
    },
    'VSelect'
  ),
  VM = fe()({
    name: 'VSelect',
    props: TM(),
    emits: { 'update:focused': (e) => !0, 'update:modelValue': (e) => !0, 'update:menu': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { t: i } = Kn(),
        a = te(),
        s = te(),
        o = te(),
        r = Ge(e, 'menu'),
        l = A({
          get: () => r.value,
          set: (j) => {
            var U
            ;(r.value && !j && (U = s.value) != null && U.ΨopenChildren) || (r.value = j)
          }
        }),
        { items: c, transformIn: u, transformOut: d } = lh(e),
        f = Ge(
          e,
          'modelValue',
          [],
          (j) => u(j === null ? [null] : Dn(j)),
          (j) => {
            const U = d(j)
            return e.multiple ? U : U[0] ?? null
          }
        ),
        h = Uc(),
        v = A(() => f.value.map((j) => j.value)),
        g = Ce(!1),
        p = A(() => (l.value ? e.closeText : e.openText))
      let y = '',
        b
      const x = A(() => (e.hideSelected ? c.value.filter((j) => !f.value.some((U) => U === j)) : c.value)),
        w = A(
          () => (e.hideNoData && !c.value.length) || e.readonly || (h == null ? void 0 : h.isReadonly.value)
        ),
        C = te(),
        { onListScroll: P, onListKeydown: k } = dh(C, a)
      function S(j) {
        e.openOnClear && (l.value = !0)
      }
      function _() {
        w.value || (l.value = !l.value)
      }
      function T(j) {
        var ce, Te
        if (!j.key || e.readonly || (h != null && h.isReadonly.value)) return
        ;['Enter', ' ', 'ArrowDown', 'ArrowUp', 'Home', 'End'].includes(j.key) && j.preventDefault(),
          ['Enter', 'ArrowDown', ' '].includes(j.key) && (l.value = !0),
          ['Escape', 'Tab'].includes(j.key) && (l.value = !1),
          j.key === 'Home'
            ? (ce = C.value) == null || ce.focus('first')
            : j.key === 'End' && ((Te = C.value) == null || Te.focus('last'))
        const U = 1e3
        function X($e) {
          const He = $e.key.length === 1,
            Ue = !$e.ctrlKey && !$e.metaKey && !$e.altKey
          return He && Ue
        }
        if (e.multiple || !X(j)) return
        const oe = performance.now()
        oe - b > U && (y = ''), (y += j.key.toLowerCase()), (b = oe)
        const de = c.value.find(($e) => $e.title.toLowerCase().startsWith(y))
        de !== void 0 && (f.value = [de])
      }
      function B(j) {
        if (e.multiple) {
          const U = f.value.findIndex((X) => e.valueComparator(X.value, j.value))
          if (U === -1) f.value = [...f.value, j]
          else {
            const X = [...f.value]
            X.splice(U, 1), (f.value = X)
          }
        } else (f.value = [j]), (l.value = !1)
      }
      function O(j) {
        var U
        ;((U = C.value) != null && U.$el.contains(j.relatedTarget)) || (l.value = !1)
      }
      function N() {
        var j
        g.value && ((j = a.value) == null || j.focus())
      }
      function Q(j) {
        g.value = !0
      }
      function ue(j) {
        if (j == null) f.value = []
        else if (qs(a.value, ':autofill') || qs(a.value, ':-webkit-autofill')) {
          const U = c.value.find((X) => X.title === j)
          U && B(U)
        } else a.value && (a.value.value = '')
      }
      return (
        Pe(l, () => {
          if (!e.hideSelected && l.value && f.value.length) {
            const j = x.value.findIndex((U) => f.value.some((X) => e.valueComparator(X.value, U.value)))
            yt &&
              window.requestAnimationFrame(() => {
                var U
                j >= 0 && ((U = o.value) == null || U.scrollToIndex(j))
              })
          }
        }),
        ge(() => {
          const j = !!(e.chips || n.chip),
            U = !!(!e.hideNoData || x.value.length || n['prepend-item'] || n['append-item'] || n['no-data']),
            X = f.value.length > 0,
            [oe] = vs.filterProps(e),
            de = X || (!g.value && e.label && !e.persistentPlaceholder) ? void 0 : e.placeholder
          return m(
            vs,
            xe({ ref: a }, oe, {
              modelValue: f.value.map((ce) => ce.props.value).join(', '),
              'onUpdate:modelValue': ue,
              focused: g.value,
              'onUpdate:focused': (ce) => (g.value = ce),
              validationValue: f.externalValue,
              dirty: X,
              class: [
                'v-select',
                {
                  'v-select--active-menu': l.value,
                  'v-select--chips': !!e.chips,
                  [`v-select--${e.multiple ? 'multiple' : 'single'}`]: !0,
                  'v-select--selected': f.value.length,
                  'v-select--selection-slot': !!n.selection
                },
                e.class
              ],
              style: e.style,
              inputmode: 'none',
              placeholder: de,
              'onClick:clear': S,
              'onMousedown:control': _,
              onBlur: O,
              onKeydown: T,
              'aria-label': i(p.value),
              title: i(p.value)
            }),
            {
              ...n,
              default: () =>
                m(Oe, null, [
                  m(
                    Xc,
                    xe(
                      {
                        ref: s,
                        modelValue: l.value,
                        'onUpdate:modelValue': (ce) => (l.value = ce),
                        activator: 'parent',
                        contentClass: 'v-select__content',
                        disabled: w.value,
                        eager: e.eager,
                        maxHeight: 310,
                        openOnClick: !1,
                        closeOnContentClick: !1,
                        transition: e.transition,
                        onAfterLeave: N
                      },
                      e.menuProps
                    ),
                    {
                      default: () => [
                        U &&
                          m(
                            Yc,
                            {
                              ref: C,
                              selected: v.value,
                              selectStrategy: e.multiple ? 'independent' : 'single-independent',
                              onMousedown: (ce) => ce.preventDefault(),
                              onKeydown: k,
                              onFocusin: Q,
                              onScrollPassive: P,
                              tabindex: '-1',
                              color: e.itemColor ?? e.color
                            },
                            {
                              default: () => {
                                var ce, Te, $e
                                return [
                                  (ce = n['prepend-item']) == null ? void 0 : ce.call(n),
                                  !x.value.length &&
                                    !e.hideNoData &&
                                    (((Te = n['no-data']) == null ? void 0 : Te.call(n)) ??
                                      m(Qi, { title: i(e.noDataText) }, null)),
                                  m(
                                    Jc,
                                    { ref: o, renderless: !0, items: x.value },
                                    {
                                      default: (He) => {
                                        var W
                                        let { item: Ue, index: ie, itemRef: Y } = He
                                        const ne = xe(Ue.props, { ref: Y, key: ie, onClick: () => B(Ue) })
                                        return (
                                          ((W = n.item) == null
                                            ? void 0
                                            : W.call(n, { item: Ue, index: ie, props: ne })) ??
                                          m(Qi, ne, {
                                            prepend: (le) => {
                                              let { isSelected: De } = le
                                              return m(Oe, null, [
                                                e.multiple && !e.hideSelected
                                                  ? m(
                                                      Qs,
                                                      {
                                                        key: Ue.value,
                                                        modelValue: De,
                                                        ripple: !1,
                                                        tabindex: '-1'
                                                      },
                                                      null
                                                    )
                                                  : void 0,
                                                Ue.props.prependIcon &&
                                                  m(gt, { icon: Ue.props.prependIcon }, null)
                                              ])
                                            }
                                          })
                                        )
                                      }
                                    }
                                  ),
                                  ($e = n['append-item']) == null ? void 0 : $e.call(n)
                                ]
                              }
                            }
                          )
                      ]
                    }
                  ),
                  f.value.map((ce, Te) => {
                    var Ue
                    function $e(ie) {
                      ie.stopPropagation(), ie.preventDefault(), B(ce)
                    }
                    const He = {
                      'onClick:close': $e,
                      onMousedown(ie) {
                        ie.preventDefault(), ie.stopPropagation()
                      },
                      modelValue: !0,
                      'onUpdate:modelValue': void 0
                    }
                    return m('div', { key: ce.value, class: 'v-select__selection' }, [
                      j
                        ? n.chip
                          ? m(
                              vt,
                              {
                                key: 'chip-defaults',
                                defaults: {
                                  VChip: { closable: e.closableChips, size: 'small', text: ce.title }
                                }
                              },
                              {
                                default: () => {
                                  var ie
                                  return [
                                    (ie = n.chip) == null
                                      ? void 0
                                      : ie.call(n, { item: ce, index: Te, props: He })
                                  ]
                                }
                              }
                            )
                          : m(
                              Ur,
                              xe(
                                { key: 'chip', closable: e.closableChips, size: 'small', text: ce.title },
                                He
                              ),
                              null
                            )
                        : ((Ue = n.selection) == null ? void 0 : Ue.call(n, { item: ce, index: Te })) ??
                          m('span', { class: 'v-select__selection-text' }, [
                            ce.title,
                            e.multiple &&
                              Te < f.value.length - 1 &&
                              m('span', { class: 'v-select__selection-comma' }, [nt(',')])
                          ])
                    ])
                  })
                ]),
              'append-inner': function () {
                var He
                for (var ce = arguments.length, Te = new Array(ce), $e = 0; $e < ce; $e++)
                  Te[$e] = arguments[$e]
                return m(Oe, null, [
                  (He = n['append-inner']) == null ? void 0 : He.call(n, ...Te),
                  e.menuIcon ? m(gt, { class: 'v-select__menu-icon', icon: e.menuIcon }, null) : void 0
                ])
              }
            }
          )
        }),
        vi({ isFocused: g, menu: l, select: B }, a)
      )
    }
  }),
  EM = (e, t, n) =>
    e == null || t == null ? -1 : e.toString().toLocaleLowerCase().indexOf(t.toString().toLocaleLowerCase()),
  mb = ee(
    {
      customFilter: Function,
      customKeyFilter: Object,
      filterKeys: [Array, String],
      filterMode: { type: String, default: 'intersection' },
      noFilter: Boolean
    },
    'filter'
  )
function LM(e, t, n) {
  var r
  const i = [],
    a = (n == null ? void 0 : n.default) ?? EM,
    s = n != null && n.filterKeys ? Dn(n.filterKeys) : !1,
    o = Object.keys((n == null ? void 0 : n.customKeyFilter) ?? {}).length
  if (!(e != null && e.length)) return i
  e: for (let l = 0; l < e.length; l++) {
    const [c, u = c] = Dn(e[l]),
      d = {},
      f = {}
    let h = -1
    if (t && !(n != null && n.noFilter)) {
      if (typeof c == 'object') {
        const p = s || Object.keys(u)
        for (const y of p) {
          const b = Si(u, y, u),
            x = (r = n == null ? void 0 : n.customKeyFilter) == null ? void 0 : r[y]
          if (((h = x ? x(b, t, c) : a(b, t, c)), h !== -1 && h !== !1)) x ? (d[y] = h) : (f[y] = h)
          else if ((n == null ? void 0 : n.filterMode) === 'every') continue e
        }
      } else (h = a(c, t, c)), h !== -1 && h !== !1 && (f.title = h)
      const v = Object.keys(f).length,
        g = Object.keys(d).length
      if (
        (!v && !g) ||
        ((n == null ? void 0 : n.filterMode) === 'union' && g !== o && !v) ||
        ((n == null ? void 0 : n.filterMode) === 'intersection' && (g !== o || !v))
      )
        continue
    }
    i.push({ index: l, matches: { ...f, ...d } })
  }
  return i
}
function pb(e, t, n, i) {
  const a = te([]),
    s = te(new Map()),
    o = A(() => (i != null && i.transform ? Xe(t).map((l) => [l, i.transform(l)]) : Xe(t)))
  Ut(() => {
    const l = typeof n == 'function' ? n() : Xe(n),
      c = typeof l != 'string' && typeof l != 'number' ? '' : String(l),
      u = LM(o.value, c, {
        customKeyFilter: e.customKeyFilter,
        default: e.customFilter,
        filterKeys: e.filterKeys,
        filterMode: e.filterMode,
        noFilter: e.noFilter
      }),
      d = Xe(t),
      f = [],
      h = new Map()
    u.forEach((v) => {
      let { index: g, matches: p } = v
      const y = d[g]
      f.push(y), h.set(y.value, p)
    }),
      (a.value = f),
      (s.value = h)
  })
  function r(l) {
    return s.value.get(l.value)
  }
  return { filteredItems: a, filteredMatches: s, getMatches: r }
}
function OM(e, t, n) {
  if (t == null) return e
  if (Array.isArray(t)) throw new Error('Multiple matches is not implemented')
  return typeof t == 'number' && ~t
    ? m(Oe, null, [
        m('span', { class: 'v-autocomplete__unmask' }, [e.substr(0, t)]),
        m('span', { class: 'v-autocomplete__mask' }, [e.substr(t, n)]),
        m('span', { class: 'v-autocomplete__unmask' }, [e.substr(t + n)])
      ])
    : e
}
const IM = ee(
    {
      autoSelectFirst: { type: [Boolean, String] },
      search: String,
      ...mb({ filterKeys: ['title'] }),
      ...fh(),
      ...Gn(Zc({ modelValue: null, role: 'combobox' }), ['validationValue', 'dirty', 'appendInnerIcon']),
      ...sa({ transition: !1 })
    },
    'VAutocomplete'
  ),
  DM = fe()({
    name: 'VAutocomplete',
    props: IM(),
    emits: {
      'update:focused': (e) => !0,
      'update:search': (e) => !0,
      'update:modelValue': (e) => !0,
      'update:menu': (e) => !0
    },
    setup(e, t) {
      let { slots: n } = t
      const { t: i } = Kn(),
        a = te(),
        s = Ce(!1),
        o = Ce(!0),
        r = Ce(!1),
        l = te(),
        c = te(),
        u = Ge(e, 'menu'),
        d = A({
          get: () => u.value,
          set: (ne) => {
            var W
            ;(u.value && !ne && (W = l.value) != null && W.ΨopenChildren) || (u.value = ne)
          }
        }),
        f = Ce(-1),
        h = A(() => {
          var ne
          return (ne = a.value) == null ? void 0 : ne.color
        }),
        v = A(() => (d.value ? e.closeText : e.openText)),
        { items: g, transformIn: p, transformOut: y } = lh(e),
        { textColorClasses: b, textColorStyles: x } = dn(h),
        w = Ge(e, 'search', ''),
        C = Ge(
          e,
          'modelValue',
          [],
          (ne) => p(ne === null ? [null] : Dn(ne)),
          (ne) => {
            const W = y(ne)
            return e.multiple ? W : W[0] ?? null
          }
        ),
        P = Uc(),
        { filteredItems: k, getMatches: S } = pb(e, g, () => (o.value ? '' : w.value)),
        _ = A(() =>
          e.hideSelected ? k.value.filter((ne) => !C.value.some((W) => W.value === ne.value)) : k.value
        ),
        T = A(() => C.value.map((ne) => ne.props.value)),
        B = A(() => {
          var W
          return (
            (e.autoSelectFirst === !0 ||
              (e.autoSelectFirst === 'exact' && w.value === ((W = _.value[0]) == null ? void 0 : W.title))) &&
            _.value.length > 0 &&
            !o.value &&
            !r.value
          )
        }),
        O = A(
          () => (e.hideNoData && !g.value.length) || e.readonly || (P == null ? void 0 : P.isReadonly.value)
        ),
        N = te(),
        { onListScroll: Q, onListKeydown: ue } = dh(N, a)
      function j(ne) {
        e.openOnClear && (d.value = !0), (w.value = '')
      }
      function U() {
        O.value || (d.value = !0)
      }
      function X(ne) {
        O.value || (s.value && (ne.preventDefault(), ne.stopPropagation()), (d.value = !d.value))
      }
      function oe(ne) {
        var De, L, D
        if (e.readonly || (P != null && P.isReadonly.value)) return
        const W = a.value.selectionStart,
          le = C.value.length
        if (
          ((f.value > -1 || ['Enter', 'ArrowDown', 'ArrowUp'].includes(ne.key)) && ne.preventDefault(),
          ['Enter', 'ArrowDown'].includes(ne.key) && (d.value = !0),
          ['Escape'].includes(ne.key) && (d.value = !1),
          B.value && ['Enter', 'Tab'].includes(ne.key) && Y(_.value[0]),
          ne.key === 'ArrowDown' && B.value && ((De = N.value) == null || De.focus('next')),
          !!e.multiple)
        ) {
          if (['Backspace', 'Delete'].includes(ne.key)) {
            if (f.value < 0) {
              ne.key === 'Backspace' && !w.value && (f.value = le - 1)
              return
            }
            const H = f.value,
              Z = C.value[f.value]
            Z && Y(Z), (f.value = H >= le - 1 ? le - 2 : H)
          }
          if (ne.key === 'ArrowLeft') {
            if (f.value < 0 && W > 0) return
            const H = f.value > -1 ? f.value - 1 : le - 1
            C.value[H]
              ? (f.value = H)
              : ((f.value = -1),
                a.value.setSelectionRange(
                  (L = w.value) == null ? void 0 : L.length,
                  (D = w.value) == null ? void 0 : D.length
                ))
          }
          if (ne.key === 'ArrowRight') {
            if (f.value < 0) return
            const H = f.value + 1
            C.value[H] ? (f.value = H) : ((f.value = -1), a.value.setSelectionRange(0, 0))
          }
        }
      }
      function de(ne) {
        w.value = ne.target.value
      }
      function ce(ne) {
        if (qs(a.value, ':autofill') || qs(a.value, ':-webkit-autofill')) {
          const W = g.value.find((le) => le.title === ne.target.value)
          W && Y(W)
        }
      }
      function Te() {
        var ne
        s.value && ((o.value = !0), (ne = a.value) == null || ne.focus())
      }
      function $e(ne) {
        ;(s.value = !0),
          setTimeout(() => {
            r.value = !0
          })
      }
      function He(ne) {
        r.value = !1
      }
      function Ue(ne) {
        ;(ne == null || (ne === '' && !e.multiple)) && (C.value = [])
      }
      const ie = Ce(!1)
      function Y(ne) {
        if (e.multiple) {
          const W = C.value.findIndex((le) => e.valueComparator(le.value, ne.value))
          if (W === -1) C.value = [...C.value, ne]
          else {
            const le = [...C.value]
            le.splice(W, 1), (C.value = le)
          }
        } else
          (C.value = [ne]),
            (ie.value = !0),
            (w.value = ne.title),
            (d.value = !1),
            (o.value = !0),
            mt(() => (ie.value = !1))
      }
      return (
        Pe(s, (ne, W) => {
          var le
          ne !== W &&
            (ne
              ? ((ie.value = !0),
                (w.value = e.multiple
                  ? ''
                  : String(((le = C.value.at(-1)) == null ? void 0 : le.props.title) ?? '')),
                (o.value = !0),
                mt(() => (ie.value = !1)))
              : (!e.multiple && !w.value
                  ? (C.value = [])
                  : B.value &&
                    !r.value &&
                    !C.value.some((De) => {
                      let { value: L } = De
                      return L === _.value[0].value
                    }) &&
                    Y(_.value[0]),
                (d.value = !1),
                (w.value = ''),
                (f.value = -1)))
        }),
        Pe(w, (ne) => {
          !s.value || ie.value || (ne && (d.value = !0), (o.value = !ne))
        }),
        Pe(d, () => {
          if (!e.hideSelected && d.value && C.value.length) {
            const ne = _.value.findIndex((W) => C.value.some((le) => W.value === le.value))
            yt &&
              window.requestAnimationFrame(() => {
                var W
                ne >= 0 && ((W = c.value) == null || W.scrollToIndex(ne))
              })
          }
        }),
        ge(() => {
          const ne = !!(e.chips || n.chip),
            W = !!(!e.hideNoData || _.value.length || n['prepend-item'] || n['append-item'] || n['no-data']),
            le = C.value.length > 0,
            [De] = vs.filterProps(e)
          return m(
            vs,
            xe({ ref: a }, De, {
              modelValue: w.value,
              'onUpdate:modelValue': Ue,
              focused: s.value,
              'onUpdate:focused': (L) => (s.value = L),
              validationValue: C.externalValue,
              dirty: le,
              onInput: de,
              onChange: ce,
              class: [
                'v-autocomplete',
                `v-autocomplete--${e.multiple ? 'multiple' : 'single'}`,
                {
                  'v-autocomplete--active-menu': d.value,
                  'v-autocomplete--chips': !!e.chips,
                  'v-autocomplete--selection-slot': !!n.selection,
                  'v-autocomplete--selecting-index': f.value > -1
                },
                e.class
              ],
              style: e.style,
              readonly: e.readonly,
              placeholder: le ? void 0 : e.placeholder,
              'onClick:clear': j,
              'onMousedown:control': U,
              onKeydown: oe
            }),
            {
              ...n,
              default: () =>
                m(Oe, null, [
                  m(
                    Xc,
                    xe(
                      {
                        ref: l,
                        modelValue: d.value,
                        'onUpdate:modelValue': (L) => (d.value = L),
                        activator: 'parent',
                        contentClass: 'v-autocomplete__content',
                        disabled: O.value,
                        eager: e.eager,
                        maxHeight: 310,
                        openOnClick: !1,
                        closeOnContentClick: !1,
                        transition: e.transition,
                        onAfterLeave: Te
                      },
                      e.menuProps
                    ),
                    {
                      default: () => [
                        W &&
                          m(
                            Yc,
                            {
                              ref: N,
                              selected: T.value,
                              selectStrategy: e.multiple ? 'independent' : 'single-independent',
                              onMousedown: (L) => L.preventDefault(),
                              onKeydown: ue,
                              onFocusin: $e,
                              onFocusout: He,
                              onScrollPassive: Q,
                              tabindex: '-1',
                              color: e.itemColor ?? e.color
                            },
                            {
                              default: () => {
                                var L, D, H
                                return [
                                  (L = n['prepend-item']) == null ? void 0 : L.call(n),
                                  !_.value.length &&
                                    !e.hideNoData &&
                                    (((D = n['no-data']) == null ? void 0 : D.call(n)) ??
                                      m(Qi, { title: i(e.noDataText) }, null)),
                                  m(
                                    Jc,
                                    { ref: c, renderless: !0, items: _.value },
                                    {
                                      default: (Z) => {
                                        var _e
                                        let { item: ae, index: se, itemRef: ye } = Z
                                        const pe = xe(ae.props, {
                                          ref: ye,
                                          key: se,
                                          active: B.value && se === 0 ? !0 : void 0,
                                          onClick: () => Y(ae)
                                        })
                                        return (
                                          ((_e = n.item) == null
                                            ? void 0
                                            : _e.call(n, { item: ae, index: se, props: pe })) ??
                                          m(Qi, pe, {
                                            prepend: (he) => {
                                              let { isSelected: Fe } = he
                                              return m(Oe, null, [
                                                e.multiple && !e.hideSelected
                                                  ? m(
                                                      Qs,
                                                      {
                                                        key: ae.value,
                                                        modelValue: Fe,
                                                        ripple: !1,
                                                        tabindex: '-1'
                                                      },
                                                      null
                                                    )
                                                  : void 0,
                                                ae.props.prependIcon &&
                                                  m(gt, { icon: ae.props.prependIcon }, null)
                                              ])
                                            },
                                            title: () => {
                                              var he, Fe
                                              return o.value
                                                ? ae.title
                                                : OM(
                                                    ae.title,
                                                    (he = S(ae)) == null ? void 0 : he.title,
                                                    ((Fe = w.value) == null ? void 0 : Fe.length) ?? 0
                                                  )
                                            }
                                          })
                                        )
                                      }
                                    }
                                  ),
                                  (H = n['append-item']) == null ? void 0 : H.call(n)
                                ]
                              }
                            }
                          )
                      ]
                    }
                  ),
                  C.value.map((L, D) => {
                    var ae
                    function H(se) {
                      se.stopPropagation(), se.preventDefault(), Y(L)
                    }
                    const Z = {
                      'onClick:close': H,
                      onMousedown(se) {
                        se.preventDefault(), se.stopPropagation()
                      },
                      modelValue: !0,
                      'onUpdate:modelValue': void 0
                    }
                    return m(
                      'div',
                      {
                        key: L.value,
                        class: [
                          'v-autocomplete__selection',
                          D === f.value && ['v-autocomplete__selection--selected', b.value]
                        ],
                        style: D === f.value ? x.value : {}
                      },
                      [
                        ne
                          ? n.chip
                            ? m(
                                vt,
                                {
                                  key: 'chip-defaults',
                                  defaults: {
                                    VChip: { closable: e.closableChips, size: 'small', text: L.title }
                                  }
                                },
                                {
                                  default: () => {
                                    var se
                                    return [
                                      (se = n.chip) == null
                                        ? void 0
                                        : se.call(n, { item: L, index: D, props: Z })
                                    ]
                                  }
                                }
                              )
                            : m(
                                Ur,
                                xe(
                                  { key: 'chip', closable: e.closableChips, size: 'small', text: L.title },
                                  Z
                                ),
                                null
                              )
                          : ((ae = n.selection) == null ? void 0 : ae.call(n, { item: L, index: D })) ??
                            m('span', { class: 'v-autocomplete__selection-text' }, [
                              L.title,
                              e.multiple &&
                                D < C.value.length - 1 &&
                                m('span', { class: 'v-autocomplete__selection-comma' }, [nt(',')])
                            ])
                      ]
                    )
                  })
                ]),
              'append-inner': function () {
                var Z
                for (var L = arguments.length, D = new Array(L), H = 0; H < L; H++) D[H] = arguments[H]
                return m(Oe, null, [
                  (Z = n['append-inner']) == null ? void 0 : Z.call(n, ...D),
                  e.menuIcon
                    ? m(
                        gt,
                        {
                          class: 'v-autocomplete__menu-icon',
                          icon: e.menuIcon,
                          onMousedown: X,
                          onClick: q0,
                          'aria-label': i(v.value),
                          title: i(v.value)
                        },
                        null
                      )
                    : void 0
                ])
              }
            }
          )
        }),
        vi({ isFocused: s, isPristine: o, menu: d, search: w, filteredItems: k, select: Y }, a)
      )
    }
  })
const FM = ee(
    {
      bordered: Boolean,
      color: String,
      content: [Number, String],
      dot: Boolean,
      floating: Boolean,
      icon: Ye,
      inline: Boolean,
      label: { type: String, default: '$vuetify.badge' },
      max: [Number, String],
      modelValue: { type: Boolean, default: !0 },
      offsetX: [Number, String],
      offsetY: [Number, String],
      textColor: String,
      ...Me(),
      ...Oa({ location: 'top end' }),
      ...kt(),
      ...Ke(),
      ...ot(),
      ...sa({ transition: 'scale-rotate-transition' })
    },
    'VBadge'
  ),
  RM = fe()({
    name: 'VBadge',
    inheritAttrs: !1,
    props: FM(),
    setup(e, t) {
      const { backgroundColorClasses: n, backgroundColorStyles: i } = Rt(ve(e, 'color')),
        { roundedClasses: a } = Lt(e),
        { t: s } = Kn(),
        { textColorClasses: o, textColorStyles: r } = dn(ve(e, 'textColor')),
        { themeClasses: l } = hy(),
        { locationStyles: c } = Ia(
          e,
          !0,
          (u) =>
            (e.floating ? (e.dot ? 2 : 4) : e.dot ? 8 : 12) +
            (['top', 'bottom'].includes(u)
              ? +(e.offsetY ?? 0)
              : ['left', 'right'].includes(u)
              ? +(e.offsetX ?? 0)
              : 0)
        )
      return (
        ge(() => {
          const u = Number(e.content),
            d = !e.max || isNaN(u) ? e.content : u <= +e.max ? u : `${e.max}+`,
            [f, h] = ds(t.attrs, ['aria-atomic', 'aria-label', 'aria-live', 'role', 'title'])
          return m(
            e.tag,
            xe(
              {
                class: [
                  'v-badge',
                  {
                    'v-badge--bordered': e.bordered,
                    'v-badge--dot': e.dot,
                    'v-badge--floating': e.floating,
                    'v-badge--inline': e.inline
                  },
                  e.class
                ]
              },
              h,
              { style: e.style }
            ),
            {
              default: () => {
                var v, g
                return [
                  m('div', { class: 'v-badge__wrapper' }, [
                    (g = (v = t.slots).default) == null ? void 0 : g.call(v),
                    m(
                      ii,
                      { transition: e.transition },
                      {
                        default: () => {
                          var p, y
                          return [
                            Et(
                              m(
                                'span',
                                xe(
                                  {
                                    class: ['v-badge__badge', l.value, n.value, a.value, o.value],
                                    style: [i.value, r.value, e.inline ? {} : c.value],
                                    'aria-atomic': 'true',
                                    'aria-label': s(e.label, u),
                                    'aria-live': 'polite',
                                    role: 'status'
                                  },
                                  f
                                ),
                                [
                                  e.dot
                                    ? void 0
                                    : t.slots.badge
                                    ? (y = (p = t.slots).badge) == null
                                      ? void 0
                                      : y.call(p)
                                    : e.icon
                                    ? m(gt, { icon: e.icon }, null)
                                    : d
                                ]
                              ),
                              [[Li, e.modelValue]]
                            )
                          ]
                        }
                      }
                    )
                  ])
                ]
              }
            }
          )
        }),
        {}
      )
    }
  })
const BM = ee({ color: String, density: String, ...Me() }, 'VBannerActions'),
  yb = fe()({
    name: 'VBannerActions',
    props: BM(),
    setup(e, t) {
      let { slots: n } = t
      return (
        zt({ VBtn: { color: e.color, density: e.density, variant: 'text' } }),
        ge(() => {
          var i
          return m('div', { class: ['v-banner-actions', e.class], style: e.style }, [
            (i = n.default) == null ? void 0 : i.call(n)
          ])
        }),
        {}
      )
    }
  }),
  bb = hi('v-banner-text'),
  NM = ee(
    {
      avatar: String,
      color: String,
      icon: Ye,
      lines: String,
      stacked: Boolean,
      sticky: Boolean,
      text: String,
      ...Bn(),
      ...Me(),
      ...Gt(),
      ...qn(),
      ...Yt(),
      ...Oa(),
      ...po(),
      ...kt(),
      ...Ke(),
      ...ot()
    },
    'VBanner'
  ),
  $M = fe()({
    name: 'VBanner',
    props: NM(),
    setup(e, t) {
      let { slots: n } = t
      const { borderClasses: i } = Jn(e),
        { densityClasses: a } = gn(e),
        { mobile: s } = bs(),
        { dimensionStyles: o } = Zn(e),
        { elevationClasses: r } = nn(e),
        { locationStyles: l } = Ia(e),
        { positionClasses: c } = yo(e),
        { roundedClasses: u } = Lt(e),
        { themeClasses: d } = ut(e),
        f = ve(e, 'color'),
        h = ve(e, 'density')
      zt({ VBannerActions: { color: f, density: h } }),
        ge(() => {
          const v = !!(e.text || n.text),
            g = !!(e.avatar || e.icon),
            p = !!(g || n.prepend)
          return m(
            e.tag,
            {
              class: [
                'v-banner',
                {
                  'v-banner--stacked': e.stacked || s.value,
                  'v-banner--sticky': e.sticky,
                  [`v-banner--${e.lines}-line`]: !!e.lines
                },
                i.value,
                a.value,
                r.value,
                c.value,
                u.value,
                d.value,
                e.class
              ],
              style: [o.value, l.value, e.style],
              role: 'banner'
            },
            {
              default: () => {
                var y
                return [
                  p &&
                    m('div', { key: 'prepend', class: 'v-banner__prepend' }, [
                      n.prepend
                        ? m(
                            vt,
                            {
                              key: 'prepend-defaults',
                              disabled: !g,
                              defaults: {
                                VAvatar: { color: f.value, density: h.value, icon: e.icon, image: e.avatar }
                              }
                            },
                            n.prepend
                          )
                        : m(
                            Pa,
                            {
                              key: 'prepend-avatar',
                              color: f.value,
                              density: h.value,
                              icon: e.icon,
                              image: e.avatar
                            },
                            null
                          )
                    ]),
                  m('div', { class: 'v-banner__content' }, [
                    v &&
                      m(
                        bb,
                        { key: 'text' },
                        {
                          default: () => {
                            var b
                            return [((b = n.text) == null ? void 0 : b.call(n)) ?? e.text]
                          }
                        }
                      ),
                    (y = n.default) == null ? void 0 : y.call(n)
                  ]),
                  n.actions && m(yb, { key: 'actions' }, n.actions)
                ]
              }
            }
          )
        })
    }
  })
const zM = ee(
    {
      bgColor: String,
      color: String,
      grow: Boolean,
      mode: { type: String, validator: (e) => !e || ['horizontal', 'shift'].includes(e) },
      height: { type: [Number, String], default: 56 },
      active: { type: Boolean, default: !0 },
      ...Bn(),
      ...Me(),
      ...Gt(),
      ...Yt(),
      ...kt(),
      ...uo({ name: 'bottom-navigation' }),
      ...Ke({ tag: 'header' }),
      ...ho({ modelValue: !0, selectedClass: 'v-btn--selected' }),
      ...ot()
    },
    'VBottomNavigation'
  ),
  HM = fe()({
    name: 'VBottomNavigation',
    props: zM(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = hy(),
        { borderClasses: a } = Jn(e),
        { backgroundColorClasses: s, backgroundColorStyles: o } = Rt(ve(e, 'bgColor')),
        { densityClasses: r } = gn(e),
        { elevationClasses: l } = nn(e),
        { roundedClasses: c } = Lt(e),
        { ssrBootStyles: u } = _s(),
        d = A(
          () => Number(e.height) - (e.density === 'comfortable' ? 8 : 0) - (e.density === 'compact' ? 16 : 0)
        ),
        f = ve(e, 'active'),
        { layoutItemStyles: h } = fo({
          id: e.name,
          order: A(() => parseInt(e.order, 10)),
          position: A(() => 'bottom'),
          layoutSize: A(() => (f.value ? d.value : 0)),
          elementSize: d,
          active: f,
          absolute: ve(e, 'absolute')
        })
      return (
        Ss(e, Qf),
        zt(
          {
            VBtn: {
              color: ve(e, 'color'),
              density: ve(e, 'density'),
              stacked: A(() => e.mode !== 'horizontal'),
              variant: 'text'
            }
          },
          { scoped: !0 }
        ),
        ge(() =>
          m(
            e.tag,
            {
              class: [
                'v-bottom-navigation',
                {
                  'v-bottom-navigation--active': f.value,
                  'v-bottom-navigation--grow': e.grow,
                  'v-bottom-navigation--shift': e.mode === 'shift'
                },
                i.value,
                s.value,
                a.value,
                r.value,
                l.value,
                c.value,
                e.class
              ],
              style: [
                o.value,
                h.value,
                { height: Ve(d.value), transform: `translateY(${Ve(f.value ? 0 : 100, '%')})` },
                u.value,
                e.style
              ]
            },
            {
              default: () => [n.default && m('div', { class: 'v-bottom-navigation__content' }, [n.default()])]
            }
          )
        ),
        {}
      )
    }
  })
const WM = ee({ divider: [Number, String], ...Me() }, 'VBreadcrumbsDivider'),
  _b = fe()({
    name: 'VBreadcrumbsDivider',
    props: WM(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ge(() => {
          var i
          return m('li', { class: ['v-breadcrumbs-divider', e.class], style: e.style }, [
            ((i = n == null ? void 0 : n.default) == null ? void 0 : i.call(n)) ?? e.divider
          ])
        }),
        {}
      )
    }
  }),
  jM = ee(
    {
      active: Boolean,
      activeClass: String,
      activeColor: String,
      color: String,
      disabled: Boolean,
      title: String,
      ...Me(),
      ...jr(),
      ...Ke({ tag: 'li' })
    },
    'VBreadcrumbsItem'
  ),
  xb = fe()({
    name: 'VBreadcrumbsItem',
    props: jM(),
    setup(e, t) {
      let { slots: n, attrs: i } = t
      const a = Wr(e, i),
        s = A(() => {
          var c
          return e.active || ((c = a.isActive) == null ? void 0 : c.value)
        }),
        o = A(() => (s.value ? e.activeColor : e.color)),
        { textColorClasses: r, textColorStyles: l } = dn(o)
      return (
        ge(() =>
          m(
            e.tag,
            {
              class: [
                'v-breadcrumbs-item',
                {
                  'v-breadcrumbs-item--active': s.value,
                  'v-breadcrumbs-item--disabled': e.disabled,
                  [`${e.activeClass}`]: s.value && e.activeClass
                },
                r.value,
                e.class
              ],
              style: [l.value, e.style],
              'aria-current': s.value ? 'page' : void 0
            },
            {
              default: () => {
                var c, u
                return [
                  a.isLink.value
                    ? m(
                        'a',
                        {
                          class: 'v-breadcrumbs-item--link',
                          href: a.href.value,
                          'aria-current': s.value ? 'page' : void 0,
                          onClick: a.navigate
                        },
                        [((u = n.default) == null ? void 0 : u.call(n)) ?? e.title]
                      )
                    : ((c = n.default) == null ? void 0 : c.call(n)) ?? e.title
                ]
              }
            }
          )
        ),
        {}
      )
    }
  }),
  UM = ee(
    {
      activeClass: String,
      activeColor: String,
      bgColor: String,
      color: String,
      disabled: Boolean,
      divider: { type: String, default: '/' },
      icon: Ye,
      items: { type: Array, default: () => [] },
      ...Me(),
      ...Gt(),
      ...kt(),
      ...Ke({ tag: 'ul' })
    },
    'VBreadcrumbs'
  ),
  YM = fe()({
    name: 'VBreadcrumbs',
    props: UM(),
    setup(e, t) {
      let { slots: n } = t
      const { backgroundColorClasses: i, backgroundColorStyles: a } = Rt(ve(e, 'bgColor')),
        { densityClasses: s } = gn(e),
        { roundedClasses: o } = Lt(e)
      zt({
        VBreadcrumbsDivider: { divider: ve(e, 'divider') },
        VBreadcrumbsItem: {
          activeClass: ve(e, 'activeClass'),
          activeColor: ve(e, 'activeColor'),
          color: ve(e, 'color'),
          disabled: ve(e, 'disabled')
        }
      })
      const r = A(() =>
        e.items.map((l) => (typeof l == 'string' ? { item: { title: l }, raw: l } : { item: l, raw: l }))
      )
      return (
        ge(() => {
          const l = !!(n.prepend || e.icon)
          return m(
            e.tag,
            { class: ['v-breadcrumbs', i.value, s.value, o.value, e.class], style: [a.value, e.style] },
            {
              default: () => {
                var c
                return [
                  l &&
                    m('li', { key: 'prepend', class: 'v-breadcrumbs__prepend' }, [
                      n.prepend
                        ? m(
                            vt,
                            {
                              key: 'prepend-defaults',
                              disabled: !e.icon,
                              defaults: { VIcon: { icon: e.icon, start: !0 } }
                            },
                            n.prepend
                          )
                        : m(gt, { key: 'prepend-icon', start: !0, icon: e.icon }, null)
                    ]),
                  r.value.map((u, d, f) => {
                    let { item: h, raw: v } = u
                    return m(Oe, null, [
                      m(xb, xe({ key: h.title, disabled: d >= f.length - 1 }, h), {
                        default: n.title
                          ? () => {
                              var g
                              return (g = n.title) == null ? void 0 : g.call(n, { item: v, index: d })
                            }
                          : void 0
                      }),
                      d < f.length - 1 &&
                        m(_b, null, {
                          default: n.divider
                            ? () => {
                                var g
                                return (g = n.divider) == null ? void 0 : g.call(n, { item: v, index: d })
                              }
                            : void 0
                        })
                    ])
                  }),
                  (c = n.default) == null ? void 0 : c.call(n)
                ]
              }
            }
          )
        }),
        {}
      )
    }
  })
const wb = fe()({
    name: 'VCardActions',
    props: Me(),
    setup(e, t) {
      let { slots: n } = t
      return (
        zt({ VBtn: { variant: 'text' } }),
        ge(() => {
          var i
          return m('div', { class: ['v-card-actions', e.class], style: e.style }, [
            (i = n.default) == null ? void 0 : i.call(n)
          ])
        }),
        {}
      )
    }
  }),
  Sb = hi('v-card-subtitle'),
  kb = hi('v-card-title'),
  GM = ee(
    {
      appendAvatar: String,
      appendIcon: Ye,
      prependAvatar: String,
      prependIcon: Ye,
      subtitle: String,
      title: String,
      ...Me(),
      ...Gt()
    },
    'VCardItem'
  ),
  Cb = fe()({
    name: 'VCardItem',
    props: GM(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ge(() => {
          var c
          const i = !!(e.prependAvatar || e.prependIcon),
            a = !!(i || n.prepend),
            s = !!(e.appendAvatar || e.appendIcon),
            o = !!(s || n.append),
            r = !!(e.title || n.title),
            l = !!(e.subtitle || n.subtitle)
          return m('div', { class: ['v-card-item', e.class], style: e.style }, [
            a &&
              m('div', { key: 'prepend', class: 'v-card-item__prepend' }, [
                n.prepend
                  ? m(
                      vt,
                      {
                        key: 'prepend-defaults',
                        disabled: !i,
                        defaults: {
                          VAvatar: { density: e.density, icon: e.prependIcon, image: e.prependAvatar }
                        }
                      },
                      n.prepend
                    )
                  : i &&
                    m(
                      Pa,
                      {
                        key: 'prepend-avatar',
                        density: e.density,
                        icon: e.prependIcon,
                        image: e.prependAvatar
                      },
                      null
                    )
              ]),
            m('div', { class: 'v-card-item__content' }, [
              r &&
                m(
                  kb,
                  { key: 'title' },
                  {
                    default: () => {
                      var u
                      return [((u = n.title) == null ? void 0 : u.call(n)) ?? e.title]
                    }
                  }
                ),
              l &&
                m(
                  Sb,
                  { key: 'subtitle' },
                  {
                    default: () => {
                      var u
                      return [((u = n.subtitle) == null ? void 0 : u.call(n)) ?? e.subtitle]
                    }
                  }
                ),
              (c = n.default) == null ? void 0 : c.call(n)
            ]),
            o &&
              m('div', { key: 'append', class: 'v-card-item__append' }, [
                n.append
                  ? m(
                      vt,
                      {
                        key: 'append-defaults',
                        disabled: !s,
                        defaults: {
                          VAvatar: { density: e.density, icon: e.appendIcon, image: e.appendAvatar }
                        }
                      },
                      n.append
                    )
                  : s &&
                    m(
                      Pa,
                      { key: 'append-avatar', density: e.density, icon: e.appendIcon, image: e.appendAvatar },
                      null
                    )
              ])
          ])
        }),
        {}
      )
    }
  }),
  Mb = hi('v-card-text'),
  XM = ee(
    {
      appendAvatar: String,
      appendIcon: Ye,
      disabled: Boolean,
      flat: Boolean,
      hover: Boolean,
      image: String,
      link: { type: Boolean, default: void 0 },
      prependAvatar: String,
      prependIcon: Ye,
      ripple: { type: [Boolean, Object], default: !0 },
      subtitle: String,
      text: String,
      title: String,
      ...Bn(),
      ...Me(),
      ...Gt(),
      ...qn(),
      ...Yt(),
      ...ih(),
      ...Oa(),
      ...po(),
      ...kt(),
      ...jr(),
      ...Ke(),
      ...ot(),
      ...Qn({ variant: 'elevated' })
    },
    'VCard'
  ),
  KM = fe()({
    name: 'VCard',
    directives: { Ripple: Da },
    props: XM(),
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const { themeClasses: a } = ut(e),
        { borderClasses: s } = Jn(e),
        { colorClasses: o, colorStyles: r, variantClasses: l } = ws(e),
        { densityClasses: c } = gn(e),
        { dimensionStyles: u } = Zn(e),
        { elevationClasses: d } = nn(e),
        { loaderClasses: f } = Hc(e),
        { locationStyles: h } = Ia(e),
        { positionClasses: v } = yo(e),
        { roundedClasses: g } = Lt(e),
        p = Wr(e, n),
        y = A(() => e.link !== !1 && p.isLink.value),
        b = A(() => !e.disabled && e.link !== !1 && (e.link || p.isClickable.value))
      return (
        ge(() => {
          const x = y.value ? 'a' : e.tag,
            w = !!(i.title || e.title),
            C = !!(i.subtitle || e.subtitle),
            P = w || C,
            k = !!(i.append || e.appendAvatar || e.appendIcon),
            S = !!(i.prepend || e.prependAvatar || e.prependIcon),
            _ = !!(i.image || e.image),
            T = P || S || k,
            B = !!(i.text || e.text)
          return Et(
            m(
              x,
              {
                class: [
                  'v-card',
                  {
                    'v-card--disabled': e.disabled,
                    'v-card--flat': e.flat,
                    'v-card--hover': e.hover && !(e.disabled || e.flat),
                    'v-card--link': b.value
                  },
                  a.value,
                  s.value,
                  o.value,
                  c.value,
                  d.value,
                  f.value,
                  v.value,
                  g.value,
                  l.value,
                  e.class
                ],
                style: [r.value, u.value, h.value, e.style],
                href: p.href.value,
                onClick: b.value && p.navigate,
                tabindex: e.disabled ? -1 : void 0
              },
              {
                default: () => {
                  var O
                  return [
                    _ &&
                      m('div', { key: 'image', class: 'v-card__image' }, [
                        i.image
                          ? m(
                              vt,
                              {
                                key: 'image-defaults',
                                disabled: !e.image,
                                defaults: { VImg: { cover: !0, src: e.image } }
                              },
                              i.image
                            )
                          : m(fs, { key: 'image-img', cover: !0, src: e.image }, null)
                      ]),
                    m(
                      ah,
                      {
                        name: 'v-card',
                        active: !!e.loading,
                        color: typeof e.loading == 'boolean' ? void 0 : e.loading
                      },
                      { default: i.loader }
                    ),
                    T &&
                      m(
                        Cb,
                        {
                          key: 'item',
                          prependAvatar: e.prependAvatar,
                          prependIcon: e.prependIcon,
                          title: e.title,
                          subtitle: e.subtitle,
                          appendAvatar: e.appendAvatar,
                          appendIcon: e.appendIcon
                        },
                        {
                          default: i.item,
                          prepend: i.prepend,
                          title: i.title,
                          subtitle: i.subtitle,
                          append: i.append
                        }
                      ),
                    B &&
                      m(
                        Mb,
                        { key: 'text' },
                        {
                          default: () => {
                            var N
                            return [((N = i.text) == null ? void 0 : N.call(i)) ?? e.text]
                          }
                        }
                      ),
                    (O = i.default) == null ? void 0 : O.call(i),
                    i.actions && m(wb, null, { default: i.actions }),
                    xs(b.value, 'v-card')
                  ]
                }
              }
            ),
            [[Fn('ripple'), b.value && e.ripple]]
          )
        }),
        {}
      )
    }
  })
const qM = (e) => {
  const { touchstartX: t, touchendX: n, touchstartY: i, touchendY: a } = e,
    s = 0.5,
    o = 16
  ;(e.offsetX = n - t),
    (e.offsetY = a - i),
    Math.abs(e.offsetY) < s * Math.abs(e.offsetX) &&
      (e.left && n < t - o && e.left(e), e.right && n > t + o && e.right(e)),
    Math.abs(e.offsetX) < s * Math.abs(e.offsetY) &&
      (e.up && a < i - o && e.up(e), e.down && a > i + o && e.down(e))
}
function ZM(e, t) {
  var i
  const n = e.changedTouches[0]
  ;(t.touchstartX = n.clientX),
    (t.touchstartY = n.clientY),
    (i = t.start) == null || i.call(t, { originalEvent: e, ...t })
}
function JM(e, t) {
  var i
  const n = e.changedTouches[0]
  ;(t.touchendX = n.clientX),
    (t.touchendY = n.clientY),
    (i = t.end) == null || i.call(t, { originalEvent: e, ...t }),
    qM(t)
}
function QM(e, t) {
  var i
  const n = e.changedTouches[0]
  ;(t.touchmoveX = n.clientX),
    (t.touchmoveY = n.clientY),
    (i = t.move) == null || i.call(t, { originalEvent: e, ...t })
}
function eA() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
  const t = {
    touchstartX: 0,
    touchstartY: 0,
    touchendX: 0,
    touchendY: 0,
    touchmoveX: 0,
    touchmoveY: 0,
    offsetX: 0,
    offsetY: 0,
    left: e.left,
    right: e.right,
    up: e.up,
    down: e.down,
    start: e.start,
    move: e.move,
    end: e.end
  }
  return { touchstart: (n) => ZM(n, t), touchend: (n) => JM(n, t), touchmove: (n) => QM(n, t) }
}
function tA(e, t) {
  var r
  const n = t.value,
    i = n != null && n.parent ? e.parentElement : e,
    a = (n == null ? void 0 : n.options) ?? { passive: !0 },
    s = (r = t.instance) == null ? void 0 : r.$.uid
  if (!i || !s) return
  const o = eA(t.value)
  ;(i._touchHandlers = i._touchHandlers ?? Object.create(null)),
    (i._touchHandlers[s] = o),
    U0(o).forEach((l) => {
      i.addEventListener(l, o[l], a)
    })
}
function nA(e, t) {
  var s, o
  const n = (s = t.value) != null && s.parent ? e.parentElement : e,
    i = (o = t.instance) == null ? void 0 : o.$.uid
  if (!(n != null && n._touchHandlers) || !i) return
  const a = n._touchHandlers[i]
  U0(a).forEach((r) => {
    n.removeEventListener(r, a[r])
  }),
    delete n._touchHandlers[i]
}
const hh = { mounted: tA, unmounted: nA },
  Ab = Symbol.for('vuetify:v-window'),
  Pb = Symbol.for('vuetify:v-window-group'),
  Tb = ee(
    {
      continuous: Boolean,
      nextIcon: { type: [Boolean, String, Function, Object], default: '$next' },
      prevIcon: { type: [Boolean, String, Function, Object], default: '$prev' },
      reverse: Boolean,
      showArrows: { type: [Boolean, String], validator: (e) => typeof e == 'boolean' || e === 'hover' },
      touch: { type: [Object, Boolean], default: void 0 },
      direction: { type: String, default: 'horizontal' },
      modelValue: null,
      disabled: Boolean,
      selectedClass: { type: String, default: 'v-window-item--active' },
      mandatory: { type: [Boolean, String], default: 'force' },
      ...Me(),
      ...Ke(),
      ...ot()
    },
    'VWindow'
  ),
  Td = fe()({
    name: 'VWindow',
    directives: { Touch: hh },
    props: Tb(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = ut(e),
        { isRtl: a } = Qt(),
        { t: s } = Kn(),
        o = Ss(e, Pb),
        r = te(),
        l = A(() => (a.value ? !e.reverse : e.reverse)),
        c = Ce(!1),
        u = A(() => {
          const w = e.direction === 'vertical' ? 'y' : 'x',
            P = (l.value ? !c.value : c.value) ? '-reverse' : ''
          return `v-window-${w}${P}-transition`
        }),
        d = Ce(0),
        f = te(void 0),
        h = A(() => o.items.value.findIndex((w) => o.selected.value.includes(w.id)))
      Pe(h, (w, C) => {
        const P = o.items.value.length,
          k = P - 1
        P <= 2
          ? (c.value = w < C)
          : w === k && C === 0
          ? (c.value = !0)
          : w === 0 && C === k
          ? (c.value = !1)
          : (c.value = w < C)
      }),
        Vt(Ab, { transition: u, isReversed: c, transitionCount: d, transitionHeight: f, rootRef: r })
      const v = A(() => e.continuous || h.value !== 0),
        g = A(() => e.continuous || h.value !== o.items.value.length - 1)
      function p() {
        v.value && o.prev()
      }
      function y() {
        g.value && o.next()
      }
      const b = A(() => {
          const w = [],
            C = {
              icon: a.value ? e.nextIcon : e.prevIcon,
              class: `v-window__${l.value ? 'right' : 'left'}`,
              onClick: o.prev,
              ariaLabel: s('$vuetify.carousel.prev')
            }
          w.push(v.value ? (n.prev ? n.prev({ props: C }) : m(bn, C, null)) : m('div', null, null))
          const P = {
            icon: a.value ? e.prevIcon : e.nextIcon,
            class: `v-window__${l.value ? 'left' : 'right'}`,
            onClick: o.next,
            ariaLabel: s('$vuetify.carousel.next')
          }
          return w.push(g.value ? (n.next ? n.next({ props: P }) : m(bn, P, null)) : m('div', null, null)), w
        }),
        x = A(() =>
          e.touch === !1
            ? e.touch
            : {
                ...{
                  left: () => {
                    l.value ? p() : y()
                  },
                  right: () => {
                    l.value ? y() : p()
                  },
                  start: (C) => {
                    let { originalEvent: P } = C
                    P.stopPropagation()
                  }
                },
                ...(e.touch === !0 ? {} : e.touch)
              }
        )
      return (
        ge(() =>
          Et(
            m(
              e.tag,
              {
                ref: r,
                class: [
                  'v-window',
                  { 'v-window--show-arrows-on-hover': e.showArrows === 'hover' },
                  i.value,
                  e.class
                ],
                style: e.style
              },
              {
                default: () => {
                  var w, C
                  return [
                    m('div', { class: 'v-window__container', style: { height: f.value } }, [
                      (w = n.default) == null ? void 0 : w.call(n, { group: o }),
                      e.showArrows !== !1 && m('div', { class: 'v-window__controls' }, [b.value])
                    ]),
                    (C = n.additional) == null ? void 0 : C.call(n, { group: o })
                  ]
                }
              }
            ),
            [[Fn('touch'), x.value]]
          )
        ),
        { group: o }
      )
    }
  }),
  iA = ee(
    {
      color: String,
      cycle: Boolean,
      delimiterIcon: { type: Ye, default: '$delimiter' },
      height: { type: [Number, String], default: 500 },
      hideDelimiters: Boolean,
      hideDelimiterBackground: Boolean,
      interval: { type: [Number, String], default: 6e3, validator: (e) => Number(e) > 0 },
      progress: [Boolean, String],
      verticalDelimiters: [Boolean, String],
      ...Tb({ continuous: !0, mandatory: 'force', showArrows: !0 })
    },
    'VCarousel'
  ),
  aA = fe()({
    name: 'VCarousel',
    props: iA(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = Ge(e, 'modelValue'),
        { t: a } = Kn(),
        s = te()
      let o = -1
      Pe(i, l),
        Pe(() => e.interval, l),
        Pe(
          () => e.cycle,
          (c) => {
            c ? l() : window.clearTimeout(o)
          }
        ),
        tn(r)
      function r() {
        !e.cycle ||
          !s.value ||
          (o = window.setTimeout(s.value.group.next, +e.interval > 0 ? +e.interval : 6e3))
      }
      function l() {
        window.clearTimeout(o), window.requestAnimationFrame(r)
      }
      return (
        ge(() => {
          const [c] = Td.filterProps(e)
          return m(
            Td,
            xe({ ref: s }, c, {
              modelValue: i.value,
              'onUpdate:modelValue': (u) => (i.value = u),
              class: [
                'v-carousel',
                {
                  'v-carousel--hide-delimiter-background': e.hideDelimiterBackground,
                  'v-carousel--vertical-delimiters': e.verticalDelimiters
                },
                e.class
              ],
              style: [{ height: Ve(e.height) }, e.style]
            }),
            {
              default: n.default,
              additional: (u) => {
                let { group: d } = u
                return m(Oe, null, [
                  !e.hideDelimiters &&
                    m(
                      'div',
                      {
                        class: 'v-carousel__controls',
                        style: {
                          left: e.verticalDelimiters === 'left' && e.verticalDelimiters ? 0 : 'auto',
                          right: e.verticalDelimiters === 'right' ? 0 : 'auto'
                        }
                      },
                      [
                        d.items.value.length > 0 &&
                          m(
                            vt,
                            {
                              defaults: {
                                VBtn: {
                                  color: e.color,
                                  icon: e.delimiterIcon,
                                  size: 'x-small',
                                  variant: 'text'
                                }
                              },
                              scoped: !0
                            },
                            {
                              default: () => [
                                d.items.value.map((f, h) => {
                                  const v = {
                                    id: `carousel-item-${f.id}`,
                                    'aria-label': a(
                                      '$vuetify.carousel.ariaLabel.delimiter',
                                      h + 1,
                                      d.items.value.length
                                    ),
                                    class: [d.isSelected(f.id) && 'v-btn--active'],
                                    onClick: () => d.select(f.id, !0)
                                  }
                                  return n.item ? n.item({ props: v, item: f }) : m(bn, xe(f, v), null)
                                })
                              ]
                            }
                          )
                      ]
                    ),
                  e.progress &&
                    m(
                      nh,
                      {
                        class: 'v-carousel__progress',
                        color: typeof e.progress == 'string' ? e.progress : void 0,
                        modelValue: ((d.getItemIndex(i.value) + 1) / d.items.value.length) * 100
                      },
                      null
                    )
                ])
              },
              prev: n.prev,
              next: n.next
            }
          )
        }),
        {}
      )
    }
  }),
  Vb = ee(
    {
      reverseTransition: { type: [Boolean, String], default: void 0 },
      transition: { type: [Boolean, String], default: void 0 },
      ...Me(),
      ...vo(),
      ...Gc()
    },
    'VWindowItem'
  ),
  Vd = fe()({
    name: 'VWindowItem',
    directives: { Touch: hh },
    props: Vb(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = st(Ab),
        a = go(e, Pb),
        { isBooted: s } = _s()
      if (!i || !a) throw new Error('[Vuetify] VWindowItem must be used inside VWindow')
      const o = Ce(!1),
        r = A(() => s.value && (i.isReversed.value ? e.reverseTransition !== !1 : e.transition !== !1))
      function l() {
        !o.value ||
          !i ||
          ((o.value = !1),
          i.transitionCount.value > 0 &&
            ((i.transitionCount.value -= 1),
            i.transitionCount.value === 0 && (i.transitionHeight.value = void 0)))
      }
      function c() {
        var v
        o.value ||
          !i ||
          ((o.value = !0),
          i.transitionCount.value === 0 &&
            (i.transitionHeight.value = Ve((v = i.rootRef.value) == null ? void 0 : v.clientHeight)),
          (i.transitionCount.value += 1))
      }
      function u() {
        l()
      }
      function d(v) {
        o.value &&
          mt(() => {
            !r.value || !o.value || !i || (i.transitionHeight.value = Ve(v.clientHeight))
          })
      }
      const f = A(() => {
          const v = i.isReversed.value ? e.reverseTransition : e.transition
          return r.value
            ? {
                name: typeof v != 'string' ? i.transition.value : v,
                onBeforeEnter: c,
                onAfterEnter: l,
                onEnterCancelled: u,
                onBeforeLeave: c,
                onAfterLeave: l,
                onLeaveCancelled: u,
                onEnter: d
              }
            : !1
        }),
        { hasContent: h } = ch(e, a.isSelected)
      return (
        ge(() =>
          m(
            ii,
            { transition: f.value, disabled: !s.value },
            {
              default: () => {
                var v
                return [
                  Et(
                    m('div', { class: ['v-window-item', a.selectedClass.value, e.class], style: e.style }, [
                      h.value && ((v = n.default) == null ? void 0 : v.call(n))
                    ]),
                    [[Li, a.isSelected.value]]
                  )
                ]
              }
            }
          )
        ),
        { groupItem: a }
      )
    }
  }),
  sA = ee({ ...Cy(), ...Vb() }, 'VCarouselItem'),
  oA = fe()({
    name: 'VCarouselItem',
    inheritAttrs: !1,
    props: sA(),
    setup(e, t) {
      let { slots: n, attrs: i } = t
      ge(() => {
        const [a] = fs.filterProps(e),
          [s] = Vd.filterProps(e)
        return m(Vd, xe({ class: 'v-carousel-item' }, s), { default: () => [m(fs, xe(i, a), n)] })
      })
    }
  })
const rA = hi('v-code')
const lA = ee(
    {
      color: { type: Object },
      disabled: Boolean,
      dotSize: { type: [Number, String], default: 10 },
      height: { type: [Number, String], default: 150 },
      width: { type: [Number, String], default: 300 },
      ...Me()
    },
    'VColorPickerCanvas'
  ),
  cA = Xn({
    name: 'VColorPickerCanvas',
    props: lA(),
    emits: { 'update:color': (e) => !0, 'update:position': (e) => !0 },
    setup(e, t) {
      let { emit: n } = t
      const i = Ce(!1),
        a = te(),
        s = Ce(parseFloat(e.width)),
        o = Ce(parseFloat(e.height)),
        r = te({ x: 0, y: 0 }),
        l = A({
          get: () => r.value,
          set(p) {
            var x, w
            if (!a.value) return
            const { x: y, y: b } = p
            n('update:color', {
              h: ((x = e.color) == null ? void 0 : x.h) ?? 0,
              s: cn(y, 0, s.value) / s.value,
              v: 1 - cn(b, 0, o.value) / o.value,
              a: ((w = e.color) == null ? void 0 : w.a) ?? 1
            })
          }
        }),
        c = A(() => {
          const { x: p, y } = l.value,
            b = parseInt(e.dotSize, 10) / 2
          return {
            width: Ve(e.dotSize),
            height: Ve(e.dotSize),
            transform: `translate(${Ve(p - b)}, ${Ve(y - b)})`
          }
        }),
        { resizeRef: u } = Ti((p) => {
          var x
          if (!((x = u.value) != null && x.offsetParent)) return
          const { width: y, height: b } = p[0].contentRect
          ;(s.value = y), (o.value = b)
        })
      function d(p, y, b) {
        const { left: x, top: w, width: C, height: P } = b
        l.value = { x: cn(p - x, 0, C), y: cn(y - w, 0, P) }
      }
      function f(p) {
        p.type === 'mousedown' && p.preventDefault(),
          !e.disabled &&
            (h(p),
            window.addEventListener('mousemove', h),
            window.addEventListener('mouseup', v),
            window.addEventListener('touchmove', h),
            window.addEventListener('touchend', v))
      }
      function h(p) {
        if (e.disabled || !a.value) return
        i.value = !0
        const y = ak(p)
        d(y.clientX, y.clientY, a.value.getBoundingClientRect())
      }
      function v() {
        window.removeEventListener('mousemove', h),
          window.removeEventListener('mouseup', v),
          window.removeEventListener('touchmove', h),
          window.removeEventListener('touchend', v)
      }
      function g() {
        var w
        if (!a.value) return
        const p = a.value,
          y = p.getContext('2d')
        if (!y) return
        const b = y.createLinearGradient(0, 0, p.width, 0)
        b.addColorStop(0, 'hsla(0, 0%, 100%, 1)'),
          b.addColorStop(1, `hsla(${((w = e.color) == null ? void 0 : w.h) ?? 0}, 100%, 50%, 1)`),
          (y.fillStyle = b),
          y.fillRect(0, 0, p.width, p.height)
        const x = y.createLinearGradient(0, 0, 0, p.height)
        x.addColorStop(0, 'hsla(0, 0%, 100%, 0)'),
          x.addColorStop(1, 'hsla(0, 0%, 0%, 1)'),
          (y.fillStyle = x),
          y.fillRect(0, 0, p.width, p.height)
      }
      return (
        Pe(
          () => {
            var p
            return (p = e.color) == null ? void 0 : p.h
          },
          g,
          { immediate: !0 }
        ),
        Pe(
          () => [s.value, o.value],
          (p, y) => {
            g(), (r.value = { x: (l.value.x * p[0]) / y[0], y: (l.value.y * p[1]) / y[1] })
          },
          { flush: 'post' }
        ),
        Pe(
          () => e.color,
          () => {
            if (i.value) {
              i.value = !1
              return
            }
            r.value = e.color ? { x: e.color.s * s.value, y: (1 - e.color.v) * o.value } : { x: 0, y: 0 }
          },
          { deep: !0, immediate: !0 }
        ),
        tn(() => g()),
        ge(() =>
          m(
            'div',
            {
              ref: u,
              class: ['v-color-picker-canvas', e.class],
              style: e.style,
              onMousedown: f,
              onTouchstartPassive: f
            },
            [
              m('canvas', { ref: a, width: s.value, height: o.value }, null),
              e.color &&
                m(
                  'div',
                  {
                    class: [
                      'v-color-picker-canvas__dot',
                      { 'v-color-picker-canvas__dot--disabled': e.disabled }
                    ],
                    style: c.value
                  },
                  null
                )
            ]
          )
        ),
        {}
      )
    }
  })
function uA(e, t) {
  if (t) {
    const { a: n, ...i } = e
    return i
  }
  return e
}
function dA(e, t) {
  if (t == null || typeof t == 'string') {
    const n = oy(e)
    return e.a === 1 ? n.slice(0, 7) : n
  }
  if (typeof t == 'object') {
    let n
    return (
      ts(t, ['r', 'g', 'b'])
        ? (n = Ji(e))
        : ts(t, ['h', 's', 'l'])
        ? (n = ty(e))
        : ts(t, ['h', 's', 'v']) && (n = e),
      uA(n, !ts(t, ['a']) && e.a === 1)
    )
  }
  return e
}
const tr = { h: 0, s: 0, v: 1, a: 1 },
  Ed = {
    inputProps: { type: 'number', min: 0 },
    inputs: [
      {
        label: 'R',
        max: 255,
        step: 1,
        getValue: (e) => Math.round(e.r),
        getColor: (e, t) => ({ ...e, r: Number(t) })
      },
      {
        label: 'G',
        max: 255,
        step: 1,
        getValue: (e) => Math.round(e.g),
        getColor: (e, t) => ({ ...e, g: Number(t) })
      },
      {
        label: 'B',
        max: 255,
        step: 1,
        getValue: (e) => Math.round(e.b),
        getColor: (e, t) => ({ ...e, b: Number(t) })
      },
      {
        label: 'A',
        max: 1,
        step: 0.01,
        getValue: (e) => {
          let { a: t } = e
          return t != null ? Math.round(t * 100) / 100 : 1
        },
        getColor: (e, t) => ({ ...e, a: Number(t) })
      }
    ],
    to: Ji,
    from: Rc
  }
var Rp
const fA = { ...Ed, inputs: (Rp = Ed.inputs) == null ? void 0 : Rp.slice(0, 3) },
  Ld = {
    inputProps: { type: 'number', min: 0 },
    inputs: [
      {
        label: 'H',
        max: 360,
        step: 1,
        getValue: (e) => Math.round(e.h),
        getColor: (e, t) => ({ ...e, h: Number(t) })
      },
      {
        label: 'S',
        max: 1,
        step: 0.01,
        getValue: (e) => Math.round(e.s * 100) / 100,
        getColor: (e, t) => ({ ...e, s: Number(t) })
      },
      {
        label: 'L',
        max: 1,
        step: 0.01,
        getValue: (e) => Math.round(e.l * 100) / 100,
        getColor: (e, t) => ({ ...e, l: Number(t) })
      },
      {
        label: 'A',
        max: 1,
        step: 0.01,
        getValue: (e) => {
          let { a: t } = e
          return t != null ? Math.round(t * 100) / 100 : 1
        },
        getColor: (e, t) => ({ ...e, a: Number(t) })
      }
    ],
    to: ty,
    from: Hf
  },
  hA = { ...Ld, inputs: Ld.inputs.slice(0, 3) },
  Eb = {
    inputProps: { type: 'text' },
    inputs: [{ label: 'HEXA', getValue: (e) => e, getColor: (e, t) => t }],
    to: oy,
    from: Sk
  },
  vA = { ...Eb, inputs: [{ label: 'HEX', getValue: (e) => e.slice(0, 7), getColor: (e, t) => t }] },
  ls = { rgb: fA, rgba: Ed, hsl: hA, hsla: Ld, hex: vA, hexa: Eb },
  gA = (e) => {
    let { label: t, ...n } = e
    return m('div', { class: 'v-color-picker-edit__input' }, [m('input', n, null), m('span', null, [t])])
  },
  mA = ee(
    {
      color: Object,
      disabled: Boolean,
      mode: { type: String, default: 'rgba', validator: (e) => Object.keys(ls).includes(e) },
      modes: {
        type: Array,
        default: () => Object.keys(ls),
        validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(ls).includes(t))
      },
      ...Me()
    },
    'VColorPickerEdit'
  ),
  pA = Xn({
    name: 'VColorPickerEdit',
    props: mA(),
    emits: { 'update:color': (e) => !0, 'update:mode': (e) => !0 },
    setup(e, t) {
      let { emit: n } = t
      const i = A(() => e.modes.map((s) => ({ ...ls[s], name: s }))),
        a = A(() => {
          var r
          const s = i.value.find((l) => l.name === e.mode)
          if (!s) return []
          const o = e.color ? s.to(e.color) : null
          return (r = s.inputs) == null
            ? void 0
            : r.map((l) => {
                let { getValue: c, getColor: u, ...d } = l
                return {
                  ...s.inputProps,
                  ...d,
                  disabled: e.disabled,
                  value: o && c(o),
                  onChange: (f) => {
                    const h = f.target
                    h && n('update:color', s.from(u(o ?? tr, h.value)))
                  }
                }
              })
        })
      return (
        ge(() => {
          var s
          return m('div', { class: ['v-color-picker-edit', e.class], style: e.style }, [
            (s = a.value) == null ? void 0 : s.map((o) => m(gA, o, null)),
            i.value.length > 1 &&
              m(
                bn,
                {
                  icon: '$unfold',
                  size: 'x-small',
                  variant: 'plain',
                  onClick: () => {
                    const o = i.value.findIndex((r) => r.name === e.mode)
                    n('update:mode', i.value[(o + 1) % i.value.length].name)
                  }
                },
                null
              )
          ])
        }),
        {}
      )
    }
  })
const vh = Symbol.for('vuetify:v-slider')
function Od(e, t, n) {
  const i = n === 'vertical',
    a = t.getBoundingClientRect(),
    s = 'touches' in e ? e.touches[0] : e
  return i ? s.clientY - (a.top + a.height / 2) : s.clientX - (a.left + a.width / 2)
}
function yA(e, t) {
  return 'touches' in e && e.touches.length
    ? e.touches[0][t]
    : 'changedTouches' in e && e.changedTouches.length
    ? e.changedTouches[0][t]
    : e[t]
}
const Lb = ee(
    {
      disabled: { type: Boolean, default: null },
      error: Boolean,
      readonly: { type: Boolean, default: null },
      max: { type: [Number, String], default: 100 },
      min: { type: [Number, String], default: 0 },
      step: { type: [Number, String], default: 0 },
      thumbColor: String,
      thumbLabel: {
        type: [Boolean, String],
        default: void 0,
        validator: (e) => typeof e == 'boolean' || e === 'always'
      },
      thumbSize: { type: [Number, String], default: 20 },
      showTicks: {
        type: [Boolean, String],
        default: !1,
        validator: (e) => typeof e == 'boolean' || e === 'always'
      },
      ticks: { type: [Array, Object] },
      tickSize: { type: [Number, String], default: 2 },
      color: String,
      trackColor: String,
      trackFillColor: String,
      trackSize: { type: [Number, String], default: 4 },
      direction: {
        type: String,
        default: 'horizontal',
        validator: (e) => ['vertical', 'horizontal'].includes(e)
      },
      reverse: Boolean,
      ...kt(),
      ...Yt({ elevation: 2 })
    },
    'Slider'
  ),
  Ob = (e) => {
    const t = A(() => parseFloat(e.min)),
      n = A(() => parseFloat(e.max)),
      i = A(() => (+e.step > 0 ? parseFloat(e.step) : 0)),
      a = A(() => Math.max(Lv(i.value), Lv(t.value)))
    function s(o) {
      if (((o = parseFloat(o)), i.value <= 0)) return o
      const r = cn(o, t.value, n.value),
        l = t.value % i.value,
        c = Math.round((r - l) / i.value) * i.value + l
      return parseFloat(Math.min(c, n.value).toFixed(a.value))
    }
    return { min: t, max: n, step: i, decimals: a, roundValue: s }
  },
  Ib = (e) => {
    let { props: t, steps: n, onSliderStart: i, onSliderMove: a, onSliderEnd: s, getActiveThumb: o } = e
    const { isRtl: r } = Qt(),
      l = ve(t, 'reverse'),
      c = A(() => {
        let ie = r.value ? 'rtl' : 'ltr'
        return t.reverse && (ie = ie === 'rtl' ? 'ltr' : 'rtl'), ie
      }),
      { min: u, max: d, step: f, decimals: h, roundValue: v } = n,
      g = A(() => parseInt(t.thumbSize, 10)),
      p = A(() => parseInt(t.tickSize, 10)),
      y = A(() => parseInt(t.trackSize, 10)),
      b = A(() => (d.value - u.value) / f.value),
      x = ve(t, 'disabled'),
      w = A(() => t.direction === 'vertical'),
      C = A(() => (t.error || t.disabled ? void 0 : t.thumbColor ?? t.color)),
      P = A(() => (t.error || t.disabled ? void 0 : t.trackColor ?? t.color)),
      k = A(() => (t.error || t.disabled ? void 0 : t.trackFillColor ?? t.color)),
      S = Ce(!1),
      _ = Ce(0),
      T = te(),
      B = te()
    function O(ie) {
      var Z
      const Y = t.direction === 'vertical',
        ne = Y ? 'top' : 'left',
        W = Y ? 'height' : 'width',
        le = Y ? 'clientY' : 'clientX',
        { [ne]: De, [W]: L } = (Z = T.value) == null ? void 0 : Z.$el.getBoundingClientRect(),
        D = yA(ie, le)
      let H = Math.min(Math.max((D - De - _.value) / L, 0), 1) || 0
      return (Y || c.value === 'rtl') && (H = 1 - H), v(u.value + H * (d.value - u.value))
    }
    const N = (ie) => {
        s({ value: O(ie) }), (S.value = !1), (_.value = 0)
      },
      Q = (ie) => {
        ;(B.value = o(ie)),
          B.value &&
            (B.value.focus(),
            (S.value = !0),
            B.value.contains(ie.target)
              ? (_.value = Od(ie, B.value, t.direction))
              : ((_.value = 0), a({ value: O(ie) })),
            i({ value: O(ie) }))
      },
      ue = { passive: !0, capture: !0 }
    function j(ie) {
      a({ value: O(ie) })
    }
    function U(ie) {
      ie.stopPropagation(),
        ie.preventDefault(),
        N(ie),
        window.removeEventListener('mousemove', j, ue),
        window.removeEventListener('mouseup', U)
    }
    function X(ie) {
      var Y
      N(ie),
        window.removeEventListener('touchmove', j, ue),
        (Y = ie.target) == null || Y.removeEventListener('touchend', X)
    }
    function oe(ie) {
      var Y
      Q(ie),
        window.addEventListener('touchmove', j, ue),
        (Y = ie.target) == null || Y.addEventListener('touchend', X, { passive: !1 })
    }
    function de(ie) {
      ie.preventDefault(),
        Q(ie),
        window.addEventListener('mousemove', j, ue),
        window.addEventListener('mouseup', U, { passive: !1 })
    }
    const ce = (ie) => {
        const Y = ((ie - u.value) / (d.value - u.value)) * 100
        return cn(isNaN(Y) ? 0 : Y, 0, 100)
      },
      Te = ve(t, 'showTicks'),
      $e = A(() =>
        Te.value
          ? t.ticks
            ? Array.isArray(t.ticks)
              ? t.ticks.map((ie) => ({ value: ie, position: ce(ie), label: ie.toString() }))
              : Object.keys(t.ticks).map((ie) => ({
                  value: parseFloat(ie),
                  position: ce(parseFloat(ie)),
                  label: t.ticks[ie]
                }))
            : b.value !== 1 / 0
            ? ji(b.value + 1).map((ie) => {
                const Y = u.value + ie * f.value
                return { value: Y, position: ce(Y) }
              })
            : []
          : []
      ),
      He = A(() =>
        $e.value.some((ie) => {
          let { label: Y } = ie
          return !!Y
        })
      ),
      Ue = {
        activeThumbRef: B,
        color: ve(t, 'color'),
        decimals: h,
        disabled: x,
        direction: ve(t, 'direction'),
        elevation: ve(t, 'elevation'),
        hasLabels: He,
        horizontalDirection: c,
        isReversed: l,
        min: u,
        max: d,
        mousePressed: S,
        numTicks: b,
        onSliderMousedown: de,
        onSliderTouchstart: oe,
        parsedTicks: $e,
        parseMouseMove: O,
        position: ce,
        readonly: ve(t, 'readonly'),
        rounded: ve(t, 'rounded'),
        roundValue: v,
        showTicks: Te,
        startOffset: _,
        step: f,
        thumbSize: g,
        thumbColor: C,
        thumbLabel: ve(t, 'thumbLabel'),
        ticks: ve(t, 'ticks'),
        tickSize: p,
        trackColor: P,
        trackContainerRef: T,
        trackFillColor: k,
        trackSize: y,
        vertical: w
      }
    return Vt(vh, Ue), Ue
  },
  bA = ee(
    {
      focused: Boolean,
      max: { type: Number, required: !0 },
      min: { type: Number, required: !0 },
      modelValue: { type: Number, required: !0 },
      position: { type: Number, required: !0 },
      ripple: { type: [Boolean, Object], default: !0 },
      ...Me()
    },
    'VSliderThumb'
  ),
  Id = fe()({
    name: 'VSliderThumb',
    directives: { Ripple: Da },
    props: bA(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n, emit: i } = t
      const a = st(vh),
        { rtlClasses: s } = Qt()
      if (!a) throw new Error('[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider')
      const {
          thumbColor: o,
          step: r,
          vertical: l,
          disabled: c,
          thumbSize: u,
          thumbLabel: d,
          direction: f,
          readonly: h,
          elevation: v,
          isReversed: g,
          horizontalDirection: p,
          mousePressed: y,
          decimals: b
        } = a,
        { textColorClasses: x, textColorStyles: w } = dn(o),
        { pageup: C, pagedown: P, end: k, home: S, left: _, right: T, down: B, up: O } = cd,
        N = [C, P, k, S, _, T, B, O],
        Q = A(() => (r.value ? [1, 2, 3] : [1, 5, 10]))
      function ue(U, X) {
        if (!N.includes(U.key)) return
        U.preventDefault()
        const oe = r.value || 0.1,
          de = (e.max - e.min) / oe
        if ([_, T, B, O].includes(U.key)) {
          const Te = (p.value === 'rtl' ? [_, O] : [T, O]).includes(U.key) ? 1 : -1,
            $e = U.shiftKey ? 2 : U.ctrlKey ? 1 : 0
          X = X + Te * oe * Q.value[$e]
        } else if (U.key === S) X = e.min
        else if (U.key === k) X = e.max
        else {
          const ce = U.key === P ? 1 : -1
          X = X - ce * oe * (de > 100 ? de / 10 : 10)
        }
        return Math.max(e.min, Math.min(e.max, X))
      }
      function j(U) {
        const X = ue(U, e.modelValue)
        X != null && i('update:modelValue', X)
      }
      return (
        ge(() => {
          const U = Ve(l.value || g.value ? 100 - e.position : e.position, '%'),
            { elevationClasses: X } = nn(A(() => (c.value ? void 0 : v.value)))
          return m(
            'div',
            {
              class: [
                'v-slider-thumb',
                { 'v-slider-thumb--focused': e.focused, 'v-slider-thumb--pressed': e.focused && y.value },
                e.class,
                s.value
              ],
              style: [{ '--v-slider-thumb-position': U, '--v-slider-thumb-size': Ve(u.value) }, e.style],
              role: 'slider',
              tabindex: c.value ? -1 : 0,
              'aria-valuemin': e.min,
              'aria-valuemax': e.max,
              'aria-valuenow': e.modelValue,
              'aria-readonly': !!h.value,
              'aria-orientation': f.value,
              onKeydown: h.value ? void 0 : j
            },
            [
              m('div', { class: ['v-slider-thumb__surface', x.value, X.value], style: { ...w.value } }, null),
              Et(m('div', { class: ['v-slider-thumb__ripple', x.value], style: w.value }, null), [
                [Fn('ripple'), e.ripple, null, { circle: !0, center: !0 }]
              ]),
              m(
                Kf,
                { origin: 'bottom center' },
                {
                  default: () => {
                    var oe
                    return [
                      Et(
                        m('div', { class: 'v-slider-thumb__label-container' }, [
                          m('div', { class: ['v-slider-thumb__label'] }, [
                            m('div', null, [
                              ((oe = n['thumb-label']) == null
                                ? void 0
                                : oe.call(n, { modelValue: e.modelValue })) ??
                                e.modelValue.toFixed(r.value ? b.value : 1)
                            ])
                          ])
                        ]),
                        [[Li, (d.value && e.focused) || d.value === 'always']]
                      )
                    ]
                  }
                }
              )
            ]
          )
        }),
        {}
      )
    }
  })
const _A = ee(
    { start: { type: Number, required: !0 }, stop: { type: Number, required: !0 }, ...Me() },
    'VSliderTrack'
  ),
  Db = fe()({
    name: 'VSliderTrack',
    props: _A(),
    emits: {},
    setup(e, t) {
      let { slots: n } = t
      const i = st(vh)
      if (!i) throw new Error('[Vuetify] v-slider-track must be inside v-slider or v-range-slider')
      const {
          color: a,
          horizontalDirection: s,
          parsedTicks: o,
          rounded: r,
          showTicks: l,
          tickSize: c,
          trackColor: u,
          trackFillColor: d,
          trackSize: f,
          vertical: h,
          min: v,
          max: g
        } = i,
        { roundedClasses: p } = Lt(r),
        { backgroundColorClasses: y, backgroundColorStyles: b } = Rt(d),
        { backgroundColorClasses: x, backgroundColorStyles: w } = Rt(u),
        C = A(() => `inset-${h.value ? 'block-end' : 'inline-start'}`),
        P = A(() => (h.value ? 'height' : 'width')),
        k = A(() => ({ [C.value]: '0%', [P.value]: '100%' })),
        S = A(() => e.stop - e.start),
        _ = A(() => ({ [C.value]: Ve(e.start, '%'), [P.value]: Ve(S.value, '%') })),
        T = A(() =>
          l.value
            ? (h.value ? o.value.slice().reverse() : o.value).map((O, N) => {
                var j
                const Q = h.value ? 'bottom' : 'margin-inline-start',
                  ue = O.value !== v.value && O.value !== g.value ? Ve(O.position, '%') : void 0
                return m(
                  'div',
                  {
                    key: O.value,
                    class: [
                      'v-slider-track__tick',
                      {
                        'v-slider-track__tick--filled': O.position >= e.start && O.position <= e.stop,
                        'v-slider-track__tick--first': O.value === v.value,
                        'v-slider-track__tick--last': O.value === g.value
                      }
                    ],
                    style: { [Q]: ue }
                  },
                  [
                    (O.label || n['tick-label']) &&
                      m('div', { class: 'v-slider-track__tick-label' }, [
                        ((j = n['tick-label']) == null ? void 0 : j.call(n, { tick: O, index: N })) ?? O.label
                      ])
                  ]
                )
              })
            : []
        )
      return (
        ge(() =>
          m(
            'div',
            {
              class: ['v-slider-track', p.value, e.class],
              style: [
                {
                  '--v-slider-track-size': Ve(f.value),
                  '--v-slider-tick-size': Ve(c.value),
                  direction: h.value ? void 0 : s.value
                },
                e.style
              ]
            },
            [
              m(
                'div',
                {
                  class: [
                    'v-slider-track__background',
                    x.value,
                    { 'v-slider-track__background--opacity': !!a.value || !d.value }
                  ],
                  style: { ...k.value, ...w.value }
                },
                null
              ),
              m('div', { class: ['v-slider-track__fill', y.value], style: { ..._.value, ...b.value } }, null),
              l.value &&
                m(
                  'div',
                  {
                    class: [
                      'v-slider-track__ticks',
                      { 'v-slider-track__ticks--always-show': l.value === 'always' }
                    ]
                  },
                  [T.value]
                )
            ]
          )
        ),
        {}
      )
    }
  }),
  xA = ee({ ...jc(), ...Lb(), ...ra(), modelValue: { type: [Number, String], default: 0 } }, 'VSlider'),
  Dd = fe()({
    name: 'VSlider',
    props: xA(),
    emits: { 'update:focused': (e) => !0, 'update:modelValue': (e) => !0, start: (e) => !0, end: (e) => !0 },
    setup(e, t) {
      let { slots: n, emit: i } = t
      const a = te(),
        { rtlClasses: s } = Qt(),
        o = Ob(e),
        r = Ge(e, 'modelValue', void 0, (P) => o.roundValue(P ?? o.min.value)),
        {
          min: l,
          max: c,
          mousePressed: u,
          roundValue: d,
          onSliderMousedown: f,
          onSliderTouchstart: h,
          trackContainerRef: v,
          position: g,
          hasLabels: p,
          readonly: y
        } = Ib({
          props: e,
          steps: o,
          onSliderStart: () => {
            i('start', r.value)
          },
          onSliderEnd: (P) => {
            let { value: k } = P
            const S = d(k)
            ;(r.value = S), i('end', S)
          },
          onSliderMove: (P) => {
            let { value: k } = P
            return (r.value = d(k))
          },
          getActiveThumb: () => {
            var P
            return (P = a.value) == null ? void 0 : P.$el
          }
        }),
        { isFocused: b, focus: x, blur: w } = Fa(e),
        C = A(() => g(r.value))
      return (
        ge(() => {
          const [P, k] = en.filterProps(e),
            S = !!(e.label || n.label || n.prepend)
          return m(
            en,
            xe(
              {
                class: [
                  'v-slider',
                  {
                    'v-slider--has-labels': !!n['tick-label'] || p.value,
                    'v-slider--focused': b.value,
                    'v-slider--pressed': u.value,
                    'v-slider--disabled': e.disabled
                  },
                  s.value,
                  e.class
                ],
                style: e.style
              },
              P,
              { focused: b.value }
            ),
            {
              ...n,
              prepend: S
                ? (_) => {
                    var T, B
                    return m(Oe, null, [
                      ((T = n.label) == null ? void 0 : T.call(n, _)) ??
                        (e.label
                          ? m(bo, { id: _.id.value, class: 'v-slider__label', text: e.label }, null)
                          : void 0),
                      (B = n.prepend) == null ? void 0 : B.call(n, _)
                    ])
                  }
                : void 0,
              default: (_) => {
                let { id: T, messagesId: B } = _
                return m(
                  'div',
                  {
                    class: 'v-slider__container',
                    onMousedown: y.value ? void 0 : f,
                    onTouchstartPassive: y.value ? void 0 : h
                  },
                  [
                    m(
                      'input',
                      {
                        id: T.value,
                        name: e.name || T.value,
                        disabled: !!e.disabled,
                        readonly: !!e.readonly,
                        tabindex: '-1',
                        value: r.value
                      },
                      null
                    ),
                    m(Db, { ref: v, start: 0, stop: C.value }, { 'tick-label': n['tick-label'] }),
                    m(
                      Id,
                      {
                        ref: a,
                        'aria-describedby': B.value,
                        focused: b.value,
                        min: l.value,
                        max: c.value,
                        modelValue: r.value,
                        'onUpdate:modelValue': (O) => (r.value = O),
                        position: C.value,
                        elevation: e.elevation,
                        onFocus: x,
                        onBlur: w
                      },
                      { 'thumb-label': n['thumb-label'] }
                    )
                  ]
                )
              }
            }
          )
        }),
        {}
      )
    }
  }),
  wA = ee({ color: { type: Object }, disabled: Boolean, hideAlpha: Boolean, ...Me() }, 'VColorPickerPreview'),
  SA = Xn({
    name: 'VColorPickerPreview',
    props: wA(),
    emits: { 'update:color': (e) => !0 },
    setup(e, t) {
      let { emit: n } = t
      return (
        ge(() => {
          var i, a
          return m(
            'div',
            {
              class: [
                'v-color-picker-preview',
                { 'v-color-picker-preview--hide-alpha': e.hideAlpha },
                e.class
              ],
              style: e.style
            },
            [
              m('div', { class: 'v-color-picker-preview__dot' }, [
                m('div', { style: { background: iy(e.color ?? tr) } }, null)
              ]),
              m('div', { class: 'v-color-picker-preview__sliders' }, [
                m(
                  Dd,
                  {
                    class: 'v-color-picker-preview__track v-color-picker-preview__hue',
                    modelValue: (i = e.color) == null ? void 0 : i.h,
                    'onUpdate:modelValue': (s) => n('update:color', { ...(e.color ?? tr), h: s }),
                    step: 0,
                    min: 0,
                    max: 360,
                    disabled: e.disabled,
                    thumbSize: 14,
                    trackSize: 8,
                    trackFillColor: 'white',
                    hideDetails: !0
                  },
                  null
                ),
                !e.hideAlpha &&
                  m(
                    Dd,
                    {
                      class: 'v-color-picker-preview__track v-color-picker-preview__alpha',
                      modelValue: ((a = e.color) == null ? void 0 : a.a) ?? 1,
                      'onUpdate:modelValue': (s) => n('update:color', { ...(e.color ?? tr), a: s }),
                      step: 1 / 256,
                      min: 0,
                      max: 1,
                      disabled: e.disabled,
                      thumbSize: 14,
                      trackSize: 8,
                      trackFillColor: 'white',
                      hideDetails: !0
                    },
                    null
                  )
              ])
            ]
          )
        }),
        {}
      )
    }
  })
const kA = Object.freeze({
    base: '#f44336',
    lighten5: '#ffebee',
    lighten4: '#ffcdd2',
    lighten3: '#ef9a9a',
    lighten2: '#e57373',
    lighten1: '#ef5350',
    darken1: '#e53935',
    darken2: '#d32f2f',
    darken3: '#c62828',
    darken4: '#b71c1c',
    accent1: '#ff8a80',
    accent2: '#ff5252',
    accent3: '#ff1744',
    accent4: '#d50000'
  }),
  CA = Object.freeze({
    base: '#e91e63',
    lighten5: '#fce4ec',
    lighten4: '#f8bbd0',
    lighten3: '#f48fb1',
    lighten2: '#f06292',
    lighten1: '#ec407a',
    darken1: '#d81b60',
    darken2: '#c2185b',
    darken3: '#ad1457',
    darken4: '#880e4f',
    accent1: '#ff80ab',
    accent2: '#ff4081',
    accent3: '#f50057',
    accent4: '#c51162'
  }),
  MA = Object.freeze({
    base: '#9c27b0',
    lighten5: '#f3e5f5',
    lighten4: '#e1bee7',
    lighten3: '#ce93d8',
    lighten2: '#ba68c8',
    lighten1: '#ab47bc',
    darken1: '#8e24aa',
    darken2: '#7b1fa2',
    darken3: '#6a1b9a',
    darken4: '#4a148c',
    accent1: '#ea80fc',
    accent2: '#e040fb',
    accent3: '#d500f9',
    accent4: '#aa00ff'
  }),
  AA = Object.freeze({
    base: '#673ab7',
    lighten5: '#ede7f6',
    lighten4: '#d1c4e9',
    lighten3: '#b39ddb',
    lighten2: '#9575cd',
    lighten1: '#7e57c2',
    darken1: '#5e35b1',
    darken2: '#512da8',
    darken3: '#4527a0',
    darken4: '#311b92',
    accent1: '#b388ff',
    accent2: '#7c4dff',
    accent3: '#651fff',
    accent4: '#6200ea'
  }),
  PA = Object.freeze({
    base: '#3f51b5',
    lighten5: '#e8eaf6',
    lighten4: '#c5cae9',
    lighten3: '#9fa8da',
    lighten2: '#7986cb',
    lighten1: '#5c6bc0',
    darken1: '#3949ab',
    darken2: '#303f9f',
    darken3: '#283593',
    darken4: '#1a237e',
    accent1: '#8c9eff',
    accent2: '#536dfe',
    accent3: '#3d5afe',
    accent4: '#304ffe'
  }),
  TA = Object.freeze({
    base: '#2196f3',
    lighten5: '#e3f2fd',
    lighten4: '#bbdefb',
    lighten3: '#90caf9',
    lighten2: '#64b5f6',
    lighten1: '#42a5f5',
    darken1: '#1e88e5',
    darken2: '#1976d2',
    darken3: '#1565c0',
    darken4: '#0d47a1',
    accent1: '#82b1ff',
    accent2: '#448aff',
    accent3: '#2979ff',
    accent4: '#2962ff'
  }),
  VA = Object.freeze({
    base: '#03a9f4',
    lighten5: '#e1f5fe',
    lighten4: '#b3e5fc',
    lighten3: '#81d4fa',
    lighten2: '#4fc3f7',
    lighten1: '#29b6f6',
    darken1: '#039be5',
    darken2: '#0288d1',
    darken3: '#0277bd',
    darken4: '#01579b',
    accent1: '#80d8ff',
    accent2: '#40c4ff',
    accent3: '#00b0ff',
    accent4: '#0091ea'
  }),
  EA = Object.freeze({
    base: '#00bcd4',
    lighten5: '#e0f7fa',
    lighten4: '#b2ebf2',
    lighten3: '#80deea',
    lighten2: '#4dd0e1',
    lighten1: '#26c6da',
    darken1: '#00acc1',
    darken2: '#0097a7',
    darken3: '#00838f',
    darken4: '#006064',
    accent1: '#84ffff',
    accent2: '#18ffff',
    accent3: '#00e5ff',
    accent4: '#00b8d4'
  }),
  LA = Object.freeze({
    base: '#009688',
    lighten5: '#e0f2f1',
    lighten4: '#b2dfdb',
    lighten3: '#80cbc4',
    lighten2: '#4db6ac',
    lighten1: '#26a69a',
    darken1: '#00897b',
    darken2: '#00796b',
    darken3: '#00695c',
    darken4: '#004d40',
    accent1: '#a7ffeb',
    accent2: '#64ffda',
    accent3: '#1de9b6',
    accent4: '#00bfa5'
  }),
  OA = Object.freeze({
    base: '#4caf50',
    lighten5: '#e8f5e9',
    lighten4: '#c8e6c9',
    lighten3: '#a5d6a7',
    lighten2: '#81c784',
    lighten1: '#66bb6a',
    darken1: '#43a047',
    darken2: '#388e3c',
    darken3: '#2e7d32',
    darken4: '#1b5e20',
    accent1: '#b9f6ca',
    accent2: '#69f0ae',
    accent3: '#00e676',
    accent4: '#00c853'
  }),
  IA = Object.freeze({
    base: '#8bc34a',
    lighten5: '#f1f8e9',
    lighten4: '#dcedc8',
    lighten3: '#c5e1a5',
    lighten2: '#aed581',
    lighten1: '#9ccc65',
    darken1: '#7cb342',
    darken2: '#689f38',
    darken3: '#558b2f',
    darken4: '#33691e',
    accent1: '#ccff90',
    accent2: '#b2ff59',
    accent3: '#76ff03',
    accent4: '#64dd17'
  }),
  DA = Object.freeze({
    base: '#cddc39',
    lighten5: '#f9fbe7',
    lighten4: '#f0f4c3',
    lighten3: '#e6ee9c',
    lighten2: '#dce775',
    lighten1: '#d4e157',
    darken1: '#c0ca33',
    darken2: '#afb42b',
    darken3: '#9e9d24',
    darken4: '#827717',
    accent1: '#f4ff81',
    accent2: '#eeff41',
    accent3: '#c6ff00',
    accent4: '#aeea00'
  }),
  FA = Object.freeze({
    base: '#ffeb3b',
    lighten5: '#fffde7',
    lighten4: '#fff9c4',
    lighten3: '#fff59d',
    lighten2: '#fff176',
    lighten1: '#ffee58',
    darken1: '#fdd835',
    darken2: '#fbc02d',
    darken3: '#f9a825',
    darken4: '#f57f17',
    accent1: '#ffff8d',
    accent2: '#ffff00',
    accent3: '#ffea00',
    accent4: '#ffd600'
  }),
  RA = Object.freeze({
    base: '#ffc107',
    lighten5: '#fff8e1',
    lighten4: '#ffecb3',
    lighten3: '#ffe082',
    lighten2: '#ffd54f',
    lighten1: '#ffca28',
    darken1: '#ffb300',
    darken2: '#ffa000',
    darken3: '#ff8f00',
    darken4: '#ff6f00',
    accent1: '#ffe57f',
    accent2: '#ffd740',
    accent3: '#ffc400',
    accent4: '#ffab00'
  }),
  BA = Object.freeze({
    base: '#ff9800',
    lighten5: '#fff3e0',
    lighten4: '#ffe0b2',
    lighten3: '#ffcc80',
    lighten2: '#ffb74d',
    lighten1: '#ffa726',
    darken1: '#fb8c00',
    darken2: '#f57c00',
    darken3: '#ef6c00',
    darken4: '#e65100',
    accent1: '#ffd180',
    accent2: '#ffab40',
    accent3: '#ff9100',
    accent4: '#ff6d00'
  }),
  NA = Object.freeze({
    base: '#ff5722',
    lighten5: '#fbe9e7',
    lighten4: '#ffccbc',
    lighten3: '#ffab91',
    lighten2: '#ff8a65',
    lighten1: '#ff7043',
    darken1: '#f4511e',
    darken2: '#e64a19',
    darken3: '#d84315',
    darken4: '#bf360c',
    accent1: '#ff9e80',
    accent2: '#ff6e40',
    accent3: '#ff3d00',
    accent4: '#dd2c00'
  }),
  $A = Object.freeze({
    base: '#795548',
    lighten5: '#efebe9',
    lighten4: '#d7ccc8',
    lighten3: '#bcaaa4',
    lighten2: '#a1887f',
    lighten1: '#8d6e63',
    darken1: '#6d4c41',
    darken2: '#5d4037',
    darken3: '#4e342e',
    darken4: '#3e2723'
  }),
  zA = Object.freeze({
    base: '#607d8b',
    lighten5: '#eceff1',
    lighten4: '#cfd8dc',
    lighten3: '#b0bec5',
    lighten2: '#90a4ae',
    lighten1: '#78909c',
    darken1: '#546e7a',
    darken2: '#455a64',
    darken3: '#37474f',
    darken4: '#263238'
  }),
  HA = Object.freeze({
    base: '#9e9e9e',
    lighten5: '#fafafa',
    lighten4: '#f5f5f5',
    lighten3: '#eeeeee',
    lighten2: '#e0e0e0',
    lighten1: '#bdbdbd',
    darken1: '#757575',
    darken2: '#616161',
    darken3: '#424242',
    darken4: '#212121'
  }),
  WA = Object.freeze({ black: '#000000', white: '#ffffff', transparent: '#ffffff00' }),
  jA = Object.freeze({
    red: kA,
    pink: CA,
    purple: MA,
    deepPurple: AA,
    indigo: PA,
    blue: TA,
    lightBlue: VA,
    cyan: EA,
    teal: LA,
    green: OA,
    lightGreen: IA,
    lime: DA,
    yellow: FA,
    amber: RA,
    orange: BA,
    deepOrange: NA,
    brown: $A,
    blueGrey: zA,
    grey: HA,
    shades: WA
  }),
  UA = ee(
    {
      swatches: { type: Array, default: () => YA(jA) },
      disabled: Boolean,
      color: Object,
      maxHeight: [Number, String],
      ...Me()
    },
    'VColorPickerSwatches'
  )
function YA(e) {
  return Object.keys(e).map((t) => {
    const n = e[t]
    return n.base
      ? [
          n.base,
          n.darken4,
          n.darken3,
          n.darken2,
          n.darken1,
          n.lighten1,
          n.lighten2,
          n.lighten3,
          n.lighten4,
          n.lighten5
        ]
      : [n.black, n.white, n.transparent]
  })
}
const GA = Xn({
  name: 'VColorPickerSwatches',
  props: UA(),
  emits: { 'update:color': (e) => !0 },
  setup(e, t) {
    let { emit: n } = t
    return (
      ge(() =>
        m(
          'div',
          { class: ['v-color-picker-swatches', e.class], style: [{ maxHeight: Ve(e.maxHeight) }, e.style] },
          [
            m('div', null, [
              e.swatches.map((i) =>
                m('div', { class: 'v-color-picker-swatches__swatch' }, [
                  i.map((a) => {
                    const s = jn(a),
                      o = Rc(s),
                      r = ny(s)
                    return m(
                      'div',
                      { class: 'v-color-picker-swatches__color', onClick: () => o && n('update:color', o) },
                      [
                        m('div', { style: { background: r } }, [
                          e.color && co(e.color, o)
                            ? m(
                                gt,
                                {
                                  size: 'x-small',
                                  icon: '$success',
                                  color: Ak(a, '#FFFFFF') > 2 ? 'white' : 'black'
                                },
                                null
                              )
                            : void 0
                        ])
                      ]
                    )
                  })
                ])
              )
            ])
          ]
        )
      ),
      {}
    )
  }
})
const Fb = ee(
    { color: String, ...Bn(), ...Me(), ...qn(), ...Yt(), ...Oa(), ...po(), ...kt(), ...Ke(), ...ot() },
    'VSheet'
  ),
  Fd = fe()({
    name: 'VSheet',
    props: Fb(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = ut(e),
        { backgroundColorClasses: a, backgroundColorStyles: s } = Rt(ve(e, 'color')),
        { borderClasses: o } = Jn(e),
        { dimensionStyles: r } = Zn(e),
        { elevationClasses: l } = nn(e),
        { locationStyles: c } = Ia(e),
        { positionClasses: u } = yo(e),
        { roundedClasses: d } = Lt(e)
      return (
        ge(() =>
          m(
            e.tag,
            {
              class: ['v-sheet', i.value, a.value, o.value, l.value, u.value, d.value, e.class],
              style: [s.value, r.value, c.value, e.style]
            },
            n
          )
        ),
        {}
      )
    }
  }),
  XA = ee(
    {
      canvasHeight: { type: [String, Number], default: 150 },
      disabled: Boolean,
      dotSize: { type: [Number, String], default: 10 },
      hideCanvas: Boolean,
      hideSliders: Boolean,
      hideInputs: Boolean,
      mode: { type: String, default: 'rgba', validator: (e) => Object.keys(ls).includes(e) },
      modes: {
        type: Array,
        default: () => Object.keys(ls),
        validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(ls).includes(t))
      },
      showSwatches: Boolean,
      swatches: Array,
      swatchesMaxHeight: { type: [Number, String], default: 150 },
      modelValue: { type: [Object, String] },
      ...Gn(Fb({ width: 300 }), ['height', 'location', 'minHeight', 'maxHeight', 'minWidth', 'maxWidth'])
    },
    'VColorPicker'
  ),
  KA = Xn({
    name: 'VColorPicker',
    props: XA(),
    emits: { 'update:modelValue': (e) => !0, 'update:mode': (e) => !0 },
    setup(e) {
      const t = Ge(e, 'mode'),
        n = te(null),
        i = Ge(
          e,
          'modelValue',
          void 0,
          (o) => {
            if (o == null || o === '') return null
            let r
            try {
              r = Rc(jn(o))
            } catch {
              return null
            }
            return n.value && ((r = { ...r, h: n.value.h }), (n.value = null)), r
          },
          (o) => (o ? dA(o, e.modelValue) : null)
        ),
        { rtlClasses: a } = Qt(),
        s = (o) => {
          ;(i.value = o), (n.value = o)
        }
      return (
        tn(() => {
          e.modes.includes(t.value) || (t.value = e.modes[0])
        }),
        zt({ VSlider: { color: void 0, trackColor: void 0, trackFillColor: void 0 } }),
        ge(() => {
          const [o] = Fd.filterProps(e)
          return m(
            Fd,
            xe(
              {
                rounded: e.rounded,
                elevation: e.elevation,
                theme: e.theme,
                class: ['v-color-picker', a.value, e.class],
                style: [{ '--v-color-picker-color-hsv': iy({ ...(i.value ?? tr), a: 1 }) }, e.style]
              },
              o,
              { maxWidth: e.width }
            ),
            {
              default: () => [
                !e.hideCanvas &&
                  m(
                    cA,
                    {
                      key: 'canvas',
                      color: i.value,
                      'onUpdate:color': s,
                      disabled: e.disabled,
                      dotSize: e.dotSize,
                      width: e.width,
                      height: e.canvasHeight
                    },
                    null
                  ),
                (!e.hideSliders || !e.hideInputs) &&
                  m('div', { key: 'controls', class: 'v-color-picker__controls' }, [
                    !e.hideSliders &&
                      m(
                        SA,
                        {
                          key: 'preview',
                          color: i.value,
                          'onUpdate:color': s,
                          hideAlpha: !t.value.endsWith('a'),
                          disabled: e.disabled
                        },
                        null
                      ),
                    !e.hideInputs &&
                      m(
                        pA,
                        {
                          key: 'edit',
                          modes: e.modes,
                          mode: t.value,
                          'onUpdate:mode': (r) => (t.value = r),
                          color: i.value,
                          'onUpdate:color': s,
                          disabled: e.disabled
                        },
                        null
                      )
                  ]),
                e.showSwatches &&
                  m(
                    GA,
                    {
                      key: 'swatches',
                      color: i.value,
                      'onUpdate:color': s,
                      maxHeight: e.swatchesMaxHeight,
                      swatches: e.swatches,
                      disabled: e.disabled
                    },
                    null
                  )
              ]
            }
          )
        }),
        {}
      )
    }
  })
function qA(e, t, n) {
  if (t == null) return e
  if (Array.isArray(t)) throw new Error('Multiple matches is not implemented')
  return typeof t == 'number' && ~t
    ? m(Oe, null, [
        m('span', { class: 'v-combobox__unmask' }, [e.substr(0, t)]),
        m('span', { class: 'v-combobox__mask' }, [e.substr(t, n)]),
        m('span', { class: 'v-combobox__unmask' }, [e.substr(t + n)])
      ])
    : e
}
const ZA = ee(
    {
      autoSelectFirst: { type: [Boolean, String] },
      delimiters: Array,
      ...mb({ filterKeys: ['title'] }),
      ...fh({ hideNoData: !0, returnObject: !0 }),
      ...Gn(Zc({ modelValue: null, role: 'combobox' }), ['validationValue', 'dirty', 'appendInnerIcon']),
      ...sa({ transition: !1 })
    },
    'VCombobox'
  ),
  JA = fe()({
    name: 'VCombobox',
    props: ZA(),
    emits: {
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0,
      'update:search': (e) => !0,
      'update:menu': (e) => !0
    },
    setup(e, t) {
      var ne
      let { emit: n, slots: i } = t
      const { t: a } = Kn(),
        s = te(),
        o = Ce(!1),
        r = Ce(!0),
        l = Ce(!1),
        c = te(),
        u = te(),
        d = Ge(e, 'menu'),
        f = A({
          get: () => d.value,
          set: (W) => {
            var le
            ;(d.value && !W && (le = c.value) != null && le.ΨopenChildren) || (d.value = W)
          }
        }),
        h = Ce(-1)
      let v = !1
      const g = A(() => {
          var W
          return (W = s.value) == null ? void 0 : W.color
        }),
        p = A(() => (f.value ? e.closeText : e.openText)),
        { items: y, transformIn: b, transformOut: x } = lh(e),
        { textColorClasses: w, textColorStyles: C } = dn(g),
        P = Ge(
          e,
          'modelValue',
          [],
          (W) => b(Dn(W)),
          (W) => {
            const le = x(W)
            return e.multiple ? le : le[0] ?? null
          }
        ),
        k = Uc(),
        S = Ce(e.multiple ? '' : ((ne = P.value[0]) == null ? void 0 : ne.title) ?? ''),
        _ = A({
          get: () => S.value,
          set: (W) => {
            var le
            if (
              ((S.value = W),
              e.multiple || (P.value = [is(e, W)]),
              W && e.multiple && (le = e.delimiters) != null && le.length)
            ) {
              const De = W.split(new RegExp(`(?:${e.delimiters.join('|')})+`))
              De.length > 1 &&
                (De.forEach((L) => {
                  ;(L = L.trim()), L && He(is(e, L))
                }),
                (S.value = ''))
            }
            W || (h.value = -1), (r.value = !W)
          }
        })
      Pe(S, (W) => {
        v ? mt(() => (v = !1)) : o.value && !f.value && (f.value = !0), n('update:search', W)
      }),
        Pe(P, (W) => {
          var le
          e.multiple || (S.value = ((le = W[0]) == null ? void 0 : le.title) ?? '')
        })
      const { filteredItems: T, getMatches: B } = pb(e, y, () => (r.value ? '' : _.value)),
        O = A(() =>
          e.hideSelected ? T.value.filter((W) => !P.value.some((le) => le.value === W.value)) : T.value
        ),
        N = A(() => P.value.map((W) => W.value)),
        Q = A(() => {
          var le
          return (
            (e.autoSelectFirst === !0 ||
              (e.autoSelectFirst === 'exact' &&
                _.value === ((le = O.value[0]) == null ? void 0 : le.title))) &&
            O.value.length > 0 &&
            !r.value &&
            !l.value
          )
        }),
        ue = A(
          () => (e.hideNoData && !y.value.length) || e.readonly || (k == null ? void 0 : k.isReadonly.value)
        ),
        j = te(),
        { onListScroll: U, onListKeydown: X } = dh(j, s)
      function oe(W) {
        ;(v = !0), e.openOnClear && (f.value = !0)
      }
      function de() {
        ue.value || (f.value = !0)
      }
      function ce(W) {
        ue.value || (o.value && (W.preventDefault(), W.stopPropagation()), (f.value = !f.value))
      }
      function Te(W) {
        var L
        if (e.readonly || (k != null && k.isReadonly.value)) return
        const le = s.value.selectionStart,
          De = P.value.length
        if (
          ((h.value > -1 || ['Enter', 'ArrowDown', 'ArrowUp'].includes(W.key)) && W.preventDefault(),
          ['Enter', 'ArrowDown'].includes(W.key) && (f.value = !0),
          ['Escape'].includes(W.key) && (f.value = !1),
          ['Enter', 'Escape', 'Tab'].includes(W.key) &&
            (Q.value && ['Enter', 'Tab'].includes(W.key) && He(T.value[0]), (r.value = !0)),
          W.key === 'ArrowDown' && Q.value && ((L = j.value) == null || L.focus('next')),
          !!e.multiple)
        ) {
          if (['Backspace', 'Delete'].includes(W.key)) {
            if (h.value < 0) {
              W.key === 'Backspace' && !_.value && (h.value = De - 1)
              return
            }
            const D = h.value,
              H = P.value[h.value]
            H && He(H), (h.value = D >= De - 1 ? De - 2 : D)
          }
          if (W.key === 'ArrowLeft') {
            if (h.value < 0 && le > 0) return
            const D = h.value > -1 ? h.value - 1 : De - 1
            P.value[D]
              ? (h.value = D)
              : ((h.value = -1), s.value.setSelectionRange(_.value.length, _.value.length))
          }
          if (W.key === 'ArrowRight') {
            if (h.value < 0) return
            const D = h.value + 1
            P.value[D] ? (h.value = D) : ((h.value = -1), s.value.setSelectionRange(0, 0))
          }
          W.key === 'Enter' && _.value && (He(is(e, _.value)), (_.value = ''))
        }
      }
      function $e() {
        var W
        o.value && ((r.value = !0), (W = s.value) == null || W.focus())
      }
      function He(W) {
        if (e.multiple) {
          const le = P.value.findIndex((De) => e.valueComparator(De.value, W.value))
          if (le === -1) P.value = [...P.value, W]
          else {
            const De = [...P.value]
            De.splice(le, 1), (P.value = De)
          }
          _.value = ''
        } else
          (P.value = [W]),
            (S.value = W.title),
            mt(() => {
              ;(f.value = !1), (r.value = !0)
            })
      }
      function Ue(W) {
        ;(o.value = !0),
          setTimeout(() => {
            l.value = !0
          })
      }
      function ie(W) {
        l.value = !1
      }
      function Y(W) {
        ;(W == null || (W === '' && !e.multiple)) && (P.value = [])
      }
      return (
        Pe(T, (W) => {
          !W.length && e.hideNoData && (f.value = !1)
        }),
        Pe(o, (W, le) => {
          W ||
            W === le ||
            ((h.value = -1),
            (f.value = !1),
            Q.value &&
            !l.value &&
            !P.value.some((De) => {
              let { value: L } = De
              return L === O.value[0].value
            })
              ? He(O.value[0])
              : e.multiple && _.value && ((P.value = [...P.value, is(e, _.value)]), (_.value = '')))
        }),
        Pe(f, () => {
          if (!e.hideSelected && f.value && P.value.length) {
            const W = O.value.findIndex((le) => P.value.some((De) => e.valueComparator(De.value, le.value)))
            yt &&
              window.requestAnimationFrame(() => {
                var le
                W >= 0 && ((le = u.value) == null || le.scrollToIndex(W))
              })
          }
        }),
        ge(() => {
          const W = !!(e.chips || i.chip),
            le = !!(!e.hideNoData || O.value.length || i['prepend-item'] || i['append-item'] || i['no-data']),
            De = P.value.length > 0,
            [L] = vs.filterProps(e)
          return m(
            vs,
            xe({ ref: s }, L, {
              modelValue: _.value,
              'onUpdate:modelValue': [(D) => (_.value = D), Y],
              focused: o.value,
              'onUpdate:focused': (D) => (o.value = D),
              validationValue: P.externalValue,
              dirty: De,
              class: [
                'v-combobox',
                {
                  'v-combobox--active-menu': f.value,
                  'v-combobox--chips': !!e.chips,
                  'v-combobox--selection-slot': !!i.selection,
                  'v-combobox--selecting-index': h.value > -1,
                  [`v-combobox--${e.multiple ? 'multiple' : 'single'}`]: !0
                },
                e.class
              ],
              style: e.style,
              readonly: e.readonly,
              placeholder: De ? void 0 : e.placeholder,
              'onClick:clear': oe,
              'onMousedown:control': de,
              onKeydown: Te
            }),
            {
              ...i,
              default: () =>
                m(Oe, null, [
                  m(
                    Xc,
                    xe(
                      {
                        ref: c,
                        modelValue: f.value,
                        'onUpdate:modelValue': (D) => (f.value = D),
                        activator: 'parent',
                        contentClass: 'v-combobox__content',
                        disabled: ue.value,
                        eager: e.eager,
                        maxHeight: 310,
                        openOnClick: !1,
                        closeOnContentClick: !1,
                        transition: e.transition,
                        onAfterLeave: $e
                      },
                      e.menuProps
                    ),
                    {
                      default: () => [
                        le &&
                          m(
                            Yc,
                            {
                              ref: j,
                              selected: N.value,
                              selectStrategy: e.multiple ? 'independent' : 'single-independent',
                              onMousedown: (D) => D.preventDefault(),
                              onKeydown: X,
                              onFocusin: Ue,
                              onFocusout: ie,
                              onScrollPassive: U,
                              tabindex: '-1',
                              color: e.itemColor ?? e.color
                            },
                            {
                              default: () => {
                                var D, H, Z
                                return [
                                  (D = i['prepend-item']) == null ? void 0 : D.call(i),
                                  !O.value.length &&
                                    !e.hideNoData &&
                                    (((H = i['no-data']) == null ? void 0 : H.call(i)) ??
                                      m(Qi, { title: a(e.noDataText) }, null)),
                                  m(
                                    Jc,
                                    { ref: u, renderless: !0, items: O.value },
                                    {
                                      default: (ae) => {
                                        var he
                                        let { item: se, index: ye, itemRef: pe } = ae
                                        const _e = xe(se.props, {
                                          ref: pe,
                                          key: ye,
                                          active: Q.value && ye === 0 ? !0 : void 0,
                                          onClick: () => He(se)
                                        })
                                        return (
                                          ((he = i.item) == null
                                            ? void 0
                                            : he.call(i, { item: se, index: ye, props: _e })) ??
                                          m(Qi, _e, {
                                            prepend: (Fe) => {
                                              let { isSelected: Le } = Fe
                                              return m(Oe, null, [
                                                e.multiple && !e.hideSelected
                                                  ? m(
                                                      Qs,
                                                      {
                                                        key: se.value,
                                                        modelValue: Le,
                                                        ripple: !1,
                                                        tabindex: '-1'
                                                      },
                                                      null
                                                    )
                                                  : void 0,
                                                se.props.prependIcon &&
                                                  m(gt, { icon: se.props.prependIcon }, null)
                                              ])
                                            },
                                            title: () => {
                                              var Fe, Le
                                              return r.value
                                                ? se.title
                                                : qA(
                                                    se.title,
                                                    (Fe = B(se)) == null ? void 0 : Fe.title,
                                                    ((Le = _.value) == null ? void 0 : Le.length) ?? 0
                                                  )
                                            }
                                          })
                                        )
                                      }
                                    }
                                  ),
                                  (Z = i['append-item']) == null ? void 0 : Z.call(i)
                                ]
                              }
                            }
                          )
                      ]
                    }
                  ),
                  P.value.map((D, H) => {
                    var se
                    function Z(ye) {
                      ye.stopPropagation(), ye.preventDefault(), He(D)
                    }
                    const ae = {
                      'onClick:close': Z,
                      onMousedown(ye) {
                        ye.preventDefault(), ye.stopPropagation()
                      },
                      modelValue: !0,
                      'onUpdate:modelValue': void 0
                    }
                    return m(
                      'div',
                      {
                        key: D.value,
                        class: [
                          'v-combobox__selection',
                          H === h.value && ['v-combobox__selection--selected', w.value]
                        ],
                        style: H === h.value ? C.value : {}
                      },
                      [
                        W
                          ? i.chip
                            ? m(
                                vt,
                                {
                                  key: 'chip-defaults',
                                  defaults: {
                                    VChip: { closable: e.closableChips, size: 'small', text: D.title }
                                  }
                                },
                                {
                                  default: () => {
                                    var ye
                                    return [
                                      (ye = i.chip) == null
                                        ? void 0
                                        : ye.call(i, { item: D, index: H, props: ae })
                                    ]
                                  }
                                }
                              )
                            : m(
                                Ur,
                                xe(
                                  { key: 'chip', closable: e.closableChips, size: 'small', text: D.title },
                                  ae
                                ),
                                null
                              )
                          : ((se = i.selection) == null ? void 0 : se.call(i, { item: D, index: H })) ??
                            m('span', { class: 'v-combobox__selection-text' }, [
                              D.title,
                              e.multiple &&
                                H < P.value.length - 1 &&
                                m('span', { class: 'v-combobox__selection-comma' }, [nt(',')])
                            ])
                      ]
                    )
                  })
                ]),
              'append-inner': function () {
                var ae
                for (var D = arguments.length, H = new Array(D), Z = 0; Z < D; Z++) H[Z] = arguments[Z]
                return m(Oe, null, [
                  (ae = i['append-inner']) == null ? void 0 : ae.call(i, ...H),
                  (!e.hideNoData || e.items.length) && e.menuIcon
                    ? m(
                        gt,
                        {
                          class: 'v-combobox__menu-icon',
                          icon: e.menuIcon,
                          onMousedown: ce,
                          onClick: q0,
                          'aria-label': a(p.value),
                          title: a(p.value)
                        },
                        null
                      )
                    : void 0
                ])
              }
            }
          )
        }),
        vi(
          {
            isFocused: o,
            isPristine: r,
            menu: f,
            search: _,
            selectionIndex: h,
            filteredItems: T,
            select: He
          },
          s
        )
      )
    }
  })
const QA = ee(
    {
      fullscreen: Boolean,
      retainFocus: { type: Boolean, default: !0 },
      scrollable: Boolean,
      ...Yr({ origin: 'center center', scrollStrategy: 'block', transition: { component: $c }, zIndex: 2400 })
    },
    'VDialog'
  ),
  eP = fe()({
    name: 'VDialog',
    props: QA(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = Ge(e, 'modelValue'),
        { scopeId: a } = _o(),
        s = te()
      function o(l) {
        var d, f
        const c = l.relatedTarget,
          u = l.target
        if (
          c !== u &&
          (d = s.value) != null &&
          d.contentEl &&
          (f = s.value) != null &&
          f.globalTop &&
          ![document, s.value.contentEl].includes(u) &&
          !s.value.contentEl.contains(u)
        ) {
          const h = _r(s.value.contentEl)
          if (!h.length) return
          const v = h[0],
            g = h[h.length - 1]
          c === v ? g.focus() : v.focus()
        }
      }
      yt &&
        Pe(
          () => i.value && e.retainFocus,
          (l) => {
            l ? document.addEventListener('focusin', o) : document.removeEventListener('focusin', o)
          },
          { immediate: !0 }
        ),
        Pe(i, async (l) => {
          var c, u
          await mt(),
            l
              ? (c = s.value.contentEl) == null || c.focus({ preventScroll: !0 })
              : (u = s.value.activatorEl) == null || u.focus({ preventScroll: !0 })
        })
      const r = A(() => xe({ 'aria-haspopup': 'dialog', 'aria-expanded': String(i.value) }, e.activatorProps))
      return (
        ge(() => {
          const [l] = ea.filterProps(e)
          return m(
            ea,
            xe(
              {
                ref: s,
                class: [
                  'v-dialog',
                  { 'v-dialog--fullscreen': e.fullscreen, 'v-dialog--scrollable': e.scrollable },
                  e.class
                ],
                style: e.style
              },
              l,
              {
                modelValue: i.value,
                'onUpdate:modelValue': (c) => (i.value = c),
                'aria-modal': 'true',
                activatorProps: r.value,
                role: 'dialog'
              },
              a
            ),
            {
              activator: n.activator,
              default: function () {
                for (var c = arguments.length, u = new Array(c), d = 0; d < c; d++) u[d] = arguments[d]
                return m(
                  vt,
                  { root: 'VDialog' },
                  {
                    default: () => {
                      var f
                      return [(f = n.default) == null ? void 0 : f.call(n, ...u)]
                    }
                  }
                )
              }
            }
          )
        }),
        vi({}, s)
      )
    }
  })
const Mr = Symbol.for('vuetify:v-expansion-panel'),
  tP = ['default', 'accordion', 'inset', 'popout'],
  nP = ee(
    {
      color: String,
      variant: { type: String, default: 'default', validator: (e) => tP.includes(e) },
      readonly: Boolean,
      ...Me(),
      ...ho(),
      ...Ke(),
      ...ot()
    },
    'VExpansionPanels'
  ),
  iP = fe()({
    name: 'VExpansionPanels',
    props: nP(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      Ss(e, Mr)
      const { themeClasses: i } = ut(e),
        a = A(() => e.variant && `v-expansion-panels--variant-${e.variant}`)
      return (
        zt({
          VExpansionPanel: { color: ve(e, 'color') },
          VExpansionPanelTitle: { readonly: ve(e, 'readonly') }
        }),
        ge(() => m(e.tag, { class: ['v-expansion-panels', i.value, a.value, e.class], style: e.style }, n)),
        {}
      )
    }
  }),
  aP = ee({ ...Me(), ...Gc() }, 'VExpansionPanelText'),
  Rb = fe()({
    name: 'VExpansionPanelText',
    props: aP(),
    setup(e, t) {
      let { slots: n } = t
      const i = st(Mr)
      if (!i) throw new Error('[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel')
      const { hasContent: a, onAfterLeave: s } = ch(e, i.isSelected)
      return (
        ge(() =>
          m(
            zc,
            { onAfterLeave: s },
            {
              default: () => {
                var o
                return [
                  Et(
                    m('div', { class: ['v-expansion-panel-text', e.class], style: e.style }, [
                      n.default &&
                        a.value &&
                        m('div', { class: 'v-expansion-panel-text__wrapper' }, [
                          (o = n.default) == null ? void 0 : o.call(n)
                        ])
                    ]),
                    [[Li, i.isSelected.value]]
                  )
                ]
              }
            }
          )
        ),
        {}
      )
    }
  }),
  Bb = ee(
    {
      color: String,
      expandIcon: { type: Ye, default: '$expand' },
      collapseIcon: { type: Ye, default: '$collapse' },
      hideActions: Boolean,
      ripple: { type: [Boolean, Object], default: !1 },
      readonly: Boolean,
      ...Me()
    },
    'VExpansionPanelTitle'
  ),
  Nb = fe()({
    name: 'VExpansionPanelTitle',
    directives: { Ripple: Da },
    props: Bb(),
    setup(e, t) {
      let { slots: n } = t
      const i = st(Mr)
      if (!i) throw new Error('[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel')
      const { backgroundColorClasses: a, backgroundColorStyles: s } = Rt(e, 'color'),
        o = A(() => ({
          collapseIcon: e.collapseIcon,
          disabled: i.disabled.value,
          expanded: i.isSelected.value,
          expandIcon: e.expandIcon,
          readonly: e.readonly
        }))
      return (
        ge(() => {
          var r
          return Et(
            m(
              'button',
              {
                class: [
                  'v-expansion-panel-title',
                  { 'v-expansion-panel-title--active': i.isSelected.value },
                  a.value,
                  e.class
                ],
                style: [s.value, e.style],
                type: 'button',
                tabindex: i.disabled.value ? -1 : void 0,
                disabled: i.disabled.value,
                'aria-expanded': i.isSelected.value,
                onClick: e.readonly ? void 0 : i.toggle
              },
              [
                m('span', { class: 'v-expansion-panel-title__overlay' }, null),
                (r = n.default) == null ? void 0 : r.call(n, o.value),
                !e.hideActions &&
                  m('span', { class: 'v-expansion-panel-title__icon' }, [
                    n.actions
                      ? n.actions(o.value)
                      : m(gt, { icon: i.isSelected.value ? e.collapseIcon : e.expandIcon }, null)
                  ])
              ]
            ),
            [[Fn('ripple'), e.ripple]]
          )
        }),
        {}
      )
    }
  }),
  sP = ee(
    {
      title: String,
      text: String,
      bgColor: String,
      ...Me(),
      ...Yt(),
      ...vo(),
      ...Gc(),
      ...kt(),
      ...Ke(),
      ...Bb()
    },
    'VExpansionPanel'
  ),
  oP = fe()({
    name: 'VExpansionPanel',
    props: sP(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = go(e, Mr),
        { backgroundColorClasses: a, backgroundColorStyles: s } = Rt(e, 'bgColor'),
        { elevationClasses: o } = nn(e),
        { roundedClasses: r } = Lt(e),
        l = A(() => (i == null ? void 0 : i.disabled.value) || e.disabled),
        c = A(() =>
          i.group.items.value.reduce((f, h, v) => (i.group.selected.value.includes(h.id) && f.push(v), f), [])
        ),
        u = A(() => {
          const f = i.group.items.value.findIndex((h) => h.id === i.id)
          return !i.isSelected.value && c.value.some((h) => h - f === 1)
        }),
        d = A(() => {
          const f = i.group.items.value.findIndex((h) => h.id === i.id)
          return !i.isSelected.value && c.value.some((h) => h - f === -1)
        })
      return (
        Vt(Mr, i),
        zt({ VExpansionPanelText: { eager: ve(e, 'eager') } }),
        ge(() => {
          const f = !!(n.text || e.text),
            h = !!(n.title || e.title)
          return m(
            e.tag,
            {
              class: [
                'v-expansion-panel',
                {
                  'v-expansion-panel--active': i.isSelected.value,
                  'v-expansion-panel--before-active': u.value,
                  'v-expansion-panel--after-active': d.value,
                  'v-expansion-panel--disabled': l.value
                },
                r.value,
                a.value,
                e.class
              ],
              style: [s.value, e.style]
            },
            {
              default: () => {
                var v
                return [
                  m('div', { class: ['v-expansion-panel__shadow', ...o.value] }, null),
                  h &&
                    m(
                      Nb,
                      {
                        key: 'title',
                        collapseIcon: e.collapseIcon,
                        color: e.color,
                        expandIcon: e.expandIcon,
                        hideActions: e.hideActions,
                        ripple: e.ripple
                      },
                      { default: () => [n.title ? n.title() : e.title] }
                    ),
                  f && m(Rb, { key: 'text' }, { default: () => [n.text ? n.text() : e.text] }),
                  (v = n.default) == null ? void 0 : v.call(n)
                ]
              }
            }
          )
        }),
        {}
      )
    }
  })
const rP = ee(
    {
      chips: Boolean,
      counter: Boolean,
      counterSizeString: { type: String, default: '$vuetify.fileInput.counterSize' },
      counterString: { type: String, default: '$vuetify.fileInput.counter' },
      multiple: Boolean,
      showSize: {
        type: [Boolean, Number],
        default: !1,
        validator: (e) => typeof e == 'boolean' || [1e3, 1024].includes(e)
      },
      ...ra({ prependIcon: '$file' }),
      modelValue: {
        type: Array,
        default: () => [],
        validator: (e) => Dn(e).every((t) => t != null && typeof t == 'object')
      },
      ...qc({ clearable: !0 })
    },
    'VFileInput'
  ),
  lP = fe()({
    name: 'VFileInput',
    inheritAttrs: !1,
    props: rP(),
    emits: {
      'click:control': (e) => !0,
      'mousedown:control': (e) => !0,
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0
    },
    setup(e, t) {
      let { attrs: n, emit: i, slots: a } = t
      const { t: s } = Kn(),
        o = Ge(e, 'modelValue'),
        { isFocused: r, focus: l, blur: c } = Fa(e),
        u = A(() => (typeof e.showSize != 'boolean' ? e.showSize : void 0)),
        d = A(() =>
          (o.value ?? []).reduce((_, T) => {
            let { size: B = 0 } = T
            return _ + B
          }, 0)
        ),
        f = A(() => Iv(d.value, u.value)),
        h = A(() =>
          (o.value ?? []).map((_) => {
            const { name: T = '', size: B = 0 } = _
            return e.showSize ? `${T} (${Iv(B, u.value)})` : T
          })
        ),
        v = A(() => {
          var T
          const _ = ((T = o.value) == null ? void 0 : T.length) ?? 0
          return e.showSize ? s(e.counterSizeString, _, f.value) : s(e.counterString, _)
        }),
        g = te(),
        p = te(),
        y = te(),
        b = A(() => r.value || e.active),
        x = A(() => ['plain', 'underlined'].includes(e.variant))
      function w() {
        var _
        y.value !== document.activeElement && ((_ = y.value) == null || _.focus()), r.value || l()
      }
      function C(_) {
        k(_)
      }
      function P(_) {
        i('mousedown:control', _)
      }
      function k(_) {
        var T
        ;(T = y.value) == null || T.click(), i('click:control', _)
      }
      function S(_) {
        _.stopPropagation(),
          w(),
          mt(() => {
            ;(o.value = []), Nf(e['onClick:clear'], _)
          })
      }
      return (
        Pe(o, (_) => {
          ;(!Array.isArray(_) || !_.length) && y.value && (y.value.value = '')
        }),
        ge(() => {
          const _ = !!(a.counter || e.counter),
            T = !!(_ || a.details),
            [B, O] = ys(n),
            [{ modelValue: N, ...Q }] = en.filterProps(e),
            [ue] = uh(e)
          return m(
            en,
            xe(
              {
                ref: g,
                modelValue: o.value,
                'onUpdate:modelValue': (j) => (o.value = j),
                class: ['v-file-input', { 'v-text-field--plain-underlined': x.value }, e.class],
                style: e.style,
                'onClick:prepend': C
              },
              B,
              Q,
              { centerAffix: !x.value, focused: r.value }
            ),
            {
              ...a,
              default: (j) => {
                let { id: U, isDisabled: X, isDirty: oe, isReadonly: de, isValid: ce } = j
                return m(
                  Gr,
                  xe(
                    {
                      ref: p,
                      'prepend-icon': e.prependIcon,
                      onMousedown: P,
                      onClick: k,
                      'onClick:clear': S,
                      'onClick:prependInner': e['onClick:prependInner'],
                      'onClick:appendInner': e['onClick:appendInner']
                    },
                    ue,
                    {
                      id: U.value,
                      active: b.value || oe.value,
                      dirty: oe.value,
                      disabled: X.value,
                      focused: r.value,
                      error: ce.value === !1
                    }
                  ),
                  {
                    ...a,
                    default: (Te) => {
                      var Ue
                      let {
                        props: { class: $e, ...He }
                      } = Te
                      return m(Oe, null, [
                        m(
                          'input',
                          xe(
                            {
                              ref: y,
                              type: 'file',
                              readonly: de.value,
                              disabled: X.value,
                              multiple: e.multiple,
                              name: e.name,
                              onClick: (ie) => {
                                ie.stopPropagation(), de.value && ie.preventDefault(), w()
                              },
                              onChange: (ie) => {
                                if (!ie.target) return
                                const Y = ie.target
                                o.value = [...(Y.files ?? [])]
                              },
                              onFocus: w,
                              onBlur: c
                            },
                            He,
                            O
                          ),
                          null
                        ),
                        m('div', { class: $e }, [
                          !!((Ue = o.value) != null && Ue.length) &&
                            (a.selection
                              ? a.selection({
                                  fileNames: h.value,
                                  totalBytes: d.value,
                                  totalBytesReadable: f.value
                                })
                              : e.chips
                              ? h.value.map((ie) =>
                                  m(Ur, { key: ie, size: 'small', color: e.color }, { default: () => [ie] })
                                )
                              : h.value.join(', '))
                        ])
                      ])
                    }
                  }
                )
              },
              details: T
                ? (j) => {
                    var U, X
                    return m(Oe, null, [
                      (U = a.details) == null ? void 0 : U.call(a, j),
                      _ &&
                        m(Oe, null, [
                          m('span', null, null),
                          m(Kc, { active: !!((X = o.value) != null && X.length), value: v.value }, a.counter)
                        ])
                    ])
                  }
                : void 0
            }
          )
        }),
        vi({}, g, p, y)
      )
    }
  })
const cP = ee(
    {
      app: Boolean,
      color: String,
      height: { type: [Number, String], default: 'auto' },
      ...Bn(),
      ...Me(),
      ...Yt(),
      ...uo(),
      ...kt(),
      ...Ke({ tag: 'footer' }),
      ...ot()
    },
    'VFooter'
  ),
  uP = fe()({
    name: 'VFooter',
    props: cP(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = ut(e),
        { backgroundColorClasses: a, backgroundColorStyles: s } = Rt(ve(e, 'color')),
        { borderClasses: o } = Jn(e),
        { elevationClasses: r } = nn(e),
        { roundedClasses: l } = Lt(e),
        c = Ce(32),
        { resizeRef: u } = Ti((h) => {
          h.length && (c.value = h[0].target.clientHeight)
        }),
        d = A(() => (e.height === 'auto' ? c.value : parseInt(e.height, 10))),
        { layoutItemStyles: f } = fo({
          id: e.name,
          order: A(() => parseInt(e.order, 10)),
          position: A(() => 'bottom'),
          layoutSize: d,
          elementSize: A(() => (e.height === 'auto' ? void 0 : d.value)),
          active: A(() => e.app),
          absolute: ve(e, 'absolute')
        })
      return (
        ge(() =>
          m(
            e.tag,
            {
              ref: u,
              class: ['v-footer', i.value, a.value, o.value, r.value, l.value, e.class],
              style: [s.value, e.app ? f.value : { height: Ve(e.height) }, e.style]
            },
            n
          )
        ),
        {}
      )
    }
  }),
  dP = ee({ ...Me(), ...w2() }, 'VForm'),
  fP = fe()({
    name: 'VForm',
    props: dP(),
    emits: { 'update:modelValue': (e) => !0, submit: (e) => !0 },
    setup(e, t) {
      let { slots: n, emit: i } = t
      const a = S2(e),
        s = te()
      function o(l) {
        l.preventDefault(), a.reset()
      }
      function r(l) {
        const c = l,
          u = a.validate()
        ;(c.then = u.then.bind(u)),
          (c.catch = u.catch.bind(u)),
          (c.finally = u.finally.bind(u)),
          i('submit', c),
          c.defaultPrevented ||
            u.then((d) => {
              var h
              let { valid: f } = d
              f && ((h = s.value) == null || h.submit())
            }),
          c.preventDefault()
      }
      return (
        ge(() => {
          var l
          return m(
            'form',
            { ref: s, class: ['v-form', e.class], style: e.style, novalidate: !0, onReset: o, onSubmit: r },
            [(l = n.default) == null ? void 0 : l.call(n, a)]
          )
        }),
        vi(a, s)
      )
    }
  })
const hP = ee({ fluid: { type: Boolean, default: !1 }, ...Me(), ...Ke() }, 'VContainer'),
  vP = fe()({
    name: 'VContainer',
    props: hP(),
    setup(e, t) {
      let { slots: n } = t
      const { rtlClasses: i } = Qt()
      return (
        ge(() =>
          m(
            e.tag,
            { class: ['v-container', { 'v-container--fluid': e.fluid }, i.value, e.class], style: e.style },
            n
          )
        ),
        {}
      )
    }
  }),
  $b = (() => Bc.reduce((e, t) => ((e[t] = { type: [Boolean, String, Number], default: !1 }), e), {}))(),
  zb = (() =>
    Bc.reduce((e, t) => {
      const n = 'offset' + na(t)
      return (e[n] = { type: [String, Number], default: null }), e
    }, {}))(),
  Hb = (() =>
    Bc.reduce((e, t) => {
      const n = 'order' + na(t)
      return (e[n] = { type: [String, Number], default: null }), e
    }, {}))(),
  bg = { col: Object.keys($b), offset: Object.keys(zb), order: Object.keys(Hb) }
function gP(e, t, n) {
  let i = e
  if (!(n == null || n === !1)) {
    if (t) {
      const a = t.replace(e, '')
      i += `-${a}`
    }
    return (
      e === 'col' && (i = 'v-' + i),
      (e === 'col' && (n === '' || n === !0)) || (i += `-${n}`),
      i.toLowerCase()
    )
  }
}
const mP = ['auto', 'start', 'end', 'center', 'baseline', 'stretch'],
  pP = ee(
    {
      cols: { type: [Boolean, String, Number], default: !1 },
      ...$b,
      offset: { type: [String, Number], default: null },
      ...zb,
      order: { type: [String, Number], default: null },
      ...Hb,
      alignSelf: { type: String, default: null, validator: (e) => mP.includes(e) },
      ...Me(),
      ...Ke()
    },
    'VCol'
  ),
  yP = fe()({
    name: 'VCol',
    props: pP(),
    setup(e, t) {
      let { slots: n } = t
      const i = A(() => {
        const a = []
        let s
        for (s in bg)
          bg[s].forEach((r) => {
            const l = e[r],
              c = gP(s, r, l)
            c && a.push(c)
          })
        const o = a.some((r) => r.startsWith('v-col-'))
        return (
          a.push({
            'v-col': !o || !e.cols,
            [`v-col-${e.cols}`]: e.cols,
            [`offset-${e.offset}`]: e.offset,
            [`order-${e.order}`]: e.order,
            [`align-self-${e.alignSelf}`]: e.alignSelf
          }),
          a
        )
      })
      return () => {
        var a
        return Ei(
          e.tag,
          { class: [i.value, e.class], style: e.style },
          (a = n.default) == null ? void 0 : a.call(n)
        )
      }
    }
  }),
  gh = ['start', 'end', 'center'],
  Wb = ['space-between', 'space-around', 'space-evenly']
function mh(e, t) {
  return Bc.reduce((n, i) => {
    const a = e + na(i)
    return (n[a] = t()), n
  }, {})
}
const bP = [...gh, 'baseline', 'stretch'],
  jb = (e) => bP.includes(e),
  Ub = mh('align', () => ({ type: String, default: null, validator: jb })),
  _P = [...gh, ...Wb],
  Yb = (e) => _P.includes(e),
  Gb = mh('justify', () => ({ type: String, default: null, validator: Yb })),
  xP = [...gh, ...Wb, 'stretch'],
  Xb = (e) => xP.includes(e),
  Kb = mh('alignContent', () => ({ type: String, default: null, validator: Xb })),
  _g = { align: Object.keys(Ub), justify: Object.keys(Gb), alignContent: Object.keys(Kb) },
  wP = { align: 'align', justify: 'justify', alignContent: 'align-content' }
function SP(e, t, n) {
  let i = wP[e]
  if (n != null) {
    if (t) {
      const a = t.replace(e, '')
      i += `-${a}`
    }
    return (i += `-${n}`), i.toLowerCase()
  }
}
const kP = ee(
    {
      dense: Boolean,
      noGutters: Boolean,
      align: { type: String, default: null, validator: jb },
      ...Ub,
      justify: { type: String, default: null, validator: Yb },
      ...Gb,
      alignContent: { type: String, default: null, validator: Xb },
      ...Kb,
      ...Me(),
      ...Ke()
    },
    'VRow'
  ),
  CP = fe()({
    name: 'VRow',
    props: kP(),
    setup(e, t) {
      let { slots: n } = t
      const i = A(() => {
        const a = []
        let s
        for (s in _g)
          _g[s].forEach((o) => {
            const r = e[o],
              l = SP(s, o, r)
            l && a.push(l)
          })
        return (
          a.push({
            'v-row--no-gutters': e.noGutters,
            'v-row--dense': e.dense,
            [`align-${e.align}`]: e.align,
            [`justify-${e.justify}`]: e.justify,
            [`align-content-${e.alignContent}`]: e.alignContent
          }),
          a
        )
      })
      return () => {
        var a
        return Ei(
          e.tag,
          { class: ['v-row', i.value, e.class], style: e.style },
          (a = n.default) == null ? void 0 : a.call(n)
        )
      }
    }
  }),
  MP = hi('v-spacer', 'div', 'VSpacer'),
  AP = ee({ disabled: Boolean, modelValue: { type: Boolean, default: void 0 }, ...ub() }, 'VHover'),
  PP = fe()({
    name: 'VHover',
    props: AP(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = Ge(e, 'modelValue'),
        { runOpenDelay: a, runCloseDelay: s } = db(e, (o) => !e.disabled && (i.value = o))
      return () => {
        var o
        return (o = n.default) == null
          ? void 0
          : o.call(n, { isHovering: i.value, props: { onMouseenter: a, onMouseleave: s } })
      }
    }
  })
const qb = Symbol.for('vuetify:v-item-group'),
  TP = ee({ ...Me(), ...ho({ selectedClass: 'v-item--selected' }), ...Ke(), ...ot() }, 'VItemGroup'),
  VP = fe()({
    name: 'VItemGroup',
    props: TP(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = ut(e),
        { isSelected: a, select: s, next: o, prev: r, selected: l } = Ss(e, qb)
      return () =>
        m(
          e.tag,
          { class: ['v-item-group', i.value, e.class], style: e.style },
          {
            default: () => {
              var c
              return [
                (c = n.default) == null
                  ? void 0
                  : c.call(n, { isSelected: a, select: s, next: o, prev: r, selected: l.value })
              ]
            }
          }
        )
    }
  }),
  EP = fe()({
    name: 'VItem',
    props: vo(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { isSelected: i, select: a, toggle: s, selectedClass: o, value: r, disabled: l } = go(e, qb)
      return () => {
        var c
        return (c = n.default) == null
          ? void 0
          : c.call(n, {
              isSelected: i.value,
              selectedClass: o.value,
              select: a,
              toggle: s,
              value: r.value,
              disabled: l.value
            })
      }
    }
  })
const LP = hi('v-kbd')
const OP = ee({ ...Me(), ...py() }, 'VLayout'),
  IP = fe()({
    name: 'VLayout',
    props: OP(),
    setup(e, t) {
      let { slots: n } = t
      const { layoutClasses: i, layoutStyles: a, getLayoutItem: s, items: o, layoutRef: r } = yy(e)
      return (
        ge(() => {
          var l
          return m('div', { ref: r, class: [i.value, e.class], style: [a.value, e.style] }, [
            (l = n.default) == null ? void 0 : l.call(n)
          ])
        }),
        { getLayoutItem: s, items: o }
      )
    }
  })
const DP = ee(
    {
      position: { type: String, required: !0 },
      size: { type: [Number, String], default: 300 },
      modelValue: Boolean,
      ...Me(),
      ...uo()
    },
    'VLayoutItem'
  ),
  FP = fe()({
    name: 'VLayoutItem',
    props: DP(),
    setup(e, t) {
      let { slots: n } = t
      const { layoutItemStyles: i } = fo({
        id: e.name,
        order: A(() => parseInt(e.order, 10)),
        position: ve(e, 'position'),
        elementSize: ve(e, 'size'),
        layoutSize: ve(e, 'size'),
        active: ve(e, 'modelValue'),
        absolute: ve(e, 'absolute')
      })
      return () => {
        var a
        return m('div', { class: ['v-layout-item', e.class], style: [i.value, e.style] }, [
          (a = n.default) == null ? void 0 : a.call(n)
        ])
      }
    }
  }),
  RP = ee(
    {
      modelValue: Boolean,
      options: { type: Object, default: () => ({ root: void 0, rootMargin: void 0, threshold: void 0 }) },
      ...Me(),
      ...qn(),
      ...Ke(),
      ...sa({ transition: 'fade-transition' })
    },
    'VLazy'
  ),
  BP = fe()({
    name: 'VLazy',
    directives: { intersect: Hr },
    props: RP(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { dimensionStyles: i } = Zn(e),
        a = Ge(e, 'modelValue')
      function s(o) {
        a.value || (a.value = o)
      }
      return (
        ge(() =>
          Et(
            m(
              e.tag,
              { class: ['v-lazy', e.class], style: [i.value, e.style] },
              {
                default: () => [
                  a.value &&
                    m(
                      ii,
                      { transition: e.transition, appear: !0 },
                      {
                        default: () => {
                          var o
                          return [(o = n.default) == null ? void 0 : o.call(n)]
                        }
                      }
                    )
                ]
              }
            ),
            [[Fn('intersect'), { handler: s, options: e.options }, null]]
          )
        ),
        {}
      )
    }
  })
const NP = ee(
    {
      locale: String,
      fallbackLocale: String,
      messages: Object,
      rtl: { type: Boolean, default: void 0 },
      ...Me()
    },
    'VLocaleProvider'
  ),
  $P = fe()({
    name: 'VLocaleProvider',
    props: NP(),
    setup(e, t) {
      let { slots: n } = t
      const { rtlClasses: i } = Kk(e)
      return (
        ge(() => {
          var a
          return m('div', { class: ['v-locale-provider', i.value, e.class], style: e.style }, [
            (a = n.default) == null ? void 0 : a.call(n)
          ])
        }),
        {}
      )
    }
  })
const zP = ee({ scrollable: Boolean, ...Me(), ...Ke({ tag: 'main' }) }, 'VMain'),
  HP = fe()({
    name: 'VMain',
    props: zP(),
    setup(e, t) {
      let { slots: n } = t
      const { mainStyles: i } = SC(),
        { ssrBootStyles: a } = _s()
      return (
        ge(() =>
          m(
            e.tag,
            {
              class: ['v-main', { 'v-main--scrollable': e.scrollable }, e.class],
              style: [i.value, a.value, e.style]
            },
            {
              default: () => {
                var s, o
                return [
                  e.scrollable
                    ? m('div', { class: 'v-main__scroller' }, [(s = n.default) == null ? void 0 : s.call(n)])
                    : (o = n.default) == null
                    ? void 0
                    : o.call(n)
                ]
              }
            }
          )
        ),
        {}
      )
    }
  })
function WP(e) {
  let { rootEl: t, isSticky: n, layoutItemStyles: i } = e
  const a = Ce(!1),
    s = Ce(0),
    o = A(() => {
      const c = typeof a.value == 'boolean' ? 'top' : a.value
      return [
        n.value ? { top: 'auto', bottom: 'auto', height: void 0 } : void 0,
        a.value ? { [c]: Ve(s.value) } : { top: i.value.top }
      ]
    })
  tn(() => {
    Pe(
      n,
      (c) => {
        c ? window.addEventListener('scroll', l, { passive: !0 }) : window.removeEventListener('scroll', l)
      },
      { immediate: !0 }
    )
  }),
    _n(() => {
      window.removeEventListener('scroll', l)
    })
  let r = 0
  function l() {
    const c = r > window.scrollY ? 'up' : 'down',
      u = t.value.getBoundingClientRect(),
      d = parseFloat(i.value.top ?? 0),
      f = window.scrollY - Math.max(0, s.value - d),
      h = u.height + Math.max(s.value, d) - window.scrollY - window.innerHeight,
      v = parseFloat(getComputedStyle(t.value).getPropertyValue('--v-body-scroll-y')) || 0
    u.height < window.innerHeight - d
      ? ((a.value = 'top'), (s.value = d))
      : (c === 'up' && a.value === 'bottom') || (c === 'down' && a.value === 'top')
      ? ((s.value = window.scrollY + u.top - v), (a.value = !0))
      : c === 'down' && h <= 0
      ? ((s.value = 0), (a.value = 'bottom'))
      : c === 'up' &&
        f <= 0 &&
        (v
          ? a.value !== 'top' && ((s.value = -f + v + d), (a.value = 'top'))
          : ((s.value = u.top + f), (a.value = 'top'))),
      (r = window.scrollY)
  }
  return { isStuck: a, stickyStyles: o }
}
const jP = 100,
  UP = 20
function xg(e) {
  const t = 1.41421356237
  return (e < 0 ? -1 : 1) * Math.sqrt(Math.abs(e)) * t
}
function wg(e) {
  if (e.length < 2) return 0
  if (e.length === 2) return e[1].t === e[0].t ? 0 : (e[1].d - e[0].d) / (e[1].t - e[0].t)
  let t = 0
  for (let n = e.length - 1; n > 0; n--) {
    if (e[n].t === e[n - 1].t) continue
    const i = xg(t),
      a = (e[n].d - e[n - 1].d) / (e[n].t - e[n - 1].t)
    ;(t += (a - i) * Math.abs(a)), n === e.length - 1 && (t *= 0.5)
  }
  return xg(t) * 1e3
}
function YP() {
  const e = {}
  function t(a) {
    Array.from(a.changedTouches).forEach((s) => {
      ;(e[s.identifier] ?? (e[s.identifier] = new ik(UP))).push([a.timeStamp, s])
    })
  }
  function n(a) {
    Array.from(a.changedTouches).forEach((s) => {
      delete e[s.identifier]
    })
  }
  function i(a) {
    var c
    const s = (c = e[a]) == null ? void 0 : c.values().reverse()
    if (!s) throw new Error(`No samples for touch id ${a}`)
    const o = s[0],
      r = [],
      l = []
    for (const u of s) {
      if (o[0] - u[0] > jP) break
      r.push({ t: u[0], d: u[1].clientX }), l.push({ t: u[0], d: u[1].clientY })
    }
    return {
      x: wg(r),
      y: wg(l),
      get direction() {
        const { x: u, y: d } = this,
          [f, h] = [Math.abs(u), Math.abs(d)]
        return f > h && u >= 0
          ? 'right'
          : f > h && u <= 0
          ? 'left'
          : h > f && d >= 0
          ? 'down'
          : h > f && d <= 0
          ? 'up'
          : GP()
      }
    }
  }
  return { addMovement: t, endTouch: n, getVelocity: i }
}
function GP() {
  throw new Error()
}
function XP(e) {
  let { isActive: t, isTemporary: n, width: i, touchless: a, position: s } = e
  tn(() => {
    window.addEventListener('touchstart', y, { passive: !0 }),
      window.addEventListener('touchmove', b, { passive: !1 }),
      window.addEventListener('touchend', x, { passive: !0 })
  }),
    _n(() => {
      window.removeEventListener('touchstart', y),
        window.removeEventListener('touchmove', b),
        window.removeEventListener('touchend', x)
    })
  const o = A(() => ['left', 'right'].includes(s.value)),
    { addMovement: r, endTouch: l, getVelocity: c } = YP()
  let u = !1
  const d = Ce(!1),
    f = Ce(0),
    h = Ce(0)
  let v
  function g(C, P) {
    return (
      (s.value === 'left'
        ? C
        : s.value === 'right'
        ? document.documentElement.clientWidth - C
        : s.value === 'top'
        ? C
        : s.value === 'bottom'
        ? document.documentElement.clientHeight - C
        : Es()) - (P ? i.value : 0)
    )
  }
  function p(C) {
    let P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
    const k =
      s.value === 'left'
        ? (C - h.value) / i.value
        : s.value === 'right'
        ? (document.documentElement.clientWidth - C - h.value) / i.value
        : s.value === 'top'
        ? (C - h.value) / i.value
        : s.value === 'bottom'
        ? (document.documentElement.clientHeight - C - h.value) / i.value
        : Es()
    return P ? Math.max(0, Math.min(1, k)) : k
  }
  function y(C) {
    if (a.value) return
    const P = C.changedTouches[0].clientX,
      k = C.changedTouches[0].clientY,
      S = 25,
      _ =
        s.value === 'left'
          ? P < S
          : s.value === 'right'
          ? P > document.documentElement.clientWidth - S
          : s.value === 'top'
          ? k < S
          : s.value === 'bottom'
          ? k > document.documentElement.clientHeight - S
          : Es(),
      T =
        t.value &&
        (s.value === 'left'
          ? P < i.value
          : s.value === 'right'
          ? P > document.documentElement.clientWidth - i.value
          : s.value === 'top'
          ? k < i.value
          : s.value === 'bottom'
          ? k > document.documentElement.clientHeight - i.value
          : Es())
    ;(_ || T || (t.value && n.value)) &&
      ((u = !0),
      (v = [P, k]),
      (h.value = g(o.value ? P : k, t.value)),
      (f.value = p(o.value ? P : k)),
      l(C),
      r(C))
  }
  function b(C) {
    const P = C.changedTouches[0].clientX,
      k = C.changedTouches[0].clientY
    if (u) {
      if (!C.cancelable) {
        u = !1
        return
      }
      const _ = Math.abs(P - v[0]),
        T = Math.abs(k - v[1])
      ;(o.value ? _ > T && _ > 3 : T > _ && T > 3)
        ? ((d.value = !0), (u = !1))
        : (o.value ? T : _) > 3 && (u = !1)
    }
    if (!d.value) return
    C.preventDefault(), r(C)
    const S = p(o.value ? P : k, !1)
    ;(f.value = Math.max(0, Math.min(1, S))),
      S > 1 ? (h.value = g(o.value ? P : k, !0)) : S < 0 && (h.value = g(o.value ? P : k, !1))
  }
  function x(C) {
    if (((u = !1), !d.value)) return
    r(C), (d.value = !1)
    const P = c(C.changedTouches[0].identifier),
      k = Math.abs(P.x),
      S = Math.abs(P.y)
    ;(o.value ? k > S && k > 400 : S > k && S > 3)
      ? (t.value =
          P.direction === ({ left: 'right', right: 'left', top: 'down', bottom: 'up' }[s.value] || Es()))
      : (t.value = f.value > 0.5)
  }
  const w = A(() =>
    d.value
      ? {
          transform:
            s.value === 'left'
              ? `translateX(calc(-100% + ${f.value * i.value}px))`
              : s.value === 'right'
              ? `translateX(calc(100% - ${f.value * i.value}px))`
              : s.value === 'top'
              ? `translateY(calc(-100% + ${f.value * i.value}px))`
              : s.value === 'bottom'
              ? `translateY(calc(100% - ${f.value * i.value}px))`
              : Es(),
          transition: 'none'
        }
      : void 0
  )
  return { isDragging: d, dragProgress: f, dragStyles: w }
}
function Es() {
  throw new Error()
}
const KP = ['start', 'end', 'left', 'right', 'top', 'bottom'],
  qP = ee(
    {
      color: String,
      disableResizeWatcher: Boolean,
      disableRouteWatcher: Boolean,
      expandOnHover: Boolean,
      floating: Boolean,
      modelValue: { type: Boolean, default: null },
      permanent: Boolean,
      rail: { type: Boolean, default: null },
      railWidth: { type: [Number, String], default: 56 },
      scrim: { type: [Boolean, String], default: !0 },
      image: String,
      temporary: Boolean,
      touchless: Boolean,
      width: { type: [Number, String], default: 256 },
      location: { type: String, default: 'start', validator: (e) => KP.includes(e) },
      sticky: Boolean,
      ...Bn(),
      ...Me(),
      ...Yt(),
      ...uo(),
      ...kt(),
      ...Ke({ tag: 'nav' }),
      ...ot()
    },
    'VNavigationDrawer'
  ),
  ZP = fe()({
    name: 'VNavigationDrawer',
    props: qP(),
    emits: { 'update:modelValue': (e) => !0, 'update:rail': (e) => !0 },
    setup(e, t) {
      let { attrs: n, emit: i, slots: a } = t
      const { isRtl: s } = Qt(),
        { themeClasses: o } = ut(e),
        { borderClasses: r } = Jn(e),
        { backgroundColorClasses: l, backgroundColorStyles: c } = Rt(ve(e, 'color')),
        { elevationClasses: u } = nn(e),
        { mobile: d } = bs(),
        { roundedClasses: f } = Lt(e),
        h = Ty(),
        v = Ge(e, 'modelValue', null, (oe) => !!oe),
        { ssrBootStyles: g } = _s(),
        { scopeId: p } = _o(),
        y = te(),
        b = Ce(!1),
        x = A(() =>
          e.rail && e.expandOnHover && b.value ? Number(e.width) : Number(e.rail ? e.railWidth : e.width)
        ),
        w = A(() => dd(e.location, s.value)),
        C = A(() => !e.permanent && (d.value || e.temporary)),
        P = A(() => e.sticky && !C.value && w.value !== 'bottom')
      e.expandOnHover && e.rail != null && Pe(b, (oe) => i('update:rail', !oe)),
        e.disableResizeWatcher || Pe(C, (oe) => !e.permanent && mt(() => (v.value = !oe))),
        !e.disableRouteWatcher && h && Pe(h.currentRoute, () => C.value && (v.value = !1)),
        Pe(
          () => e.permanent,
          (oe) => {
            oe && (v.value = !0)
          }
        ),
        Ic(() => {
          e.modelValue != null || C.value || (v.value = e.permanent || !d.value)
        })
      const {
          isDragging: k,
          dragProgress: S,
          dragStyles: _
        } = XP({ isActive: v, isTemporary: C, width: x, touchless: ve(e, 'touchless'), position: w }),
        T = A(() => {
          const oe = C.value ? 0 : e.rail && e.expandOnHover ? Number(e.railWidth) : x.value
          return k.value ? oe * S.value : oe
        }),
        { layoutItemStyles: B, layoutItemScrimStyles: O } = fo({
          id: e.name,
          order: A(() => parseInt(e.order, 10)),
          position: w,
          layoutSize: T,
          elementSize: x,
          active: A(() => v.value || k.value),
          disableTransitions: A(() => k.value),
          absolute: A(() => e.absolute || (P.value && typeof N.value != 'string'))
        }),
        { isStuck: N, stickyStyles: Q } = WP({ rootEl: y, isSticky: P, layoutItemStyles: B }),
        ue = Rt(A(() => (typeof e.scrim == 'string' ? e.scrim : null))),
        j = A(() => ({ ...(k.value ? { opacity: S.value * 0.2, transition: 'none' } : void 0), ...O.value }))
      zt({ VList: { bgColor: 'transparent' } })
      function U() {
        b.value = !0
      }
      function X() {
        b.value = !1
      }
      return (
        ge(() => {
          const oe = a.image || e.image
          return m(Oe, null, [
            m(
              e.tag,
              xe(
                {
                  ref: y,
                  onMouseenter: U,
                  onMouseleave: X,
                  class: [
                    'v-navigation-drawer',
                    `v-navigation-drawer--${w.value}`,
                    {
                      'v-navigation-drawer--expand-on-hover': e.expandOnHover,
                      'v-navigation-drawer--floating': e.floating,
                      'v-navigation-drawer--is-hovering': b.value,
                      'v-navigation-drawer--rail': e.rail,
                      'v-navigation-drawer--temporary': C.value,
                      'v-navigation-drawer--active': v.value,
                      'v-navigation-drawer--sticky': P.value
                    },
                    o.value,
                    l.value,
                    r.value,
                    u.value,
                    f.value,
                    e.class
                  ],
                  style: [c.value, B.value, _.value, g.value, Q.value, e.style]
                },
                p,
                n
              ),
              {
                default: () => {
                  var de, ce, Te, $e
                  return [
                    oe &&
                      m('div', { key: 'image', class: 'v-navigation-drawer__img' }, [
                        a.image
                          ? (de = a.image) == null
                            ? void 0
                            : de.call(a, { image: e.image })
                          : m('img', { src: e.image, alt: '' }, null)
                      ]),
                    a.prepend &&
                      m('div', { class: 'v-navigation-drawer__prepend' }, [
                        (ce = a.prepend) == null ? void 0 : ce.call(a)
                      ]),
                    m('div', { class: 'v-navigation-drawer__content' }, [
                      (Te = a.default) == null ? void 0 : Te.call(a)
                    ]),
                    a.append &&
                      m('div', { class: 'v-navigation-drawer__append' }, [
                        ($e = a.append) == null ? void 0 : $e.call(a)
                      ])
                  ]
                }
              }
            ),
            m(
              Pi,
              { name: 'fade-transition' },
              {
                default: () => [
                  C.value &&
                    (k.value || v.value) &&
                    !!e.scrim &&
                    m(
                      'div',
                      xe(
                        {
                          class: ['v-navigation-drawer__scrim', ue.backgroundColorClasses.value],
                          style: [j.value, ue.backgroundColorStyles.value],
                          onClick: () => (v.value = !1)
                        },
                        p
                      ),
                      null
                    )
                ]
              }
            )
          ])
        }),
        { isStuck: N }
      )
    }
  }),
  JP = Xn({
    name: 'VNoSsr',
    setup(e, t) {
      let { slots: n } = t
      const i = fb()
      return () => {
        var a
        return i.value && ((a = n.default) == null ? void 0 : a.call(n))
      }
    }
  })
function QP() {
  const e = te([])
  _0(() => (e.value = []))
  function t(n, i) {
    e.value[i] = n
  }
  return { refs: e, updateRef: t }
}
const eT = ee(
    {
      activeColor: String,
      start: { type: [Number, String], default: 1 },
      modelValue: { type: Number, default: (e) => e.start },
      disabled: Boolean,
      length: { type: [Number, String], default: 1, validator: (e) => e % 1 === 0 },
      totalVisible: [Number, String],
      firstIcon: { type: Ye, default: '$first' },
      prevIcon: { type: Ye, default: '$prev' },
      nextIcon: { type: Ye, default: '$next' },
      lastIcon: { type: Ye, default: '$last' },
      ariaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.root' },
      pageAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.page' },
      currentPageAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.currentPage' },
      firstAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.first' },
      previousAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.previous' },
      nextAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.next' },
      lastAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.last' },
      ellipsis: { type: String, default: '...' },
      showFirstLastPage: Boolean,
      ...Bn(),
      ...Me(),
      ...Gt(),
      ...Yt(),
      ...kt(),
      ...oa(),
      ...Ke({ tag: 'nav' }),
      ...ot(),
      ...Qn({ variant: 'text' })
    },
    'VPagination'
  ),
  tT = fe()({
    name: 'VPagination',
    props: eT(),
    emits: {
      'update:modelValue': (e) => !0,
      first: (e) => !0,
      prev: (e) => !0,
      next: (e) => !0,
      last: (e) => !0
    },
    setup(e, t) {
      let { slots: n, emit: i } = t
      const a = Ge(e, 'modelValue'),
        { t: s, n: o } = Kn(),
        { isRtl: r } = Qt(),
        { themeClasses: l } = ut(e),
        { width: c } = bs(),
        u = Ce(-1)
      zt(void 0, { scoped: !0 })
      const { resizeRef: d } = Ti((S) => {
          if (!S.length) return
          const { target: _, contentRect: T } = S[0],
            B = _.querySelector('.v-pagination__list > *')
          if (!B) return
          const O = T.width,
            N = B.offsetWidth + parseFloat(getComputedStyle(B).marginRight) * 2
          u.value = g(O, N)
        }),
        f = A(() => parseInt(e.length, 10)),
        h = A(() => parseInt(e.start, 10)),
        v = A(() => (e.totalVisible ? parseInt(e.totalVisible, 10) : u.value >= 0 ? u.value : g(c.value, 58)))
      function g(S, _) {
        const T = e.showFirstLastPage ? 5 : 3
        return Math.max(0, Math.floor(+((S - _ * T) / _).toFixed(2)))
      }
      const p = A(() => {
        if (f.value <= 0 || isNaN(f.value) || f.value > Number.MAX_SAFE_INTEGER) return []
        if (v.value <= 1) return [a.value]
        if (f.value <= v.value) return ji(f.value, h.value)
        const S = v.value % 2 === 0,
          _ = S ? v.value / 2 : Math.floor(v.value / 2),
          T = S ? _ : _ + 1,
          B = f.value - _
        if (T - a.value >= 0) return [...ji(Math.max(1, v.value - 1), h.value), e.ellipsis, f.value]
        if (a.value - B >= (S ? 1 : 0)) {
          const O = v.value - 1,
            N = f.value - O + h.value
          return [h.value, e.ellipsis, ...ji(O, N)]
        } else {
          const O = Math.max(1, v.value - 3),
            N = O === 1 ? a.value : a.value - Math.ceil(O / 2) + h.value
          return [h.value, e.ellipsis, ...ji(O, N), e.ellipsis, f.value]
        }
      })
      function y(S, _, T) {
        S.preventDefault(), (a.value = _), T && i(T, _)
      }
      const { refs: b, updateRef: x } = QP()
      zt({
        VPaginationBtn: {
          color: ve(e, 'color'),
          border: ve(e, 'border'),
          density: ve(e, 'density'),
          size: ve(e, 'size'),
          variant: ve(e, 'variant'),
          rounded: ve(e, 'rounded'),
          elevation: ve(e, 'elevation')
        }
      })
      const w = A(() =>
          p.value.map((S, _) => {
            const T = (B) => x(B, _)
            if (typeof S == 'string')
              return {
                isActive: !1,
                key: `ellipsis-${_}`,
                page: S,
                props: { ref: T, ellipsis: !0, icon: !0, disabled: !0 }
              }
            {
              const B = S === a.value
              return {
                isActive: B,
                key: S,
                page: o(S),
                props: {
                  ref: T,
                  ellipsis: !1,
                  icon: !0,
                  disabled: !!e.disabled || +e.length < 2,
                  color: B ? e.activeColor : e.color,
                  ariaCurrent: B,
                  ariaLabel: s(B ? e.currentPageAriaLabel : e.pageAriaLabel, S),
                  onClick: (O) => y(O, S)
                }
              }
            }
          })
        ),
        C = A(() => {
          const S = !!e.disabled || a.value <= h.value,
            _ = !!e.disabled || a.value >= h.value + f.value - 1
          return {
            first: e.showFirstLastPage
              ? {
                  icon: r.value ? e.lastIcon : e.firstIcon,
                  onClick: (T) => y(T, h.value, 'first'),
                  disabled: S,
                  ariaLabel: s(e.firstAriaLabel),
                  ariaDisabled: S
                }
              : void 0,
            prev: {
              icon: r.value ? e.nextIcon : e.prevIcon,
              onClick: (T) => y(T, a.value - 1, 'prev'),
              disabled: S,
              ariaLabel: s(e.previousAriaLabel),
              ariaDisabled: S
            },
            next: {
              icon: r.value ? e.prevIcon : e.nextIcon,
              onClick: (T) => y(T, a.value + 1, 'next'),
              disabled: _,
              ariaLabel: s(e.nextAriaLabel),
              ariaDisabled: _
            },
            last: e.showFirstLastPage
              ? {
                  icon: r.value ? e.firstIcon : e.lastIcon,
                  onClick: (T) => y(T, h.value + f.value - 1, 'last'),
                  disabled: _,
                  ariaLabel: s(e.lastAriaLabel),
                  ariaDisabled: _
                }
              : void 0
          }
        })
      function P() {
        var _
        const S = a.value - h.value
        ;(_ = b.value[S]) == null || _.$el.focus()
      }
      function k(S) {
        S.key === cd.left && !e.disabled && a.value > +e.start
          ? ((a.value = a.value - 1), mt(P))
          : S.key === cd.right &&
            !e.disabled &&
            a.value < h.value + f.value - 1 &&
            ((a.value = a.value + 1), mt(P))
      }
      return (
        ge(() =>
          m(
            e.tag,
            {
              ref: d,
              class: ['v-pagination', l.value, e.class],
              style: e.style,
              role: 'navigation',
              'aria-label': s(e.ariaLabel),
              onKeydown: k,
              'data-test': 'v-pagination-root'
            },
            {
              default: () => [
                m('ul', { class: 'v-pagination__list' }, [
                  e.showFirstLastPage &&
                    m(
                      'li',
                      { key: 'first', class: 'v-pagination__first', 'data-test': 'v-pagination-first' },
                      [
                        n.first
                          ? n.first(C.value.first)
                          : m(bn, xe({ _as: 'VPaginationBtn' }, C.value.first), null)
                      ]
                    ),
                  m('li', { key: 'prev', class: 'v-pagination__prev', 'data-test': 'v-pagination-prev' }, [
                    n.prev ? n.prev(C.value.prev) : m(bn, xe({ _as: 'VPaginationBtn' }, C.value.prev), null)
                  ]),
                  w.value.map((S, _) =>
                    m(
                      'li',
                      {
                        key: S.key,
                        class: ['v-pagination__item', { 'v-pagination__item--is-active': S.isActive }],
                        'data-test': 'v-pagination-item'
                      },
                      [
                        n.item
                          ? n.item(S)
                          : m(bn, xe({ _as: 'VPaginationBtn' }, S.props), { default: () => [S.page] })
                      ]
                    )
                  ),
                  m('li', { key: 'next', class: 'v-pagination__next', 'data-test': 'v-pagination-next' }, [
                    n.next ? n.next(C.value.next) : m(bn, xe({ _as: 'VPaginationBtn' }, C.value.next), null)
                  ]),
                  e.showFirstLastPage &&
                    m('li', { key: 'last', class: 'v-pagination__last', 'data-test': 'v-pagination-last' }, [
                      n.last ? n.last(C.value.last) : m(bn, xe({ _as: 'VPaginationBtn' }, C.value.last), null)
                    ])
                ])
              ]
            }
          )
        ),
        {}
      )
    }
  })
function nT(e) {
  return Math.floor(Math.abs(e)) * Math.sign(e)
}
const iT = ee({ scale: { type: [Number, String], default: 0.5 }, ...Me() }, 'VParallax'),
  aT = fe()({
    name: 'VParallax',
    props: iT(),
    setup(e, t) {
      let { slots: n } = t
      const { intersectionRef: i, isIntersecting: a } = eh(),
        { resizeRef: s, contentRect: o } = Ti(),
        { height: r } = bs(),
        l = te()
      Ut(() => {
        var h
        i.value = s.value = (h = l.value) == null ? void 0 : h.$el
      })
      let c
      Pe(a, (h) => {
        h
          ? ((c = Wf(i.value)),
            (c = c === document.scrollingElement ? document : c),
            c.addEventListener('scroll', f, { passive: !0 }),
            f())
          : c.removeEventListener('scroll', f)
      }),
        _n(() => {
          c == null || c.removeEventListener('scroll', f)
        }),
        Pe(r, f),
        Pe(() => {
          var h
          return (h = o.value) == null ? void 0 : h.height
        }, f)
      const u = A(() => 1 - cn(+e.scale))
      let d = -1
      function f() {
        a.value &&
          (cancelAnimationFrame(d),
          (d = requestAnimationFrame(() => {
            var C
            const h = ((C = l.value) == null ? void 0 : C.$el).querySelector('.v-img__img')
            if (!h) return
            const v = c instanceof Document ? document.documentElement.clientHeight : c.clientHeight,
              g = c instanceof Document ? window.scrollY : c.scrollTop,
              p = i.value.getBoundingClientRect().top + g,
              y = o.value.height,
              b = p + (y - v) / 2,
              x = nT((g - b) * u.value),
              w = Math.max(1, (u.value * (v - y) + y) / y)
            h.style.setProperty('transform', `translateY(${x}px) scale(${w})`)
          })))
      }
      return (
        ge(() =>
          m(
            fs,
            {
              class: ['v-parallax', { 'v-parallax--active': a.value }, e.class],
              style: e.style,
              ref: l,
              cover: !0,
              onLoadstart: f,
              onLoad: f
            },
            n
          )
        ),
        {}
      )
    }
  }),
  sT = ee({ ...Wc({ falseIcon: '$radioOff', trueIcon: '$radioOn' }) }, 'VRadio'),
  oT = fe()({
    name: 'VRadio',
    props: sT(),
    setup(e, t) {
      let { slots: n } = t
      return ge(() => m(hs, xe(e, { class: ['v-radio', e.class], style: e.style, type: 'radio' }), n)), {}
    }
  })
const rT = ee(
    {
      height: { type: [Number, String], default: 'auto' },
      ...ra(),
      ...Gn(oh(), ['multiple']),
      trueIcon: { type: Ye, default: '$radioOn' },
      falseIcon: { type: Ye, default: '$radioOff' },
      type: { type: String, default: 'radio' }
    },
    'VRadioGroup'
  ),
  lT = fe()({
    name: 'VRadioGroup',
    inheritAttrs: !1,
    props: rT(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const a = vn(),
        s = A(() => e.id || `radio-group-${a}`),
        o = Ge(e, 'modelValue')
      return (
        ge(() => {
          const [r, l] = ys(n),
            [c, u] = en.filterProps(e),
            [d, f] = hs.filterProps(e),
            h = i.label ? i.label({ label: e.label, props: { for: s.value } }) : e.label
          return m(
            en,
            xe({ class: ['v-radio-group', e.class], style: e.style }, r, c, {
              modelValue: o.value,
              'onUpdate:modelValue': (v) => (o.value = v),
              id: s.value
            }),
            {
              ...i,
              default: (v) => {
                let { id: g, messagesId: p, isDisabled: y, isReadonly: b } = v
                return m(Oe, null, [
                  h && m(bo, { id: g.value }, { default: () => [h] }),
                  m(
                    $y,
                    xe(
                      d,
                      {
                        id: g.value,
                        'aria-describedby': p.value,
                        defaultsTarget: 'VRadio',
                        trueIcon: e.trueIcon,
                        falseIcon: e.falseIcon,
                        type: e.type,
                        disabled: y.value,
                        readonly: b.value,
                        'aria-labelledby': h ? g.value : void 0,
                        multiple: !1
                      },
                      l,
                      { modelValue: o.value, 'onUpdate:modelValue': (x) => (o.value = x) }
                    ),
                    i
                  )
                ])
              }
            }
          )
        }),
        {}
      )
    }
  }),
  cT = ee(
    { ...jc(), ...ra(), ...Lb(), strict: Boolean, modelValue: { type: Array, default: () => [0, 0] } },
    'VRangeSlider'
  ),
  uT = fe()({
    name: 'VRangeSlider',
    props: cT(),
    emits: { 'update:focused': (e) => !0, 'update:modelValue': (e) => !0, end: (e) => !0, start: (e) => !0 },
    setup(e, t) {
      let { slots: n, emit: i } = t
      const a = te(),
        s = te(),
        o = te(),
        { rtlClasses: r } = Qt()
      function l(_) {
        if (!a.value || !s.value) return
        const T = Od(_, a.value.$el, e.direction),
          B = Od(_, s.value.$el, e.direction),
          O = Math.abs(T),
          N = Math.abs(B)
        return O < N || (O === N && T < 0) ? a.value.$el : s.value.$el
      }
      const c = Ob(e),
        u = Ge(e, 'modelValue', void 0, (_) =>
          _ != null && _.length ? _.map((T) => c.roundValue(T)) : [0, 0]
        ),
        {
          activeThumbRef: d,
          hasLabels: f,
          max: h,
          min: v,
          mousePressed: g,
          onSliderMousedown: p,
          onSliderTouchstart: y,
          position: b,
          trackContainerRef: x
        } = Ib({
          props: e,
          steps: c,
          onSliderStart: () => {
            i('start', u.value)
          },
          onSliderEnd: (_) => {
            var O
            let { value: T } = _
            const B = d.value === ((O = a.value) == null ? void 0 : O.$el) ? [T, u.value[1]] : [u.value[0], T]
            !e.strict && B[0] < B[1] && (u.value = B), i('end', u.value)
          },
          onSliderMove: (_) => {
            var N, Q, ue, j
            let { value: T } = _
            const [B, O] = u.value
            !e.strict &&
              B === O &&
              B !== v.value &&
              ((d.value =
                T > B ? ((N = s.value) == null ? void 0 : N.$el) : (Q = a.value) == null ? void 0 : Q.$el),
              (ue = d.value) == null || ue.focus()),
              d.value === ((j = a.value) == null ? void 0 : j.$el)
                ? (u.value = [Math.min(T, O), O])
                : (u.value = [B, Math.max(B, T)])
          },
          getActiveThumb: l
        }),
        { isFocused: w, focus: C, blur: P } = Fa(e),
        k = A(() => b(u.value[0])),
        S = A(() => b(u.value[1]))
      return (
        ge(() => {
          const [_, T] = en.filterProps(e),
            B = !!(e.label || n.label || n.prepend)
          return m(
            en,
            xe(
              {
                class: [
                  'v-slider',
                  'v-range-slider',
                  {
                    'v-slider--has-labels': !!n['tick-label'] || f.value,
                    'v-slider--focused': w.value,
                    'v-slider--pressed': g.value,
                    'v-slider--disabled': e.disabled
                  },
                  r.value,
                  e.class
                ],
                style: e.style,
                ref: o
              },
              _,
              { focused: w.value }
            ),
            {
              ...n,
              prepend: B
                ? (O) => {
                    var N, Q
                    return m(Oe, null, [
                      ((N = n.label) == null ? void 0 : N.call(n, O)) ??
                        (e.label ? m(bo, { class: 'v-slider__label', text: e.label }, null) : void 0),
                      (Q = n.prepend) == null ? void 0 : Q.call(n, O)
                    ])
                  }
                : void 0,
              default: (O) => {
                var ue, j
                let { id: N, messagesId: Q } = O
                return m('div', { class: 'v-slider__container', onMousedown: p, onTouchstartPassive: y }, [
                  m(
                    'input',
                    {
                      id: `${N.value}_start`,
                      name: e.name || N.value,
                      disabled: !!e.disabled,
                      readonly: !!e.readonly,
                      tabindex: '-1',
                      value: u.value[0]
                    },
                    null
                  ),
                  m(
                    'input',
                    {
                      id: `${N.value}_stop`,
                      name: e.name || N.value,
                      disabled: !!e.disabled,
                      readonly: !!e.readonly,
                      tabindex: '-1',
                      value: u.value[1]
                    },
                    null
                  ),
                  m(Db, { ref: x, start: k.value, stop: S.value }, { 'tick-label': n['tick-label'] }),
                  m(
                    Id,
                    {
                      ref: a,
                      'aria-describedby': Q.value,
                      focused: w && d.value === ((ue = a.value) == null ? void 0 : ue.$el),
                      modelValue: u.value[0],
                      'onUpdate:modelValue': (U) => (u.value = [U, u.value[1]]),
                      onFocus: (U) => {
                        var X, oe, de, ce
                        C(),
                          (d.value = (X = a.value) == null ? void 0 : X.$el),
                          u.value[0] === u.value[1] &&
                            u.value[1] === v.value &&
                            U.relatedTarget !== ((oe = s.value) == null ? void 0 : oe.$el) &&
                            ((de = a.value) == null || de.$el.blur(),
                            (ce = s.value) == null || ce.$el.focus())
                      },
                      onBlur: () => {
                        P(), (d.value = void 0)
                      },
                      min: v.value,
                      max: u.value[1],
                      position: k.value
                    },
                    { 'thumb-label': n['thumb-label'] }
                  ),
                  m(
                    Id,
                    {
                      ref: s,
                      'aria-describedby': Q.value,
                      focused: w && d.value === ((j = s.value) == null ? void 0 : j.$el),
                      modelValue: u.value[1],
                      'onUpdate:modelValue': (U) => (u.value = [u.value[0], U]),
                      onFocus: (U) => {
                        var X, oe, de, ce
                        C(),
                          (d.value = (X = s.value) == null ? void 0 : X.$el),
                          u.value[0] === u.value[1] &&
                            u.value[0] === h.value &&
                            U.relatedTarget !== ((oe = a.value) == null ? void 0 : oe.$el) &&
                            ((de = s.value) == null || de.$el.blur(),
                            (ce = a.value) == null || ce.$el.focus())
                      },
                      onBlur: () => {
                        P(), (d.value = void 0)
                      },
                      min: u.value[0],
                      max: h.value,
                      position: S.value
                    },
                    { 'thumb-label': n['thumb-label'] }
                  )
                ])
              }
            }
          )
        }),
        {}
      )
    }
  })
const dT = ee(
    {
      name: String,
      itemAriaLabel: { type: String, default: '$vuetify.rating.ariaLabel.item' },
      activeColor: String,
      color: String,
      clearable: Boolean,
      disabled: Boolean,
      emptyIcon: { type: Ye, default: '$ratingEmpty' },
      fullIcon: { type: Ye, default: '$ratingFull' },
      halfIncrements: Boolean,
      hover: Boolean,
      length: { type: [Number, String], default: 5 },
      readonly: Boolean,
      modelValue: { type: [Number, String], default: 0 },
      itemLabels: Array,
      itemLabelPosition: { type: String, default: 'top', validator: (e) => ['top', 'bottom'].includes(e) },
      ripple: Boolean,
      ...Me(),
      ...Gt(),
      ...oa(),
      ...Ke(),
      ...ot()
    },
    'VRating'
  ),
  fT = fe()({
    name: 'VRating',
    props: dT(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { t: i } = Kn(),
        { themeClasses: a } = ut(e),
        s = Ge(e, 'modelValue'),
        o = A(() => cn(parseFloat(s.value), 0, +e.length)),
        r = A(() => ji(Number(e.length), 1)),
        l = A(() => r.value.flatMap((g) => (e.halfIncrements ? [g - 0.5, g] : [g]))),
        c = Ce(-1),
        u = A(() =>
          l.value.map((g) => {
            const p = e.hover && c.value > -1,
              y = o.value >= g,
              b = c.value >= g,
              w = (p ? b : y) ? e.fullIcon : e.emptyIcon,
              C = e.activeColor ?? e.color,
              P = y || b ? C : e.color
            return { isFilled: y, isHovered: b, icon: w, color: P }
          })
        ),
        d = A(() =>
          [0, ...l.value].map((g) => {
            function p() {
              c.value = g
            }
            function y() {
              c.value = -1
            }
            function b() {
              e.disabled || e.readonly || (s.value = o.value === g && e.clearable ? 0 : g)
            }
            return { onMouseenter: e.hover ? p : void 0, onMouseleave: e.hover ? y : void 0, onClick: b }
          })
        ),
        f = A(() => e.name ?? `v-rating-${vn()}`)
      function h(g) {
        var S, _
        let { value: p, index: y, showStar: b = !0 } = g
        const { onMouseenter: x, onMouseleave: w, onClick: C } = d.value[y + 1],
          P = `${f.value}-${String(p).replace('.', '-')}`,
          k = {
            color: (S = u.value[y]) == null ? void 0 : S.color,
            density: e.density,
            disabled: e.disabled,
            icon: (_ = u.value[y]) == null ? void 0 : _.icon,
            ripple: e.ripple,
            size: e.size,
            variant: 'plain'
          }
        return m(Oe, null, [
          m(
            'label',
            {
              for: P,
              class: {
                'v-rating__item--half': e.halfIncrements && p % 1 > 0,
                'v-rating__item--full': e.halfIncrements && p % 1 === 0
              },
              onMouseenter: x,
              onMouseleave: w,
              onClick: C
            },
            [
              m('span', { class: 'v-rating__hidden' }, [i(e.itemAriaLabel, p, e.length)]),
              b
                ? n.item
                  ? n.item({ ...u.value[y], props: k, value: p, index: y, rating: o.value })
                  : m(bn, xe({ 'aria-label': i(e.itemAriaLabel, p, e.length) }, k), null)
                : void 0
            ]
          ),
          m(
            'input',
            {
              class: 'v-rating__hidden',
              name: f.value,
              id: P,
              type: 'radio',
              value: p,
              checked: o.value === p,
              tabindex: -1,
              readonly: e.readonly,
              disabled: e.disabled
            },
            null
          )
        ])
      }
      function v(g) {
        return n['item-label']
          ? n['item-label'](g)
          : g.label
          ? m('span', null, [g.label])
          : m('span', null, [nt(' ')])
      }
      return (
        ge(() => {
          var p
          const g = !!((p = e.itemLabels) != null && p.length) || n['item-label']
          return m(
            e.tag,
            {
              class: [
                'v-rating',
                { 'v-rating--hover': e.hover, 'v-rating--readonly': e.readonly },
                a.value,
                e.class
              ],
              style: e.style
            },
            {
              default: () => [
                m(h, { value: 0, index: -1, showStar: !1 }, null),
                r.value.map((y, b) => {
                  var x, w
                  return m('div', { class: 'v-rating__wrapper' }, [
                    g && e.itemLabelPosition === 'top'
                      ? v({ value: y, index: b, label: (x = e.itemLabels) == null ? void 0 : x[b] })
                      : void 0,
                    m('div', { class: 'v-rating__item' }, [
                      e.halfIncrements
                        ? m(Oe, null, [
                            m(h, { value: y - 0.5, index: b * 2 }, null),
                            m(h, { value: y, index: b * 2 + 1 }, null)
                          ])
                        : m(h, { value: y, index: b }, null)
                    ]),
                    g && e.itemLabelPosition === 'bottom'
                      ? v({ value: y, index: b, label: (w = e.itemLabels) == null ? void 0 : w[b] })
                      : void 0
                  ])
                })
              ]
            }
          )
        }),
        {}
      )
    }
  })
function Sg(e) {
  const n = Math.abs(e)
  return Math.sign(e) * (n / ((1 / 0.501 - 2) * (1 - n) + 1))
}
function kg(e) {
  let {
    selectedElement: t,
    containerSize: n,
    contentSize: i,
    isRtl: a,
    currentScrollOffset: s,
    isHorizontal: o
  } = e
  const r = o ? t.clientWidth : t.clientHeight,
    l = o ? t.offsetLeft : t.offsetTop,
    c = a && o ? i - l - r : l,
    u = n + s,
    d = r + c,
    f = r * 0.4
  return c <= s ? (s = Math.max(c - f, 0)) : u <= d && (s = Math.min(s - (u - d - f), i - n)), s
}
function hT(e) {
  let { selectedElement: t, containerSize: n, contentSize: i, isRtl: a, isHorizontal: s } = e
  const o = s ? t.clientWidth : t.clientHeight,
    r = s ? t.offsetLeft : t.offsetTop,
    l = a && s ? i - r - o / 2 - n / 2 : r + o / 2 - n / 2
  return Math.min(i - n, Math.max(0, l))
}
const Zb = Symbol.for('vuetify:v-slide-group'),
  Jb = ee(
    {
      centerActive: Boolean,
      direction: { type: String, default: 'horizontal' },
      symbol: { type: null, default: Zb },
      nextIcon: { type: Ye, default: '$next' },
      prevIcon: { type: Ye, default: '$prev' },
      showArrows: {
        type: [Boolean, String],
        validator: (e) => typeof e == 'boolean' || ['always', 'desktop', 'mobile'].includes(e)
      },
      ...Me(),
      ...Ke(),
      ...ho({ selectedClass: 'v-slide-group-item--active' })
    },
    'VSlideGroup'
  ),
  Rd = fe()({
    name: 'VSlideGroup',
    props: Jb(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { isRtl: i } = Qt(),
        { mobile: a } = bs(),
        s = Ss(e, e.symbol),
        o = Ce(!1),
        r = Ce(0),
        l = Ce(0),
        c = Ce(0),
        u = A(() => e.direction === 'horizontal'),
        { resizeRef: d, contentRect: f } = Ti(),
        { resizeRef: h, contentRect: v } = Ti(),
        g = A(() =>
          s.selected.value.length ? s.items.value.findIndex((de) => de.id === s.selected.value[0]) : -1
        ),
        p = A(() =>
          s.selected.value.length
            ? s.items.value.findIndex((de) => de.id === s.selected.value[s.selected.value.length - 1])
            : -1
        )
      if (yt) {
        let de = -1
        Pe(
          () => [s.selected.value, f.value, v.value, u.value],
          () => {
            cancelAnimationFrame(de),
              (de = requestAnimationFrame(() => {
                if (f.value && v.value) {
                  const ce = u.value ? 'width' : 'height'
                  ;(l.value = f.value[ce]), (c.value = v.value[ce]), (o.value = l.value + 1 < c.value)
                }
                if (g.value >= 0 && h.value) {
                  const ce = h.value.children[p.value]
                  g.value === 0 || !o.value
                    ? (r.value = 0)
                    : e.centerActive
                    ? (r.value = hT({
                        selectedElement: ce,
                        containerSize: l.value,
                        contentSize: c.value,
                        isRtl: i.value,
                        isHorizontal: u.value
                      }))
                    : o.value &&
                      (r.value = kg({
                        selectedElement: ce,
                        containerSize: l.value,
                        contentSize: c.value,
                        isRtl: i.value,
                        currentScrollOffset: r.value,
                        isHorizontal: u.value
                      }))
                }
              }))
          }
        )
      }
      const y = Ce(!1)
      let b = 0,
        x = 0
      function w(de) {
        const ce = u.value ? 'clientX' : 'clientY'
        ;(x = (i.value && u.value ? -1 : 1) * r.value), (b = de.touches[0][ce]), (y.value = !0)
      }
      function C(de) {
        if (!o.value) return
        const ce = u.value ? 'clientX' : 'clientY',
          Te = i.value && u.value ? -1 : 1
        r.value = Te * (x + b - de.touches[0][ce])
      }
      function P(de) {
        const ce = c.value - l.value
        r.value < 0 || !o.value ? (r.value = 0) : r.value >= ce && (r.value = ce), (y.value = !1)
      }
      function k() {
        d.value && (d.value[u.value ? 'scrollLeft' : 'scrollTop'] = 0)
      }
      const S = Ce(!1)
      function _(de) {
        if (((S.value = !0), !(!o.value || !h.value))) {
          for (const ce of de.composedPath())
            for (const Te of h.value.children)
              if (Te === ce) {
                r.value = kg({
                  selectedElement: Te,
                  containerSize: l.value,
                  contentSize: c.value,
                  isRtl: i.value,
                  currentScrollOffset: r.value,
                  isHorizontal: u.value
                })
                return
              }
        }
      }
      function T(de) {
        S.value = !1
      }
      function B(de) {
        var ce
        !S.value && !(de.relatedTarget && (ce = h.value) != null && ce.contains(de.relatedTarget)) && N()
      }
      function O(de) {
        h.value &&
          (u.value
            ? de.key === 'ArrowRight'
              ? N(i.value ? 'prev' : 'next')
              : de.key === 'ArrowLeft' && N(i.value ? 'next' : 'prev')
            : de.key === 'ArrowDown'
            ? N('next')
            : de.key === 'ArrowUp' && N('prev'),
          de.key === 'Home' ? N('first') : de.key === 'End' && N('last'))
      }
      function N(de) {
        var ce, Te, $e, He, Ue
        if (h.value)
          if (!de) (ce = _r(h.value)[0]) == null || ce.focus()
          else if (de === 'next') {
            const ie = (Te = h.value.querySelector(':focus')) == null ? void 0 : Te.nextElementSibling
            ie ? ie.focus() : N('first')
          } else if (de === 'prev') {
            const ie = ($e = h.value.querySelector(':focus')) == null ? void 0 : $e.previousElementSibling
            ie ? ie.focus() : N('last')
          } else
            de === 'first'
              ? (He = h.value.firstElementChild) == null || He.focus()
              : de === 'last' && ((Ue = h.value.lastElementChild) == null || Ue.focus())
      }
      function Q(de) {
        const ce = r.value + (de === 'prev' ? -1 : 1) * l.value
        r.value = cn(ce, 0, c.value - l.value)
      }
      const ue = A(() => {
          let de =
            r.value > c.value - l.value ? -(c.value - l.value) + Sg(c.value - l.value - r.value) : -r.value
          r.value <= 0 && (de = Sg(-r.value))
          const ce = i.value && u.value ? -1 : 1
          return {
            transform: `translate${u.value ? 'X' : 'Y'}(${ce * de}px)`,
            transition: y.value ? 'none' : '',
            willChange: y.value ? 'transform' : ''
          }
        }),
        j = A(() => ({ next: s.next, prev: s.prev, select: s.select, isSelected: s.isSelected })),
        U = A(() => {
          switch (e.showArrows) {
            case 'always':
              return !0
            case 'desktop':
              return !a.value
            case !0:
              return o.value || Math.abs(r.value) > 0
            case 'mobile':
              return a.value || o.value || Math.abs(r.value) > 0
            default:
              return !a.value && (o.value || Math.abs(r.value) > 0)
          }
        }),
        X = A(() => Math.abs(r.value) > 0),
        oe = A(() => c.value > Math.abs(r.value) + l.value)
      return (
        ge(() =>
          m(
            e.tag,
            {
              class: [
                'v-slide-group',
                {
                  'v-slide-group--vertical': !u.value,
                  'v-slide-group--has-affixes': U.value,
                  'v-slide-group--is-overflowing': o.value
                },
                e.class
              ],
              style: e.style,
              tabindex: S.value || s.selected.value.length ? -1 : 0,
              onFocus: B
            },
            {
              default: () => {
                var de, ce, Te
                return [
                  U.value &&
                    m(
                      'div',
                      {
                        key: 'prev',
                        class: ['v-slide-group__prev', { 'v-slide-group__prev--disabled': !X.value }],
                        onClick: () => Q('prev')
                      },
                      [
                        ((de = n.prev) == null ? void 0 : de.call(n, j.value)) ??
                          m(yd, null, {
                            default: () => [m(gt, { icon: i.value ? e.nextIcon : e.prevIcon }, null)]
                          })
                      ]
                    ),
                  m('div', { key: 'container', ref: d, class: 'v-slide-group__container', onScroll: k }, [
                    m(
                      'div',
                      {
                        ref: h,
                        class: 'v-slide-group__content',
                        style: ue.value,
                        onTouchstartPassive: w,
                        onTouchmovePassive: C,
                        onTouchendPassive: P,
                        onFocusin: _,
                        onFocusout: T,
                        onKeydown: O
                      },
                      [(ce = n.default) == null ? void 0 : ce.call(n, j.value)]
                    )
                  ]),
                  U.value &&
                    m(
                      'div',
                      {
                        key: 'next',
                        class: ['v-slide-group__next', { 'v-slide-group__next--disabled': !oe.value }],
                        onClick: () => Q('next')
                      },
                      [
                        ((Te = n.next) == null ? void 0 : Te.call(n, j.value)) ??
                          m(yd, null, {
                            default: () => [m(gt, { icon: i.value ? e.prevIcon : e.nextIcon }, null)]
                          })
                      ]
                    )
                ]
              }
            }
          )
        ),
        { selected: s.selected, scrollTo: Q, scrollOffset: r, focus: N }
      )
    }
  }),
  vT = fe()({
    name: 'VSlideGroupItem',
    props: vo(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = go(e, Zb)
      return () => {
        var a
        return (a = n.default) == null
          ? void 0
          : a.call(n, {
              isSelected: i.isSelected.value,
              select: i.select,
              toggle: i.toggle,
              selectedClass: i.selectedClass.value
            })
      }
    }
  })
const gT = ee(
    {
      multiLine: Boolean,
      timeout: { type: [Number, String], default: 5e3 },
      vertical: Boolean,
      ...Oa({ location: 'bottom' }),
      ...po(),
      ...kt(),
      ...Qn(),
      ...ot(),
      ...Gn(Yr({ transition: 'v-snackbar-transition' }), [
        'persistent',
        'noClickAnimation',
        'scrim',
        'scrollStrategy'
      ])
    },
    'VSnackbar'
  ),
  mT = fe()({
    name: 'VSnackbar',
    props: gT(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = Ge(e, 'modelValue'),
        { locationStyles: a } = Ia(e),
        { positionClasses: s } = yo(e),
        { scopeId: o } = _o(),
        { themeClasses: r } = ut(e),
        { colorClasses: l, colorStyles: c, variantClasses: u } = ws(e),
        { roundedClasses: d } = Lt(e),
        f = te()
      Pe(i, v),
        Pe(() => e.timeout, v),
        tn(() => {
          i.value && v()
        })
      let h = -1
      function v() {
        window.clearTimeout(h)
        const p = Number(e.timeout)
        !i.value ||
          p === -1 ||
          (h = window.setTimeout(() => {
            i.value = !1
          }, p))
      }
      function g() {
        window.clearTimeout(h)
      }
      return (
        ge(() => {
          const [p] = ea.filterProps(e)
          return m(
            ea,
            xe(
              {
                ref: f,
                class: [
                  'v-snackbar',
                  {
                    'v-snackbar--active': i.value,
                    'v-snackbar--multi-line': e.multiLine && !e.vertical,
                    'v-snackbar--vertical': e.vertical
                  },
                  s.value,
                  e.class
                ],
                style: e.style
              },
              p,
              {
                modelValue: i.value,
                'onUpdate:modelValue': (y) => (i.value = y),
                contentProps: xe(
                  {
                    class: ['v-snackbar__wrapper', r.value, l.value, d.value, u.value],
                    style: [a.value, c.value],
                    onPointerenter: g,
                    onPointerleave: v
                  },
                  p.contentProps
                ),
                persistent: !0,
                noClickAnimation: !0,
                scrim: !1,
                scrollStrategy: 'none',
                _disableGlobalStack: !0
              },
              o
            ),
            {
              default: () => [
                xs(!1, 'v-snackbar'),
                n.default &&
                  m('div', { class: 'v-snackbar__content', role: 'status', 'aria-live': 'polite' }, [
                    n.default()
                  ]),
                n.actions &&
                  m(
                    vt,
                    { defaults: { VBtn: { variant: 'text', ripple: !1 } } },
                    { default: () => [m('div', { class: 'v-snackbar__actions' }, [n.actions()])] }
                  )
              ],
              activator: n.activator
            }
          )
        }),
        vi({}, f)
      )
    }
  })
const pT = ee(
    {
      indeterminate: Boolean,
      inset: Boolean,
      flat: Boolean,
      loading: { type: [Boolean, String], default: !1 },
      ...ra(),
      ...Wc()
    },
    'VSwitch'
  ),
  yT = fe()({
    name: 'VSwitch',
    inheritAttrs: !1,
    props: pT(),
    emits: { 'update:focused': (e) => !0, 'update:modelValue': () => !0, 'update:indeterminate': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const a = Ge(e, 'indeterminate'),
        s = Ge(e, 'modelValue'),
        { loaderClasses: o } = Hc(e),
        { isFocused: r, focus: l, blur: c } = Fa(e),
        u = te(),
        d = A(() => (typeof e.loading == 'string' && e.loading !== '' ? e.loading : e.color)),
        f = vn(),
        h = A(() => e.id || `switch-${f}`)
      function v() {
        a.value && (a.value = !1)
      }
      function g(p) {
        var y, b
        p.stopPropagation(),
          p.preventDefault(),
          (b = (y = u.value) == null ? void 0 : y.input) == null || b.click()
      }
      return (
        ge(() => {
          const [p, y] = ys(n),
            [b, x] = en.filterProps(e),
            [w, C] = hs.filterProps(e)
          return m(
            en,
            xe(
              {
                class: [
                  'v-switch',
                  { 'v-switch--inset': e.inset },
                  { 'v-switch--indeterminate': a.value },
                  o.value,
                  e.class
                ],
                style: e.style
              },
              p,
              b,
              { id: h.value, focused: r.value }
            ),
            {
              ...i,
              default: (P) => {
                let { id: k, messagesId: S, isDisabled: _, isReadonly: T, isValid: B } = P
                return m(
                  hs,
                  xe(
                    { ref: u },
                    w,
                    {
                      modelValue: s.value,
                      'onUpdate:modelValue': [(O) => (s.value = O), v],
                      id: k.value,
                      'aria-describedby': S.value,
                      type: 'checkbox',
                      'aria-checked': a.value ? 'mixed' : void 0,
                      disabled: _.value,
                      readonly: T.value,
                      onFocus: l,
                      onBlur: c
                    },
                    y
                  ),
                  {
                    ...i,
                    default: (O) => {
                      let { backgroundColorClasses: N, backgroundColorStyles: Q } = O
                      return m(
                        'div',
                        { class: ['v-switch__track', ...N.value], style: Q.value, onClick: g },
                        null
                      )
                    },
                    input: (O) => {
                      let { inputNode: N, icon: Q, backgroundColorClasses: ue, backgroundColorStyles: j } = O
                      return m(Oe, null, [
                        N,
                        m(
                          'div',
                          {
                            class: [
                              'v-switch__thumb',
                              { 'v-switch__thumb--filled': Q || e.loading },
                              e.inset ? void 0 : ue.value
                            ],
                            style: e.inset ? void 0 : j.value
                          },
                          [
                            m(Kf, null, {
                              default: () => [
                                e.loading
                                  ? m(
                                      ah,
                                      {
                                        name: 'v-switch',
                                        active: !0,
                                        color: B.value === !1 ? void 0 : d.value
                                      },
                                      {
                                        default: (U) =>
                                          i.loader
                                            ? i.loader(U)
                                            : m(
                                                th,
                                                {
                                                  active: U.isActive,
                                                  color: U.color,
                                                  indeterminate: !0,
                                                  size: '16',
                                                  width: '2'
                                                },
                                                null
                                              )
                                      }
                                    )
                                  : Q && m(gt, { key: Q, icon: Q, size: 'x-small' }, null)
                              ]
                            })
                          ]
                        )
                      ])
                    }
                  }
                )
              }
            }
          )
        }),
        {}
      )
    }
  })
const bT = ee(
    {
      color: String,
      height: [Number, String],
      window: Boolean,
      ...Me(),
      ...Yt(),
      ...uo(),
      ...kt(),
      ...Ke(),
      ...ot()
    },
    'VSystemBar'
  ),
  _T = fe()({
    name: 'VSystemBar',
    props: bT(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = ut(e),
        { backgroundColorClasses: a, backgroundColorStyles: s } = Rt(ve(e, 'color')),
        { elevationClasses: o } = nn(e),
        { roundedClasses: r } = Lt(e),
        { ssrBootStyles: l } = _s(),
        c = A(() => e.height ?? (e.window ? 32 : 24)),
        { layoutItemStyles: u } = fo({
          id: e.name,
          order: A(() => parseInt(e.order, 10)),
          position: Ce('top'),
          layoutSize: c,
          elementSize: c,
          active: A(() => !0),
          absolute: ve(e, 'absolute')
        })
      return (
        ge(() =>
          m(
            e.tag,
            {
              class: [
                'v-system-bar',
                { 'v-system-bar--window': e.window },
                i.value,
                a.value,
                o.value,
                r.value,
                e.class
              ],
              style: [s.value, u.value, l.value, e.style]
            },
            n
          )
        ),
        {}
      )
    }
  })
const Qb = Symbol.for('vuetify:v-tabs'),
  xT = ee(
    {
      fixed: Boolean,
      sliderColor: String,
      hideSlider: Boolean,
      direction: { type: String, default: 'horizontal' },
      ...Gn(sh({ selectedClass: 'v-tab--selected', variant: 'text' }), [
        'active',
        'block',
        'flat',
        'location',
        'position',
        'symbol'
      ])
    },
    'VTab'
  ),
  e1 = fe()({
    name: 'VTab',
    props: xT(),
    setup(e, t) {
      let { slots: n, attrs: i } = t
      const { textColorClasses: a, textColorStyles: s } = dn(e, 'sliderColor'),
        o = A(() => e.direction === 'horizontal'),
        r = Ce(!1),
        l = te(),
        c = te()
      function u(d) {
        var h, v
        let { value: f } = d
        if (((r.value = f), f)) {
          const g =
              (v = (h = l.value) == null ? void 0 : h.$el.parentElement) == null
                ? void 0
                : v.querySelector('.v-tab--selected .v-tab__slider'),
            p = c.value
          if (!g || !p) return
          const y = getComputedStyle(g).color,
            b = g.getBoundingClientRect(),
            x = p.getBoundingClientRect(),
            w = o.value ? 'x' : 'y',
            C = o.value ? 'X' : 'Y',
            P = o.value ? 'right' : 'bottom',
            k = o.value ? 'width' : 'height',
            S = b[w],
            _ = x[w],
            T = S > _ ? b[P] - x[P] : b[w] - x[w],
            B =
              Math.sign(T) > 0
                ? o.value
                  ? 'right'
                  : 'bottom'
                : Math.sign(T) < 0
                ? o.value
                  ? 'left'
                  : 'top'
                : 'center',
            N = (Math.abs(T) + (Math.sign(T) < 0 ? b[k] : x[k])) / Math.max(b[k], x[k]) || 0,
            Q = b[k] / x[k] || 0,
            ue = 1.5
          ns(
            p,
            {
              backgroundColor: [y, 'currentcolor'],
              transform: [
                `translate${C}(${T}px) scale${C}(${Q})`,
                `translate${C}(${T / ue}px) scale${C}(${(N - 1) / ue + 1})`,
                'none'
              ],
              transformOrigin: Array(3).fill(B)
            },
            { duration: 225, easing: xr }
          )
        }
      }
      return (
        ge(() => {
          const [d] = bn.filterProps(e)
          return m(
            bn,
            xe(
              {
                symbol: Qb,
                ref: l,
                class: ['v-tab', e.class],
                style: e.style,
                tabindex: r.value ? 0 : -1,
                role: 'tab',
                'aria-selected': String(r.value),
                active: !1
              },
              d,
              i,
              { block: e.fixed, maxWidth: e.fixed ? 300 : void 0, 'onGroup:selected': u }
            ),
            {
              default: () => {
                var f
                return [
                  ((f = n.default) == null ? void 0 : f.call(n)) ?? e.text,
                  !e.hideSlider &&
                    m('div', { ref: c, class: ['v-tab__slider', a.value], style: s.value }, null)
                ]
              }
            }
          )
        }),
        {}
      )
    }
  })
function wT(e) {
  return e ? e.map((t) => (ic(t) ? t : { text: t, value: t })) : []
}
const ST = ee(
    {
      alignTabs: { type: String, default: 'start' },
      color: String,
      fixedTabs: Boolean,
      items: { type: Array, default: () => [] },
      stacked: Boolean,
      bgColor: String,
      grow: Boolean,
      height: { type: [Number, String], default: void 0 },
      hideSlider: Boolean,
      sliderColor: String,
      ...Jb({ mandatory: 'force' }),
      ...Gt(),
      ...Ke()
    },
    'VTabs'
  ),
  kT = fe()({
    name: 'VTabs',
    props: ST(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = Ge(e, 'modelValue'),
        a = A(() => wT(e.items)),
        { densityClasses: s } = gn(e),
        { backgroundColorClasses: o, backgroundColorStyles: r } = Rt(ve(e, 'bgColor'))
      return (
        zt({
          VTab: {
            color: ve(e, 'color'),
            direction: ve(e, 'direction'),
            stacked: ve(e, 'stacked'),
            fixed: ve(e, 'fixedTabs'),
            sliderColor: ve(e, 'sliderColor'),
            hideSlider: ve(e, 'hideSlider')
          }
        }),
        ge(() => {
          const [l] = Rd.filterProps(e)
          return m(
            Rd,
            xe(l, {
              modelValue: i.value,
              'onUpdate:modelValue': (c) => (i.value = c),
              class: [
                'v-tabs',
                `v-tabs--${e.direction}`,
                `v-tabs--align-tabs-${e.alignTabs}`,
                { 'v-tabs--fixed-tabs': e.fixedTabs, 'v-tabs--grow': e.grow, 'v-tabs--stacked': e.stacked },
                s.value,
                o.value,
                e.class
              ],
              style: [{ '--v-tabs-height': Ve(e.height) }, r.value, e.style],
              role: 'tablist',
              symbol: Qb
            }),
            {
              default: () => [
                n.default ? n.default() : a.value.map((c) => m(e1, xe(c, { key: c.text }), null))
              ]
            }
          )
        }),
        {}
      )
    }
  })
const CT = ee(
    {
      fixedHeader: Boolean,
      fixedFooter: Boolean,
      height: [Number, String],
      hover: Boolean,
      ...Me(),
      ...Gt(),
      ...Ke(),
      ...ot()
    },
    'VTable'
  ),
  MT = fe()({
    name: 'VTable',
    props: CT(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = ut(e),
        { densityClasses: a } = gn(e)
      return (
        ge(() =>
          m(
            e.tag,
            {
              class: [
                'v-table',
                {
                  'v-table--fixed-height': !!e.height,
                  'v-table--fixed-header': e.fixedHeader,
                  'v-table--fixed-footer': e.fixedFooter,
                  'v-table--has-top': !!n.top,
                  'v-table--has-bottom': !!n.bottom,
                  'v-table--hover': e.hover
                },
                i.value,
                a.value,
                e.class
              ],
              style: e.style
            },
            {
              default: () => {
                var s, o, r
                return [
                  (s = n.top) == null ? void 0 : s.call(n),
                  n.default
                    ? m('div', { class: 'v-table__wrapper', style: { height: Ve(e.height) } }, [
                        m('table', null, [n.default()])
                      ])
                    : (o = n.wrapper) == null
                    ? void 0
                    : o.call(n),
                  (r = n.bottom) == null ? void 0 : r.call(n)
                ]
              }
            }
          )
        ),
        {}
      )
    }
  })
const AT = ee(
    {
      autoGrow: Boolean,
      autofocus: Boolean,
      counter: [Boolean, Number, String],
      counterValue: Function,
      prefix: String,
      placeholder: String,
      persistentPlaceholder: Boolean,
      persistentCounter: Boolean,
      noResize: Boolean,
      rows: { type: [Number, String], default: 5, validator: (e) => !isNaN(parseFloat(e)) },
      maxRows: { type: [Number, String], validator: (e) => !isNaN(parseFloat(e)) },
      suffix: String,
      modelModifiers: Object,
      ...ra(),
      ...qc()
    },
    'VTextarea'
  ),
  PT = fe()({
    name: 'VTextarea',
    directives: { Intersect: Hr },
    inheritAttrs: !1,
    props: AT(),
    emits: {
      'click:control': (e) => !0,
      'mousedown:control': (e) => !0,
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0
    },
    setup(e, t) {
      let { attrs: n, emit: i, slots: a } = t
      const s = Ge(e, 'modelValue'),
        { isFocused: o, focus: r, blur: l } = Fa(e),
        c = A(() =>
          typeof e.counterValue == 'function' ? e.counterValue(s.value) : (s.value || '').toString().length
        ),
        u = A(() => {
          if (n.maxlength) return n.maxlength
          if (!(!e.counter || (typeof e.counter != 'number' && typeof e.counter != 'string')))
            return e.counter
        })
      function d(B, O) {
        var N, Q
        !e.autofocus || !B || (Q = (N = O[0].target) == null ? void 0 : N.focus) == null || Q.call(N)
      }
      const f = te(),
        h = te(),
        v = Ce(''),
        g = te(),
        p = A(() => e.persistentPlaceholder || o.value || e.active)
      function y() {
        var B
        g.value !== document.activeElement && ((B = g.value) == null || B.focus()), o.value || r()
      }
      function b(B) {
        y(), i('click:control', B)
      }
      function x(B) {
        i('mousedown:control', B)
      }
      function w(B) {
        B.stopPropagation(),
          y(),
          mt(() => {
            ;(s.value = ''), Nf(e['onClick:clear'], B)
          })
      }
      function C(B) {
        var N
        const O = B.target
        if (((s.value = O.value), (N = e.modelModifiers) != null && N.trim)) {
          const Q = [O.selectionStart, O.selectionEnd]
          mt(() => {
            ;(O.selectionStart = Q[0]), (O.selectionEnd = Q[1])
          })
        }
      }
      const P = te(),
        k = te(+e.rows),
        S = A(() => ['plain', 'underlined'].includes(e.variant))
      Ut(() => {
        e.autoGrow || (k.value = +e.rows)
      })
      function _() {
        e.autoGrow &&
          mt(() => {
            if (!P.value || !h.value) return
            const B = getComputedStyle(P.value),
              O = getComputedStyle(h.value.$el),
              N =
                parseFloat(B.getPropertyValue('--v-field-padding-top')) +
                parseFloat(B.getPropertyValue('--v-input-padding-top')) +
                parseFloat(B.getPropertyValue('--v-field-padding-bottom')),
              Q = P.value.scrollHeight,
              ue = parseFloat(B.lineHeight),
              j = Math.max(
                parseFloat(e.rows) * ue + N,
                parseFloat(O.getPropertyValue('--v-input-control-height'))
              ),
              U = parseFloat(e.maxRows) * ue + N || 1 / 0,
              X = cn(Q ?? 0, j, U)
            ;(k.value = Math.floor((X - N) / ue)), (v.value = Ve(X))
          })
      }
      tn(_), Pe(s, _), Pe(() => e.rows, _), Pe(() => e.maxRows, _), Pe(() => e.density, _)
      let T
      return (
        Pe(P, (B) => {
          B ? ((T = new ResizeObserver(_)), T.observe(P.value)) : T == null || T.disconnect()
        }),
        _n(() => {
          T == null || T.disconnect()
        }),
        ge(() => {
          const B = !!(a.counter || e.counter || e.counterValue),
            O = !!(B || a.details),
            [N, Q] = ys(n),
            [{ modelValue: ue, ...j }] = en.filterProps(e),
            [U] = uh(e)
          return m(
            en,
            xe(
              {
                ref: f,
                modelValue: s.value,
                'onUpdate:modelValue': (X) => (s.value = X),
                class: [
                  'v-textarea v-text-field',
                  {
                    'v-textarea--prefixed': e.prefix,
                    'v-textarea--suffixed': e.suffix,
                    'v-text-field--prefixed': e.prefix,
                    'v-text-field--suffixed': e.suffix,
                    'v-textarea--auto-grow': e.autoGrow,
                    'v-textarea--no-resize': e.noResize || e.autoGrow,
                    'v-text-field--plain-underlined': S.value
                  },
                  e.class
                ],
                style: e.style
              },
              N,
              j,
              { centerAffix: k.value === 1 && !S.value, focused: o.value }
            ),
            {
              ...a,
              default: (X) => {
                let { isDisabled: oe, isDirty: de, isReadonly: ce, isValid: Te } = X
                return m(
                  Gr,
                  xe(
                    {
                      ref: h,
                      style: { '--v-textarea-control-height': v.value },
                      onClick: b,
                      onMousedown: x,
                      'onClick:clear': w,
                      'onClick:prependInner': e['onClick:prependInner'],
                      'onClick:appendInner': e['onClick:appendInner']
                    },
                    U,
                    {
                      active: p.value || de.value,
                      centerAffix: k.value === 1 && !S.value,
                      dirty: de.value || e.dirty,
                      disabled: oe.value,
                      focused: o.value,
                      error: Te.value === !1
                    }
                  ),
                  {
                    ...a,
                    default: ($e) => {
                      let {
                        props: { class: He, ...Ue }
                      } = $e
                      return m(Oe, null, [
                        e.prefix && m('span', { class: 'v-text-field__prefix' }, [e.prefix]),
                        Et(
                          m(
                            'textarea',
                            xe(
                              {
                                ref: g,
                                class: He,
                                value: s.value,
                                onInput: C,
                                autofocus: e.autofocus,
                                readonly: ce.value,
                                disabled: oe.value,
                                placeholder: e.placeholder,
                                rows: e.rows,
                                name: e.name,
                                onFocus: y,
                                onBlur: l
                              },
                              Ue,
                              Q
                            ),
                            null
                          ),
                          [[Fn('intersect'), { handler: d }, null, { once: !0 }]]
                        ),
                        e.autoGrow &&
                          Et(
                            m(
                              'textarea',
                              {
                                class: [He, 'v-textarea__sizer'],
                                id: `${Ue.id}-sizer`,
                                'onUpdate:modelValue': (ie) => (s.value = ie),
                                ref: P,
                                readonly: !0,
                                'aria-hidden': 'true'
                              },
                              null
                            ),
                            [[HS, s.value]]
                          ),
                        e.suffix && m('span', { class: 'v-text-field__suffix' }, [e.suffix])
                      ])
                    }
                  }
                )
              },
              details: O
                ? (X) => {
                    var oe
                    return m(Oe, null, [
                      (oe = a.details) == null ? void 0 : oe.call(a, X),
                      B &&
                        m(Oe, null, [
                          m('span', null, null),
                          m(
                            Kc,
                            { active: e.persistentCounter || o.value, value: c.value, max: u.value },
                            a.counter
                          )
                        ])
                    ])
                  }
                : void 0
            }
          )
        }),
        vi({}, f, h, g)
      )
    }
  })
const TT = ee({ withBackground: Boolean, ...Me(), ...ot(), ...Ke() }, 'VThemeProvider'),
  VT = fe()({
    name: 'VThemeProvider',
    props: TT(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = ut(e)
      return () => {
        var a
        return e.withBackground
          ? m(
              e.tag,
              { class: ['v-theme-provider', i.value, e.class], style: e.style },
              {
                default: () => {
                  var s
                  return [(s = n.default) == null ? void 0 : s.call(n)]
                }
              }
            )
          : (a = n.default) == null
          ? void 0
          : a.call(n)
      }
    }
  })
const ET = ee(
    {
      align: { type: String, default: 'center', validator: (e) => ['center', 'start'].includes(e) },
      direction: {
        type: String,
        default: 'vertical',
        validator: (e) => ['vertical', 'horizontal'].includes(e)
      },
      justify: { type: String, default: 'auto', validator: (e) => ['auto', 'center'].includes(e) },
      side: { type: String, validator: (e) => e == null || ['start', 'end'].includes(e) },
      lineInset: { type: [String, Number], default: 0 },
      lineThickness: { type: [String, Number], default: 2 },
      lineColor: String,
      truncateLine: { type: String, validator: (e) => ['start', 'end', 'both'].includes(e) },
      ...Me(),
      ...Gt(),
      ...Ke(),
      ...ot()
    },
    'VTimeline'
  ),
  LT = fe()({
    name: 'VTimeline',
    props: ET(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = ut(e),
        { densityClasses: a } = gn(e),
        { rtlClasses: s } = Qt()
      zt({
        VTimelineDivider: { lineColor: ve(e, 'lineColor') },
        VTimelineItem: { density: ve(e, 'density'), lineInset: ve(e, 'lineInset') }
      })
      const o = A(() => {
          const l = e.side ? e.side : e.density !== 'default' ? 'end' : null
          return l && `v-timeline--side-${l}`
        }),
        r = A(() => {
          const l = ['v-timeline--truncate-line-start', 'v-timeline--truncate-line-end']
          switch (e.truncateLine) {
            case 'both':
              return l
            case 'start':
              return l[0]
            case 'end':
              return l[1]
            default:
              return null
          }
        })
      return (
        ge(() =>
          m(
            e.tag,
            {
              class: [
                'v-timeline',
                `v-timeline--${e.direction}`,
                `v-timeline--align-${e.align}`,
                `v-timeline--justify-${e.justify}`,
                r.value,
                { 'v-timeline--inset-line': !!e.lineInset },
                i.value,
                a.value,
                o.value,
                s.value,
                e.class
              ],
              style: [{ '--v-timeline-line-thickness': Ve(e.lineThickness) }, e.style]
            },
            n
          )
        ),
        {}
      )
    }
  }),
  OT = ee(
    {
      dotColor: String,
      fillDot: Boolean,
      hideDot: Boolean,
      icon: Ye,
      iconColor: String,
      lineColor: String,
      ...Me(),
      ...kt(),
      ...oa(),
      ...Yt()
    },
    'VTimelineDivider'
  ),
  IT = fe()({
    name: 'VTimelineDivider',
    props: OT(),
    setup(e, t) {
      let { slots: n } = t
      const { sizeClasses: i, sizeStyles: a } = mo(e, 'v-timeline-divider__dot'),
        { backgroundColorStyles: s, backgroundColorClasses: o } = Rt(ve(e, 'dotColor')),
        { roundedClasses: r } = Lt(e, 'v-timeline-divider__dot'),
        { elevationClasses: l } = nn(e),
        { backgroundColorClasses: c, backgroundColorStyles: u } = Rt(ve(e, 'lineColor'))
      return (
        ge(() =>
          m(
            'div',
            {
              class: ['v-timeline-divider', { 'v-timeline-divider--fill-dot': e.fillDot }, e.class],
              style: e.style
            },
            [
              m('div', { class: ['v-timeline-divider__before', c.value], style: u.value }, null),
              !e.hideDot &&
                m(
                  'div',
                  {
                    key: 'dot',
                    class: ['v-timeline-divider__dot', l.value, r.value, i.value],
                    style: a.value
                  },
                  [
                    m('div', { class: ['v-timeline-divider__inner-dot', o.value, r.value], style: s.value }, [
                      n.default
                        ? m(
                            vt,
                            {
                              key: 'icon-defaults',
                              disabled: !e.icon,
                              defaults: { VIcon: { color: e.iconColor, icon: e.icon, size: e.size } }
                            },
                            n.default
                          )
                        : m(gt, { key: 'icon', color: e.iconColor, icon: e.icon, size: e.size }, null)
                    ])
                  ]
                ),
              m('div', { class: ['v-timeline-divider__after', c.value], style: u.value }, null)
            ]
          )
        ),
        {}
      )
    }
  }),
  DT = ee(
    {
      density: String,
      dotColor: String,
      fillDot: Boolean,
      hideDot: Boolean,
      hideOpposite: { type: Boolean, default: void 0 },
      icon: Ye,
      iconColor: String,
      lineInset: [Number, String],
      ...Me(),
      ...qn(),
      ...Yt(),
      ...kt(),
      ...oa(),
      ...Ke()
    },
    'VTimelineItem'
  ),
  FT = fe()({
    name: 'VTimelineItem',
    props: DT(),
    setup(e, t) {
      let { slots: n } = t
      const { dimensionStyles: i } = Zn(e),
        a = Ce(0),
        s = te()
      return (
        Pe(
          s,
          (o) => {
            var r
            o &&
              (a.value =
                ((r = o.$el.querySelector('.v-timeline-divider__dot')) == null
                  ? void 0
                  : r.getBoundingClientRect().width) ?? 0)
          },
          { flush: 'post' }
        ),
        ge(() => {
          var o, r
          return m(
            'div',
            {
              class: ['v-timeline-item', { 'v-timeline-item--fill-dot': e.fillDot }, e.class],
              style: [
                {
                  '--v-timeline-dot-size': Ve(a.value),
                  '--v-timeline-line-inset': e.lineInset
                    ? `calc(var(--v-timeline-dot-size) / 2 + ${Ve(e.lineInset)})`
                    : Ve(0)
                },
                e.style
              ]
            },
            [
              m('div', { class: 'v-timeline-item__body', style: i.value }, [
                (o = n.default) == null ? void 0 : o.call(n)
              ]),
              m(
                IT,
                {
                  ref: s,
                  hideDot: e.hideDot,
                  icon: e.icon,
                  iconColor: e.iconColor,
                  size: e.size,
                  elevation: e.elevation,
                  dotColor: e.dotColor,
                  fillDot: e.fillDot,
                  rounded: e.rounded
                },
                { default: n.icon }
              ),
              e.density !== 'compact' &&
                m('div', { class: 'v-timeline-item__opposite' }, [
                  !e.hideOpposite && ((r = n.opposite) == null ? void 0 : r.call(n))
                ])
            ]
          )
        }),
        {}
      )
    }
  }),
  RT = ee({ ...Me(), ...Qn({ variant: 'text' }) }, 'VToolbarItems'),
  BT = fe()({
    name: 'VToolbarItems',
    props: RT(),
    setup(e, t) {
      let { slots: n } = t
      return (
        zt({ VBtn: { color: ve(e, 'color'), height: 'inherit', variant: ve(e, 'variant') } }),
        ge(() => {
          var i
          return m('div', { class: ['v-toolbar-items', e.class], style: e.style }, [
            (i = n.default) == null ? void 0 : i.call(n)
          ])
        }),
        {}
      )
    }
  })
const NT = ee(
    {
      id: String,
      text: String,
      ...Gn(
        Yr({
          closeOnBack: !1,
          location: 'end',
          locationStrategy: 'connected',
          eager: !0,
          minWidth: 0,
          offset: 10,
          openOnClick: !1,
          openOnHover: !0,
          origin: 'auto',
          scrim: !1,
          scrollStrategy: 'reposition',
          transition: !1
        }),
        ['absolute', 'persistent']
      )
    },
    'VTooltip'
  ),
  $T = fe()({
    name: 'VTooltip',
    props: NT(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = Ge(e, 'modelValue'),
        { scopeId: a } = _o(),
        s = vn(),
        o = A(() => e.id || `v-tooltip-${s}`),
        r = te(),
        l = A(() => (e.location.split(' ').length > 1 ? e.location : e.location + ' center')),
        c = A(() =>
          e.origin === 'auto' ||
          e.origin === 'overlap' ||
          e.origin.split(' ').length > 1 ||
          e.location.split(' ').length > 1
            ? e.origin
            : e.origin + ' center'
        ),
        u = A(() => (e.transition ? e.transition : i.value ? 'scale-transition' : 'fade-transition')),
        d = A(() => xe({ 'aria-describedby': o.value }, e.activatorProps))
      return (
        ge(() => {
          const [f] = ea.filterProps(e)
          return m(
            ea,
            xe(
              { ref: r, class: ['v-tooltip', e.class], style: e.style, id: o.value },
              f,
              {
                modelValue: i.value,
                'onUpdate:modelValue': (h) => (i.value = h),
                transition: u.value,
                absolute: !0,
                location: l.value,
                origin: c.value,
                persistent: !0,
                role: 'tooltip',
                activatorProps: d.value,
                _disableGlobalStack: !0
              },
              a
            ),
            {
              activator: n.activator,
              default: function () {
                var p
                for (var h = arguments.length, v = new Array(h), g = 0; g < h; g++) v[g] = arguments[g]
                return ((p = n.default) == null ? void 0 : p.call(n, ...v)) ?? e.text
              }
            }
          )
        }),
        vi({}, r)
      )
    }
  }),
  zT = fe()({
    name: 'VValidation',
    props: Uy(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = Yy(e, 'validation')
      return () => {
        var a
        return (a = n.default) == null ? void 0 : a.call(n, i)
      }
    }
  }),
  HT = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        VAlert: p2,
        VAlertTitle: By,
        VApp: AC,
        VAppBar: GC,
        VAppBarNavIcon: h2,
        VAppBarTitle: v2,
        VAutocomplete: DM,
        VAvatar: Pa,
        VBadge: RM,
        VBanner: $M,
        VBannerActions: yb,
        VBannerText: bb,
        VBottomNavigation: HM,
        VBreadcrumbs: YM,
        VBreadcrumbsDivider: _b,
        VBreadcrumbsItem: xb,
        VBtn: bn,
        VBtnGroup: xd,
        VBtnToggle: QC,
        VCard: KM,
        VCardActions: wb,
        VCardItem: Cb,
        VCardSubtitle: Sb,
        VCardText: Mb,
        VCardTitle: kb,
        VCarousel: aA,
        VCarouselItem: oA,
        VCheckbox: C2,
        VCheckboxBtn: Qs,
        VChip: Ur,
        VChipGroup: P2,
        VClassIcon: Gf,
        VCode: rA,
        VCol: yP,
        VColorPicker: KA,
        VCombobox: JA,
        VComponentIcon: gd,
        VContainer: vP,
        VCounter: Kc,
        VDefaultsProvider: vt,
        VDialog: eP,
        VDialogBottomTransition: EC,
        VDialogTopTransition: LC,
        VDialogTransition: $c,
        VDivider: ib,
        VExpandTransition: zc,
        VExpandXTransition: Zf,
        VExpansionPanel: oP,
        VExpansionPanelText: Rb,
        VExpansionPanelTitle: Nb,
        VExpansionPanels: iP,
        VFabTransition: VC,
        VFadeTransition: yd,
        VField: Gr,
        VFieldLabel: Ho,
        VFileInput: lP,
        VFooter: uP,
        VForm: fP,
        VHover: PP,
        VIcon: gt,
        VImg: fs,
        VInput: en,
        VItem: EP,
        VItemGroup: VP,
        VKbd: LP,
        VLabel: bo,
        VLayout: IP,
        VLayoutItem: FP,
        VLazy: BP,
        VLigatureIcon: $k,
        VList: Yc,
        VListGroup: Cd,
        VListImg: X2,
        VListItem: Qi,
        VListItemAction: q2,
        VListItemMedia: J2,
        VListItemSubtitle: eb,
        VListItemTitle: tb,
        VListSubheader: nb,
        VLocaleProvider: $P,
        VMain: HP,
        VMenu: Xc,
        VMessages: Wy,
        VNavigationDrawer: ZP,
        VNoSsr: JP,
        VOverlay: ea,
        VPagination: tT,
        VParallax: aT,
        VProgressCircular: th,
        VProgressLinear: nh,
        VRadio: oT,
        VRadioGroup: lT,
        VRangeSlider: uT,
        VRating: fT,
        VResponsive: bd,
        VRow: CP,
        VScaleTransition: Kf,
        VScrollXReverseTransition: IC,
        VScrollXTransition: OC,
        VScrollYReverseTransition: FC,
        VScrollYTransition: DC,
        VSelect: VM,
        VSelectionControl: hs,
        VSelectionControlGroup: $y,
        VSheet: Fd,
        VSlideGroup: Rd,
        VSlideGroupItem: vT,
        VSlideXReverseTransition: BC,
        VSlideXTransition: RC,
        VSlideYReverseTransition: NC,
        VSlideYTransition: qf,
        VSlider: Dd,
        VSnackbar: mT,
        VSpacer: MP,
        VSvgIcon: Yf,
        VSwitch: yT,
        VSystemBar: _T,
        VTab: e1,
        VTable: MT,
        VTabs: kT,
        VTextField: vs,
        VTextarea: PT,
        VThemeProvider: VT,
        VTimeline: LT,
        VTimelineItem: FT,
        VToolbar: _d,
        VToolbarItems: BT,
        VToolbarTitle: Xf,
        VTooltip: $T,
        VValidation: zT,
        VVirtualScroll: Jc,
        VWindow: Td,
        VWindowItem: Vd
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
function WT(e, t) {
  const n = t.modifiers || {},
    i = t.value,
    { once: a, immediate: s, ...o } = n,
    r = !Object.keys(o).length,
    { handler: l, options: c } =
      typeof i == 'object'
        ? i
        : {
            handler: i,
            options: {
              attributes: (o == null ? void 0 : o.attr) ?? r,
              characterData: (o == null ? void 0 : o.char) ?? r,
              childList: (o == null ? void 0 : o.child) ?? r,
              subtree: (o == null ? void 0 : o.sub) ?? r
            }
          },
    u = new MutationObserver(function () {
      let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
        f = arguments.length > 1 ? arguments[1] : void 0
      l == null || l(d, f), a && t1(e, t)
    })
  s && (l == null || l([], u)),
    (e._mutate = Object(e._mutate)),
    (e._mutate[t.instance.$.uid] = { observer: u }),
    u.observe(e, c)
}
function t1(e, t) {
  var n
  ;(n = e._mutate) != null &&
    n[t.instance.$.uid] &&
    (e._mutate[t.instance.$.uid].observer.disconnect(), delete e._mutate[t.instance.$.uid])
}
const jT = { mounted: WT, unmounted: t1 }
function UT(e, t) {
  var a, s
  const n = t.value,
    i = { passive: !((a = t.modifiers) != null && a.active) }
  window.addEventListener('resize', n, i),
    (e._onResize = Object(e._onResize)),
    (e._onResize[t.instance.$.uid] = { handler: n, options: i }),
    ((s = t.modifiers) != null && s.quiet) || n()
}
function YT(e, t) {
  var a
  if (!((a = e._onResize) != null && a[t.instance.$.uid])) return
  const { handler: n, options: i } = e._onResize[t.instance.$.uid]
  window.removeEventListener('resize', n, i), delete e._onResize[t.instance.$.uid]
}
const GT = { mounted: UT, unmounted: YT }
function n1(e, t) {
  const { self: n = !1 } = t.modifiers ?? {},
    i = t.value,
    a = (typeof i == 'object' && i.options) || { passive: !0 },
    s = typeof i == 'function' || 'handleEvent' in i ? i : i.handler,
    o = n ? e : t.arg ? document.querySelector(t.arg) : window
  o &&
    (o.addEventListener('scroll', s, a),
    (e._onScroll = Object(e._onScroll)),
    (e._onScroll[t.instance.$.uid] = { handler: s, options: a, target: n ? void 0 : o }))
}
function i1(e, t) {
  var s
  if (!((s = e._onScroll) != null && s[t.instance.$.uid])) return
  const { handler: n, options: i, target: a = e } = e._onScroll[t.instance.$.uid]
  a.removeEventListener('scroll', n, i), delete e._onScroll[t.instance.$.uid]
}
function XT(e, t) {
  t.value !== t.oldValue && (i1(e, t), n1(e, t))
}
const KT = { mounted: n1, unmounted: i1, updated: XT },
  qT = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        ClickOutside: gb,
        Intersect: Hr,
        Mutate: jT,
        Resize: GT,
        Ripple: Da,
        Scroll: KT,
        Touch: hh
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
const ZT = {
  collapse: 'svg:M7.41,15.41L12,10.83L16.59,15.41L18,14L12,8L6,14L7.41,15.41Z',
  complete: 'svg:M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z',
  cancel:
    'svg:M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z',
  close:
    'svg:M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z',
  delete:
    'svg:M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z',
  clear:
    'svg:M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z',
  success:
    'svg:M12,2C17.52,2 22,6.48 22,12C22,17.52 17.52,22 12,22C6.48,22 2,17.52 2,12C2,6.48 6.48,2 12,2M11,16.5L18,9.5L16.59,8.09L11,13.67L7.91,10.59L6.5,12L11,16.5Z',
  info: 'svg:M13,9H11V7H13M13,17H11V11H13M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2Z',
  warning:
    'svg:M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z',
  error:
    'svg:M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z',
  prev: 'svg:M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z',
  next: 'svg:M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z',
  checkboxOn:
    'svg:M10,17L5,12L6.41,10.58L10,14.17L17.59,6.58L19,8M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3Z',
  checkboxOff:
    'svg:M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z',
  checkboxIndeterminate:
    'svg:M17,13H7V11H17M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3Z',
  delimiter:
    'svg:M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2Z',
  sortAsc: 'svg:M13,20H11V8L5.5,13.5L4.08,12.08L12,4.16L19.92,12.08L18.5,13.5L13,8V20Z',
  sortDesc: 'svg:M11,4H13V16L18.5,10.5L19.92,11.92L12,19.84L4.08,11.92L5.5,10.5L11,16V4Z',
  expand: 'svg:M7.41,8.58L12,13.17L16.59,8.58L18,10L12,16L6,10L7.41,8.58Z',
  menu: 'svg:M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z',
  subgroup: 'svg:M7,10L12,15L17,10H7Z',
  dropdown: 'svg:M7,10L12,15L17,10H7Z',
  radioOn:
    'svg:M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2M12,7C9.24,7 7,9.24 7,12C7,14.76 9.24,17 12,17C14.76,17 17,14.76 17,12C17,9.24 14.76,7 12,7Z',
  radioOff:
    'svg:M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2Z',
  edit: 'svg:M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z',
  ratingEmpty:
    'svg:M12,15.39L8.24,17.66L9.23,13.38L5.91,10.5L10.29,10.13L12,6.09L13.71,10.13L18.09,10.5L14.77,13.38L15.76,17.66M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z',
  ratingFull:
    'svg:M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z',
  ratingHalf:
    'svg:M12,15.4V6.1L13.71,10.13L18.09,10.5L14.77,13.39L15.76,17.67M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z',
  loading:
    'svg:M19,8L15,12H18C18,15.31 15.31,18 12,18C11,18 10.03,17.75 9.2,17.3L7.74,18.76C8.97,19.54 10.43,20 12,20C16.42,20 20,16.42 20,12H23M6,12C6,8.69 8.69,6 12,6C13,6 13.97,6.25 14.8,6.7L16.26,5.24C15.03,4.46 13.57,4 12,4C7.58,4 4,7.58 4,12H1L5,16L9,12',
  first: 'svg:M18.41,16.59L13.82,12L18.41,7.41L17,6L11,12L17,18L18.41,16.59M6,6H8V18H6V6Z',
  last: 'svg:M5.59,7.41L10.18,12L5.59,16.59L7,18L13,12L7,6L5.59,7.41M16,6H18V18H16V6Z',
  unfold:
    'svg:M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z',
  file: 'svg:M16.5,6V17.5C16.5,19.71 14.71,21.5 12.5,21.5C10.29,21.5 8.5,19.71 8.5,17.5V5C8.5,3.62 9.62,2.5 11,2.5C12.38,2.5 13.5,3.62 13.5,5V15.5C13.5,16.05 13.05,16.5 12.5,16.5C11.95,16.5 11.5,16.05 11.5,15.5V6H10V15.5C10,16.88 11.12,18 12.5,18C13.88,18 15,16.88 15,15.5V5C15,2.79 13.21,1 11,1C8.79,1 7,2.79 7,5V17.5C7,20.54 9.46,23 12.5,23C15.54,23 18,20.54 18,17.5V6H16.5Z',
  plus: 'svg:M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z',
  minus: 'svg:M19,13H5V11H19V13Z',
  calendar:
    'svg:M19,19H5V8H19M16,1V3H8V1H6V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3H18V1M17,12H12V17H17V12Z'
}
var JT = !1
/*!
 * pinia v2.1.6
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */ const QT = Symbol()
var Cg
;(function (e) {
  ;(e.direct = 'direct'), (e.patchObject = 'patch object'), (e.patchFunction = 'patch function')
})(Cg || (Cg = {}))
function eV() {
  const e = Ac(!0),
    t = e.run(() => te({}))
  let n = [],
    i = []
  const a = xf({
    install(s) {
      ;(a._a = s),
        s.provide(QT, a),
        (s.config.globalProperties.$pinia = a),
        i.forEach((o) => n.push(o)),
        (i = [])
    },
    use(s) {
      return !this._a && !JT ? i.push(s) : n.push(s), this
    },
    _p: n,
    _a: null,
    _e: e,
    _s: new Map(),
    state: t
  })
  return a
}
/*!
 * vue-router v4.2.5
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */ const Fs = typeof window < 'u'
function tV(e) {
  return e.__esModule || e[Symbol.toStringTag] === 'Module'
}
const ft = Object.assign
function Au(e, t) {
  const n = {}
  for (const i in t) {
    const a = t[i]
    n[i] = di(a) ? a.map(e) : e(a)
  }
  return n
}
const nr = () => {},
  di = Array.isArray,
  nV = /\/$/,
  iV = (e) => e.replace(nV, '')
function Pu(e, t, n = '/') {
  let i,
    a = {},
    s = '',
    o = ''
  const r = t.indexOf('#')
  let l = t.indexOf('?')
  return (
    r < l && r >= 0 && (l = -1),
    l > -1 && ((i = t.slice(0, l)), (s = t.slice(l + 1, r > -1 ? r : t.length)), (a = e(s))),
    r > -1 && ((i = i || t.slice(0, r)), (o = t.slice(r, t.length))),
    (i = rV(i ?? t, n)),
    { fullPath: i + (s && '?') + s + o, path: i, query: a, hash: o }
  )
}
function aV(e, t) {
  const n = t.query ? e(t.query) : ''
  return t.path + (n && '?') + n + (t.hash || '')
}
function Mg(e, t) {
  return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || '/'
}
function sV(e, t, n) {
  const i = t.matched.length - 1,
    a = n.matched.length - 1
  return (
    i > -1 &&
    i === a &&
    eo(t.matched[i], n.matched[a]) &&
    a1(t.params, n.params) &&
    e(t.query) === e(n.query) &&
    t.hash === n.hash
  )
}
function eo(e, t) {
  return (e.aliasOf || e) === (t.aliasOf || t)
}
function a1(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length) return !1
  for (const n in e) if (!oV(e[n], t[n])) return !1
  return !0
}
function oV(e, t) {
  return di(e) ? Ag(e, t) : di(t) ? Ag(t, e) : e === t
}
function Ag(e, t) {
  return di(t) ? e.length === t.length && e.every((n, i) => n === t[i]) : e.length === 1 && e[0] === t
}
function rV(e, t) {
  if (e.startsWith('/')) return e
  if (!e) return t
  const n = t.split('/'),
    i = e.split('/'),
    a = i[i.length - 1]
  ;(a === '..' || a === '.') && i.push('')
  let s = n.length - 1,
    o,
    r
  for (o = 0; o < i.length; o++)
    if (((r = i[o]), r !== '.'))
      if (r === '..') s > 1 && s--
      else break
  return n.slice(0, s).join('/') + '/' + i.slice(o - (o === i.length ? 1 : 0)).join('/')
}
var Ar
;(function (e) {
  ;(e.pop = 'pop'), (e.push = 'push')
})(Ar || (Ar = {}))
var ir
;(function (e) {
  ;(e.back = 'back'), (e.forward = 'forward'), (e.unknown = '')
})(ir || (ir = {}))
function lV(e) {
  if (!e)
    if (Fs) {
      const t = document.querySelector('base')
      ;(e = (t && t.getAttribute('href')) || '/'), (e = e.replace(/^\w+:\/\/[^\/]+/, ''))
    } else e = '/'
  return e[0] !== '/' && e[0] !== '#' && (e = '/' + e), iV(e)
}
const cV = /^[^#]+#/
function uV(e, t) {
  return e.replace(cV, '#') + t
}
function dV(e, t) {
  const n = document.documentElement.getBoundingClientRect(),
    i = e.getBoundingClientRect()
  return { behavior: t.behavior, left: i.left - n.left - (t.left || 0), top: i.top - n.top - (t.top || 0) }
}
const Qc = () => ({ left: window.pageXOffset, top: window.pageYOffset })
function fV(e) {
  let t
  if ('el' in e) {
    const n = e.el,
      i = typeof n == 'string' && n.startsWith('#'),
      a = typeof n == 'string' ? (i ? document.getElementById(n.slice(1)) : document.querySelector(n)) : n
    if (!a) return
    t = dV(a, e)
  } else t = e
  'scrollBehavior' in document.documentElement.style
    ? window.scrollTo(t)
    : window.scrollTo(
        t.left != null ? t.left : window.pageXOffset,
        t.top != null ? t.top : window.pageYOffset
      )
}
function Pg(e, t) {
  return (history.state ? history.state.position - t : -1) + e
}
const Bd = new Map()
function hV(e, t) {
  Bd.set(e, t)
}
function vV(e) {
  const t = Bd.get(e)
  return Bd.delete(e), t
}
let gV = () => location.protocol + '//' + location.host
function s1(e, t) {
  const { pathname: n, search: i, hash: a } = t,
    s = e.indexOf('#')
  if (s > -1) {
    let r = a.includes(e.slice(s)) ? e.slice(s).length : 1,
      l = a.slice(r)
    return l[0] !== '/' && (l = '/' + l), Mg(l, '')
  }
  return Mg(n, e) + i + a
}
function mV(e, t, n, i) {
  let a = [],
    s = [],
    o = null
  const r = ({ state: f }) => {
    const h = s1(e, location),
      v = n.value,
      g = t.value
    let p = 0
    if (f) {
      if (((n.value = h), (t.value = f), o && o === v)) {
        o = null
        return
      }
      p = g ? f.position - g.position : 0
    } else i(h)
    a.forEach((y) => {
      y(n.value, v, { delta: p, type: Ar.pop, direction: p ? (p > 0 ? ir.forward : ir.back) : ir.unknown })
    })
  }
  function l() {
    o = n.value
  }
  function c(f) {
    a.push(f)
    const h = () => {
      const v = a.indexOf(f)
      v > -1 && a.splice(v, 1)
    }
    return s.push(h), h
  }
  function u() {
    const { history: f } = window
    f.state && f.replaceState(ft({}, f.state, { scroll: Qc() }), '')
  }
  function d() {
    for (const f of s) f()
    ;(s = []), window.removeEventListener('popstate', r), window.removeEventListener('beforeunload', u)
  }
  return (
    window.addEventListener('popstate', r),
    window.addEventListener('beforeunload', u, { passive: !0 }),
    { pauseListeners: l, listen: c, destroy: d }
  )
}
function Tg(e, t, n, i = !1, a = !1) {
  return {
    back: e,
    current: t,
    forward: n,
    replaced: i,
    position: window.history.length,
    scroll: a ? Qc() : null
  }
}
function pV(e) {
  const { history: t, location: n } = window,
    i = { value: s1(e, n) },
    a = { value: t.state }
  a.value ||
    s(
      i.value,
      { back: null, current: i.value, forward: null, position: t.length - 1, replaced: !0, scroll: null },
      !0
    )
  function s(l, c, u) {
    const d = e.indexOf('#'),
      f = d > -1 ? (n.host && document.querySelector('base') ? e : e.slice(d)) + l : gV() + e + l
    try {
      t[u ? 'replaceState' : 'pushState'](c, '', f), (a.value = c)
    } catch (h) {
      console.error(h), n[u ? 'replace' : 'assign'](f)
    }
  }
  function o(l, c) {
    const u = ft({}, t.state, Tg(a.value.back, l, a.value.forward, !0), c, { position: a.value.position })
    s(l, u, !0), (i.value = l)
  }
  function r(l, c) {
    const u = ft({}, a.value, t.state, { forward: l, scroll: Qc() })
    s(u.current, u, !0)
    const d = ft({}, Tg(i.value, l, null), { position: u.position + 1 }, c)
    s(l, d, !1), (i.value = l)
  }
  return { location: i, state: a, push: r, replace: o }
}
function yV(e) {
  e = lV(e)
  const t = pV(e),
    n = mV(e, t.state, t.location, t.replace)
  function i(s, o = !0) {
    o || n.pauseListeners(), history.go(s)
  }
  const a = ft({ location: '', base: e, go: i, createHref: uV.bind(null, e) }, t, n)
  return (
    Object.defineProperty(a, 'location', { enumerable: !0, get: () => t.location.value }),
    Object.defineProperty(a, 'state', { enumerable: !0, get: () => t.state.value }),
    a
  )
}
function bV(e) {
  return typeof e == 'string' || (e && typeof e == 'object')
}
function o1(e) {
  return typeof e == 'string' || typeof e == 'symbol'
}
const fa = {
    path: '/',
    name: void 0,
    params: {},
    query: {},
    hash: '',
    fullPath: '/',
    matched: [],
    meta: {},
    redirectedFrom: void 0
  },
  r1 = Symbol('')
var Vg
;(function (e) {
  ;(e[(e.aborted = 4)] = 'aborted'),
    (e[(e.cancelled = 8)] = 'cancelled'),
    (e[(e.duplicated = 16)] = 'duplicated')
})(Vg || (Vg = {}))
function to(e, t) {
  return ft(new Error(), { type: e, [r1]: !0 }, t)
}
function Fi(e, t) {
  return e instanceof Error && r1 in e && (t == null || !!(e.type & t))
}
const Eg = '[^/]+?',
  _V = { sensitive: !1, strict: !1, start: !0, end: !0 },
  xV = /[.+*?^${}()[\]/\\]/g
function wV(e, t) {
  const n = ft({}, _V, t),
    i = []
  let a = n.start ? '^' : ''
  const s = []
  for (const c of e) {
    const u = c.length ? [] : [90]
    n.strict && !c.length && (a += '/')
    for (let d = 0; d < c.length; d++) {
      const f = c[d]
      let h = 40 + (n.sensitive ? 0.25 : 0)
      if (f.type === 0) d || (a += '/'), (a += f.value.replace(xV, '\\$&')), (h += 40)
      else if (f.type === 1) {
        const { value: v, repeatable: g, optional: p, regexp: y } = f
        s.push({ name: v, repeatable: g, optional: p })
        const b = y || Eg
        if (b !== Eg) {
          h += 10
          try {
            new RegExp(`(${b})`)
          } catch (w) {
            throw new Error(`Invalid custom RegExp for param "${v}" (${b}): ` + w.message)
          }
        }
        let x = g ? `((?:${b})(?:/(?:${b}))*)` : `(${b})`
        d || (x = p && c.length < 2 ? `(?:/${x})` : '/' + x),
          p && (x += '?'),
          (a += x),
          (h += 20),
          p && (h += -8),
          g && (h += -20),
          b === '.*' && (h += -50)
      }
      u.push(h)
    }
    i.push(u)
  }
  if (n.strict && n.end) {
    const c = i.length - 1
    i[c][i[c].length - 1] += 0.7000000000000001
  }
  n.strict || (a += '/?'), n.end ? (a += '$') : n.strict && (a += '(?:/|$)')
  const o = new RegExp(a, n.sensitive ? '' : 'i')
  function r(c) {
    const u = c.match(o),
      d = {}
    if (!u) return null
    for (let f = 1; f < u.length; f++) {
      const h = u[f] || '',
        v = s[f - 1]
      d[v.name] = h && v.repeatable ? h.split('/') : h
    }
    return d
  }
  function l(c) {
    let u = '',
      d = !1
    for (const f of e) {
      ;(!d || !u.endsWith('/')) && (u += '/'), (d = !1)
      for (const h of f)
        if (h.type === 0) u += h.value
        else if (h.type === 1) {
          const { value: v, repeatable: g, optional: p } = h,
            y = v in c ? c[v] : ''
          if (di(y) && !g)
            throw new Error(`Provided param "${v}" is an array but it is not repeatable (* or + modifiers)`)
          const b = di(y) ? y.join('/') : y
          if (!b)
            if (p) f.length < 2 && (u.endsWith('/') ? (u = u.slice(0, -1)) : (d = !0))
            else throw new Error(`Missing required param "${v}"`)
          u += b
        }
    }
    return u || '/'
  }
  return { re: o, score: i, keys: s, parse: r, stringify: l }
}
function SV(e, t) {
  let n = 0
  for (; n < e.length && n < t.length; ) {
    const i = t[n] - e[n]
    if (i) return i
    n++
  }
  return e.length < t.length
    ? e.length === 1 && e[0] === 40 + 40
      ? -1
      : 1
    : e.length > t.length
    ? t.length === 1 && t[0] === 40 + 40
      ? 1
      : -1
    : 0
}
function kV(e, t) {
  let n = 0
  const i = e.score,
    a = t.score
  for (; n < i.length && n < a.length; ) {
    const s = SV(i[n], a[n])
    if (s) return s
    n++
  }
  if (Math.abs(a.length - i.length) === 1) {
    if (Lg(i)) return 1
    if (Lg(a)) return -1
  }
  return a.length - i.length
}
function Lg(e) {
  const t = e[e.length - 1]
  return e.length > 0 && t[t.length - 1] < 0
}
const CV = { type: 0, value: '' },
  MV = /[a-zA-Z0-9_]/
function AV(e) {
  if (!e) return [[]]
  if (e === '/') return [[CV]]
  if (!e.startsWith('/')) throw new Error(`Invalid path "${e}"`)
  function t(h) {
    throw new Error(`ERR (${n})/"${c}": ${h}`)
  }
  let n = 0,
    i = n
  const a = []
  let s
  function o() {
    s && a.push(s), (s = [])
  }
  let r = 0,
    l,
    c = '',
    u = ''
  function d() {
    c &&
      (n === 0
        ? s.push({ type: 0, value: c })
        : n === 1 || n === 2 || n === 3
        ? (s.length > 1 &&
            (l === '*' || l === '+') &&
            t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),
          s.push({
            type: 1,
            value: c,
            regexp: u,
            repeatable: l === '*' || l === '+',
            optional: l === '*' || l === '?'
          }))
        : t('Invalid state to consume buffer'),
      (c = ''))
  }
  function f() {
    c += l
  }
  for (; r < e.length; ) {
    if (((l = e[r++]), l === '\\' && n !== 2)) {
      ;(i = n), (n = 4)
      continue
    }
    switch (n) {
      case 0:
        l === '/' ? (c && d(), o()) : l === ':' ? (d(), (n = 1)) : f()
        break
      case 4:
        f(), (n = i)
        break
      case 1:
        l === '(' ? (n = 2) : MV.test(l) ? f() : (d(), (n = 0), l !== '*' && l !== '?' && l !== '+' && r--)
        break
      case 2:
        l === ')' ? (u[u.length - 1] == '\\' ? (u = u.slice(0, -1) + l) : (n = 3)) : (u += l)
        break
      case 3:
        d(), (n = 0), l !== '*' && l !== '?' && l !== '+' && r--, (u = '')
        break
      default:
        t('Unknown state')
        break
    }
  }
  return n === 2 && t(`Unfinished custom RegExp for param "${c}"`), d(), o(), a
}
function PV(e, t, n) {
  const i = wV(AV(e.path), n),
    a = ft(i, { record: e, parent: t, children: [], alias: [] })
  return t && !a.record.aliasOf == !t.record.aliasOf && t.children.push(a), a
}
function TV(e, t) {
  const n = [],
    i = new Map()
  t = Dg({ strict: !1, end: !0, sensitive: !1 }, t)
  function a(u) {
    return i.get(u)
  }
  function s(u, d, f) {
    const h = !f,
      v = VV(u)
    v.aliasOf = f && f.record
    const g = Dg(t, u),
      p = [v]
    if ('alias' in u) {
      const x = typeof u.alias == 'string' ? [u.alias] : u.alias
      for (const w of x)
        p.push(
          ft({}, v, {
            components: f ? f.record.components : v.components,
            path: w,
            aliasOf: f ? f.record : v
          })
        )
    }
    let y, b
    for (const x of p) {
      const { path: w } = x
      if (d && w[0] !== '/') {
        const C = d.record.path,
          P = C[C.length - 1] === '/' ? '' : '/'
        x.path = d.record.path + (w && P + w)
      }
      if (
        ((y = PV(x, d, g)),
        f ? f.alias.push(y) : ((b = b || y), b !== y && b.alias.push(y), h && u.name && !Ig(y) && o(u.name)),
        v.children)
      ) {
        const C = v.children
        for (let P = 0; P < C.length; P++) s(C[P], y, f && f.children[P])
      }
      ;(f = f || y),
        ((y.record.components && Object.keys(y.record.components).length) ||
          y.record.name ||
          y.record.redirect) &&
          l(y)
    }
    return b
      ? () => {
          o(b)
        }
      : nr
  }
  function o(u) {
    if (o1(u)) {
      const d = i.get(u)
      d && (i.delete(u), n.splice(n.indexOf(d), 1), d.children.forEach(o), d.alias.forEach(o))
    } else {
      const d = n.indexOf(u)
      d > -1 &&
        (n.splice(d, 1), u.record.name && i.delete(u.record.name), u.children.forEach(o), u.alias.forEach(o))
    }
  }
  function r() {
    return n
  }
  function l(u) {
    let d = 0
    for (; d < n.length && kV(u, n[d]) >= 0 && (u.record.path !== n[d].record.path || !l1(u, n[d])); ) d++
    n.splice(d, 0, u), u.record.name && !Ig(u) && i.set(u.record.name, u)
  }
  function c(u, d) {
    let f,
      h = {},
      v,
      g
    if ('name' in u && u.name) {
      if (((f = i.get(u.name)), !f)) throw to(1, { location: u })
      ;(g = f.record.name),
        (h = ft(
          Og(
            d.params,
            f.keys.filter((b) => !b.optional).map((b) => b.name)
          ),
          u.params &&
            Og(
              u.params,
              f.keys.map((b) => b.name)
            )
        )),
        (v = f.stringify(h))
    } else if ('path' in u)
      (v = u.path), (f = n.find((b) => b.re.test(v))), f && ((h = f.parse(v)), (g = f.record.name))
    else {
      if (((f = d.name ? i.get(d.name) : n.find((b) => b.re.test(d.path))), !f))
        throw to(1, { location: u, currentLocation: d })
      ;(g = f.record.name), (h = ft({}, d.params, u.params)), (v = f.stringify(h))
    }
    const p = []
    let y = f
    for (; y; ) p.unshift(y.record), (y = y.parent)
    return { name: g, path: v, params: h, matched: p, meta: LV(p) }
  }
  return (
    e.forEach((u) => s(u)), { addRoute: s, resolve: c, removeRoute: o, getRoutes: r, getRecordMatcher: a }
  )
}
function Og(e, t) {
  const n = {}
  for (const i of t) i in e && (n[i] = e[i])
  return n
}
function VV(e) {
  return {
    path: e.path,
    redirect: e.redirect,
    name: e.name,
    meta: e.meta || {},
    aliasOf: void 0,
    beforeEnter: e.beforeEnter,
    props: EV(e),
    children: e.children || [],
    instances: {},
    leaveGuards: new Set(),
    updateGuards: new Set(),
    enterCallbacks: {},
    components: 'components' in e ? e.components || null : e.component && { default: e.component }
  }
}
function EV(e) {
  const t = {},
    n = e.props || !1
  if ('component' in e) t.default = n
  else for (const i in e.components) t[i] = typeof n == 'object' ? n[i] : n
  return t
}
function Ig(e) {
  for (; e; ) {
    if (e.record.aliasOf) return !0
    e = e.parent
  }
  return !1
}
function LV(e) {
  return e.reduce((t, n) => ft(t, n.meta), {})
}
function Dg(e, t) {
  const n = {}
  for (const i in e) n[i] = i in t ? t[i] : e[i]
  return n
}
function l1(e, t) {
  return t.children.some((n) => n === e || l1(e, n))
}
const c1 = /#/g,
  OV = /&/g,
  IV = /\//g,
  DV = /=/g,
  FV = /\?/g,
  u1 = /\+/g,
  RV = /%5B/g,
  BV = /%5D/g,
  d1 = /%5E/g,
  NV = /%60/g,
  f1 = /%7B/g,
  $V = /%7C/g,
  h1 = /%7D/g,
  zV = /%20/g
function ph(e) {
  return encodeURI('' + e)
    .replace($V, '|')
    .replace(RV, '[')
    .replace(BV, ']')
}
function HV(e) {
  return ph(e).replace(f1, '{').replace(h1, '}').replace(d1, '^')
}
function Nd(e) {
  return ph(e)
    .replace(u1, '%2B')
    .replace(zV, '+')
    .replace(c1, '%23')
    .replace(OV, '%26')
    .replace(NV, '`')
    .replace(f1, '{')
    .replace(h1, '}')
    .replace(d1, '^')
}
function WV(e) {
  return Nd(e).replace(DV, '%3D')
}
function jV(e) {
  return ph(e).replace(c1, '%23').replace(FV, '%3F')
}
function UV(e) {
  return e == null ? '' : jV(e).replace(IV, '%2F')
}
function dc(e) {
  try {
    return decodeURIComponent('' + e)
  } catch {}
  return '' + e
}
function YV(e) {
  const t = {}
  if (e === '' || e === '?') return t
  const i = (e[0] === '?' ? e.slice(1) : e).split('&')
  for (let a = 0; a < i.length; ++a) {
    const s = i[a].replace(u1, ' '),
      o = s.indexOf('='),
      r = dc(o < 0 ? s : s.slice(0, o)),
      l = o < 0 ? null : dc(s.slice(o + 1))
    if (r in t) {
      let c = t[r]
      di(c) || (c = t[r] = [c]), c.push(l)
    } else t[r] = l
  }
  return t
}
function Fg(e) {
  let t = ''
  for (let n in e) {
    const i = e[n]
    if (((n = WV(n)), i == null)) {
      i !== void 0 && (t += (t.length ? '&' : '') + n)
      continue
    }
    ;(di(i) ? i.map((s) => s && Nd(s)) : [i && Nd(i)]).forEach((s) => {
      s !== void 0 && ((t += (t.length ? '&' : '') + n), s != null && (t += '=' + s))
    })
  }
  return t
}
function GV(e) {
  const t = {}
  for (const n in e) {
    const i = e[n]
    i !== void 0 && (t[n] = di(i) ? i.map((a) => (a == null ? null : '' + a)) : i == null ? i : '' + i)
  }
  return t
}
const XV = Symbol(''),
  Rg = Symbol(''),
  yh = Symbol(''),
  v1 = Symbol(''),
  $d = Symbol('')
function Io() {
  let e = []
  function t(i) {
    return (
      e.push(i),
      () => {
        const a = e.indexOf(i)
        a > -1 && e.splice(a, 1)
      }
    )
  }
  function n() {
    e = []
  }
  return { add: t, list: () => e.slice(), reset: n }
}
function ma(e, t, n, i, a) {
  const s = i && (i.enterCallbacks[a] = i.enterCallbacks[a] || [])
  return () =>
    new Promise((o, r) => {
      const l = (d) => {
          d === !1
            ? r(to(4, { from: n, to: t }))
            : d instanceof Error
            ? r(d)
            : bV(d)
            ? r(to(2, { from: t, to: d }))
            : (s && i.enterCallbacks[a] === s && typeof d == 'function' && s.push(d), o())
        },
        c = e.call(i && i.instances[a], t, n, l)
      let u = Promise.resolve(c)
      e.length < 3 && (u = u.then(l)), u.catch((d) => r(d))
    })
}
function Tu(e, t, n, i) {
  const a = []
  for (const s of e)
    for (const o in s.components) {
      let r = s.components[o]
      if (!(t !== 'beforeRouteEnter' && !s.instances[o]))
        if (KV(r)) {
          const c = (r.__vccOpts || r)[t]
          c && a.push(ma(c, n, i, s, o))
        } else {
          let l = r()
          a.push(() =>
            l.then((c) => {
              if (!c) return Promise.reject(new Error(`Couldn't resolve component "${o}" at "${s.path}"`))
              const u = tV(c) ? c.default : c
              s.components[o] = u
              const f = (u.__vccOpts || u)[t]
              return f && ma(f, n, i, s, o)()
            })
          )
        }
    }
  return a
}
function KV(e) {
  return typeof e == 'object' || 'displayName' in e || 'props' in e || '__vccOpts' in e
}
function Bg(e) {
  const t = st(yh),
    n = st(v1),
    i = A(() => t.resolve(Xe(e.to))),
    a = A(() => {
      const { matched: l } = i.value,
        { length: c } = l,
        u = l[c - 1],
        d = n.matched
      if (!u || !d.length) return -1
      const f = d.findIndex(eo.bind(null, u))
      if (f > -1) return f
      const h = Ng(l[c - 2])
      return c > 1 && Ng(u) === h && d[d.length - 1].path !== h ? d.findIndex(eo.bind(null, l[c - 2])) : f
    }),
    s = A(() => a.value > -1 && JV(n.params, i.value.params)),
    o = A(() => a.value > -1 && a.value === n.matched.length - 1 && a1(n.params, i.value.params))
  function r(l = {}) {
    return ZV(l) ? t[Xe(e.replace) ? 'replace' : 'push'](Xe(e.to)).catch(nr) : Promise.resolve()
  }
  return { route: i, href: A(() => i.value.href), isActive: s, isExactActive: o, navigate: r }
}
const qV = hn({
    name: 'RouterLink',
    compatConfig: { MODE: 3 },
    props: {
      to: { type: [String, Object], required: !0 },
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: { type: String, default: 'page' }
    },
    useLink: Bg,
    setup(e, { slots: t }) {
      const n = yn(Bg(e)),
        { options: i } = st(yh),
        a = A(() => ({
          [$g(e.activeClass, i.linkActiveClass, 'router-link-active')]: n.isActive,
          [$g(e.exactActiveClass, i.linkExactActiveClass, 'router-link-exact-active')]: n.isExactActive
        }))
      return () => {
        const s = t.default && t.default(n)
        return e.custom
          ? s
          : Ei(
              'a',
              {
                'aria-current': n.isExactActive ? e.ariaCurrentValue : null,
                href: n.href,
                onClick: n.navigate,
                class: a.value
              },
              s
            )
      }
    }
  }),
  bi = qV
function ZV(e) {
  if (
    !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) &&
    !e.defaultPrevented &&
    !(e.button !== void 0 && e.button !== 0)
  ) {
    if (e.currentTarget && e.currentTarget.getAttribute) {
      const t = e.currentTarget.getAttribute('target')
      if (/\b_blank\b/i.test(t)) return
    }
    return e.preventDefault && e.preventDefault(), !0
  }
}
function JV(e, t) {
  for (const n in t) {
    const i = t[n],
      a = e[n]
    if (typeof i == 'string') {
      if (i !== a) return !1
    } else if (!di(a) || a.length !== i.length || i.some((s, o) => s !== a[o])) return !1
  }
  return !0
}
function Ng(e) {
  return e ? (e.aliasOf ? e.aliasOf.path : e.path) : ''
}
const $g = (e, t, n) => e ?? t ?? n,
  QV = hn({
    name: 'RouterView',
    inheritAttrs: !1,
    props: { name: { type: String, default: 'default' }, route: Object },
    compatConfig: { MODE: 3 },
    setup(e, { attrs: t, slots: n }) {
      const i = st($d),
        a = A(() => e.route || i.value),
        s = st(Rg, 0),
        o = A(() => {
          let c = Xe(s)
          const { matched: u } = a.value
          let d
          for (; (d = u[c]) && !d.components; ) c++
          return c
        }),
        r = A(() => a.value.matched[o.value])
      Vt(
        Rg,
        A(() => o.value + 1)
      ),
        Vt(XV, r),
        Vt($d, a)
      const l = te()
      return (
        Pe(
          () => [l.value, r.value, e.name],
          ([c, u, d], [f, h, v]) => {
            u &&
              ((u.instances[d] = c),
              h &&
                h !== u &&
                c &&
                c === f &&
                (u.leaveGuards.size || (u.leaveGuards = h.leaveGuards),
                u.updateGuards.size || (u.updateGuards = h.updateGuards))),
              c && u && (!h || !eo(u, h) || !f) && (u.enterCallbacks[d] || []).forEach((g) => g(c))
          },
          { flush: 'post' }
        ),
        () => {
          const c = a.value,
            u = e.name,
            d = r.value,
            f = d && d.components[u]
          if (!f) return zg(n.default, { Component: f, route: c })
          const h = d.props[u],
            v = h ? (h === !0 ? c.params : typeof h == 'function' ? h(c) : h) : null,
            p = Ei(
              f,
              ft({}, v, t, {
                onVnodeUnmounted: (y) => {
                  y.component.isUnmounted && (d.instances[u] = null)
                },
                ref: l
              })
            )
          return zg(n.default, { Component: p, route: c }) || p
        }
      )
    }
  })
function zg(e, t) {
  if (!e) return null
  const n = e(t)
  return n.length === 1 ? n[0] : n
}
const g1 = QV
function eE(e) {
  const t = TV(e.routes, e),
    n = e.parseQuery || YV,
    i = e.stringifyQuery || Fg,
    a = e.history,
    s = Io(),
    o = Io(),
    r = Io(),
    l = Ce(fa)
  let c = fa
  Fs && e.scrollBehavior && 'scrollRestoration' in history && (history.scrollRestoration = 'manual')
  const u = Au.bind(null, (Y) => '' + Y),
    d = Au.bind(null, UV),
    f = Au.bind(null, dc)
  function h(Y, ne) {
    let W, le
    return o1(Y) ? ((W = t.getRecordMatcher(Y)), (le = ne)) : (le = Y), t.addRoute(le, W)
  }
  function v(Y) {
    const ne = t.getRecordMatcher(Y)
    ne && t.removeRoute(ne)
  }
  function g() {
    return t.getRoutes().map((Y) => Y.record)
  }
  function p(Y) {
    return !!t.getRecordMatcher(Y)
  }
  function y(Y, ne) {
    if (((ne = ft({}, ne || l.value)), typeof Y == 'string')) {
      const H = Pu(n, Y, ne.path),
        Z = t.resolve({ path: H.path }, ne),
        ae = a.createHref(H.fullPath)
      return ft(H, Z, { params: f(Z.params), hash: dc(H.hash), redirectedFrom: void 0, href: ae })
    }
    let W
    if ('path' in Y) W = ft({}, Y, { path: Pu(n, Y.path, ne.path).path })
    else {
      const H = ft({}, Y.params)
      for (const Z in H) H[Z] == null && delete H[Z]
      ;(W = ft({}, Y, { params: d(H) })), (ne.params = d(ne.params))
    }
    const le = t.resolve(W, ne),
      De = Y.hash || ''
    le.params = u(f(le.params))
    const L = aV(i, ft({}, Y, { hash: HV(De), path: le.path })),
      D = a.createHref(L)
    return ft({ fullPath: L, hash: De, query: i === Fg ? GV(Y.query) : Y.query || {} }, le, {
      redirectedFrom: void 0,
      href: D
    })
  }
  function b(Y) {
    return typeof Y == 'string' ? Pu(n, Y, l.value.path) : ft({}, Y)
  }
  function x(Y, ne) {
    if (c !== Y) return to(8, { from: ne, to: Y })
  }
  function w(Y) {
    return k(Y)
  }
  function C(Y) {
    return w(ft(b(Y), { replace: !0 }))
  }
  function P(Y) {
    const ne = Y.matched[Y.matched.length - 1]
    if (ne && ne.redirect) {
      const { redirect: W } = ne
      let le = typeof W == 'function' ? W(Y) : W
      return (
        typeof le == 'string' &&
          ((le = le.includes('?') || le.includes('#') ? (le = b(le)) : { path: le }), (le.params = {})),
        ft({ query: Y.query, hash: Y.hash, params: 'path' in le ? {} : Y.params }, le)
      )
    }
  }
  function k(Y, ne) {
    const W = (c = y(Y)),
      le = l.value,
      De = Y.state,
      L = Y.force,
      D = Y.replace === !0,
      H = P(W)
    if (H)
      return k(
        ft(b(H), { state: typeof H == 'object' ? ft({}, De, H.state) : De, force: L, replace: D }),
        ne || W
      )
    const Z = W
    Z.redirectedFrom = ne
    let ae
    return (
      !L && sV(i, le, W) && ((ae = to(16, { to: Z, from: le })), ce(le, le, !0, !1)),
      (ae ? Promise.resolve(ae) : T(Z, le))
        .catch((se) => (Fi(se) ? (Fi(se, 2) ? se : de(se)) : X(se, Z, le)))
        .then((se) => {
          if (se) {
            if (Fi(se, 2))
              return k(
                ft({ replace: D }, b(se.to), {
                  state: typeof se.to == 'object' ? ft({}, De, se.to.state) : De,
                  force: L
                }),
                ne || Z
              )
          } else se = O(Z, le, !0, D, De)
          return B(Z, le, se), se
        })
    )
  }
  function S(Y, ne) {
    const W = x(Y, ne)
    return W ? Promise.reject(W) : Promise.resolve()
  }
  function _(Y) {
    const ne = He.values().next().value
    return ne && typeof ne.runWithContext == 'function' ? ne.runWithContext(Y) : Y()
  }
  function T(Y, ne) {
    let W
    const [le, De, L] = tE(Y, ne)
    W = Tu(le.reverse(), 'beforeRouteLeave', Y, ne)
    for (const H of le)
      H.leaveGuards.forEach((Z) => {
        W.push(ma(Z, Y, ne))
      })
    const D = S.bind(null, Y, ne)
    return (
      W.push(D),
      ie(W)
        .then(() => {
          W = []
          for (const H of s.list()) W.push(ma(H, Y, ne))
          return W.push(D), ie(W)
        })
        .then(() => {
          W = Tu(De, 'beforeRouteUpdate', Y, ne)
          for (const H of De)
            H.updateGuards.forEach((Z) => {
              W.push(ma(Z, Y, ne))
            })
          return W.push(D), ie(W)
        })
        .then(() => {
          W = []
          for (const H of L)
            if (H.beforeEnter)
              if (di(H.beforeEnter)) for (const Z of H.beforeEnter) W.push(ma(Z, Y, ne))
              else W.push(ma(H.beforeEnter, Y, ne))
          return W.push(D), ie(W)
        })
        .then(
          () => (
            Y.matched.forEach((H) => (H.enterCallbacks = {})),
            (W = Tu(L, 'beforeRouteEnter', Y, ne)),
            W.push(D),
            ie(W)
          )
        )
        .then(() => {
          W = []
          for (const H of o.list()) W.push(ma(H, Y, ne))
          return W.push(D), ie(W)
        })
        .catch((H) => (Fi(H, 8) ? H : Promise.reject(H)))
    )
  }
  function B(Y, ne, W) {
    r.list().forEach((le) => _(() => le(Y, ne, W)))
  }
  function O(Y, ne, W, le, De) {
    const L = x(Y, ne)
    if (L) return L
    const D = ne === fa,
      H = Fs ? history.state : {}
    W && (le || D ? a.replace(Y.fullPath, ft({ scroll: D && H && H.scroll }, De)) : a.push(Y.fullPath, De)),
      (l.value = Y),
      ce(Y, ne, W, D),
      de()
  }
  let N
  function Q() {
    N ||
      (N = a.listen((Y, ne, W) => {
        if (!Ue.listening) return
        const le = y(Y),
          De = P(le)
        if (De) {
          k(ft(De, { replace: !0 }), le).catch(nr)
          return
        }
        c = le
        const L = l.value
        Fs && hV(Pg(L.fullPath, W.delta), Qc()),
          T(le, L)
            .catch((D) =>
              Fi(D, 12)
                ? D
                : Fi(D, 2)
                ? (k(D.to, le)
                    .then((H) => {
                      Fi(H, 20) && !W.delta && W.type === Ar.pop && a.go(-1, !1)
                    })
                    .catch(nr),
                  Promise.reject())
                : (W.delta && a.go(-W.delta, !1), X(D, le, L))
            )
            .then((D) => {
              ;(D = D || O(le, L, !1)),
                D &&
                  (W.delta && !Fi(D, 8)
                    ? a.go(-W.delta, !1)
                    : W.type === Ar.pop && Fi(D, 20) && a.go(-1, !1)),
                B(le, L, D)
            })
            .catch(nr)
      }))
  }
  let ue = Io(),
    j = Io(),
    U
  function X(Y, ne, W) {
    de(Y)
    const le = j.list()
    return le.length ? le.forEach((De) => De(Y, ne, W)) : console.error(Y), Promise.reject(Y)
  }
  function oe() {
    return U && l.value !== fa
      ? Promise.resolve()
      : new Promise((Y, ne) => {
          ue.add([Y, ne])
        })
  }
  function de(Y) {
    return U || ((U = !Y), Q(), ue.list().forEach(([ne, W]) => (Y ? W(Y) : ne())), ue.reset()), Y
  }
  function ce(Y, ne, W, le) {
    const { scrollBehavior: De } = e
    if (!Fs || !De) return Promise.resolve()
    const L = (!W && vV(Pg(Y.fullPath, 0))) || ((le || !W) && history.state && history.state.scroll) || null
    return mt()
      .then(() => De(Y, ne, L))
      .then((D) => D && fV(D))
      .catch((D) => X(D, Y, ne))
  }
  const Te = (Y) => a.go(Y)
  let $e
  const He = new Set(),
    Ue = {
      currentRoute: l,
      listening: !0,
      addRoute: h,
      removeRoute: v,
      hasRoute: p,
      getRoutes: g,
      resolve: y,
      options: e,
      push: w,
      replace: C,
      go: Te,
      back: () => Te(-1),
      forward: () => Te(1),
      beforeEach: s.add,
      beforeResolve: o.add,
      afterEach: r.add,
      onError: j.add,
      isReady: oe,
      install(Y) {
        const ne = this
        Y.component('RouterLink', bi),
          Y.component('RouterView', g1),
          (Y.config.globalProperties.$router = ne),
          Object.defineProperty(Y.config.globalProperties, '$route', { enumerable: !0, get: () => Xe(l) }),
          Fs && !$e && l.value === fa && (($e = !0), w(a.location).catch((De) => {}))
        const W = {}
        for (const De in fa) Object.defineProperty(W, De, { get: () => l.value[De], enumerable: !0 })
        Y.provide(yh, ne), Y.provide(v1, t0(W)), Y.provide($d, l)
        const le = Y.unmount
        He.add(Y),
          (Y.unmount = function () {
            He.delete(Y),
              He.size < 1 && ((c = fa), N && N(), (N = null), (l.value = fa), ($e = !1), (U = !1)),
              le()
          })
      }
    }
  function ie(Y) {
    return Y.reduce((ne, W) => ne.then(() => _(W)), Promise.resolve())
  }
  return Ue
}
function tE(e, t) {
  const n = [],
    i = [],
    a = [],
    s = Math.max(t.matched.length, e.matched.length)
  for (let o = 0; o < s; o++) {
    const r = t.matched[o]
    r && (e.matched.find((c) => eo(c, r)) ? i.push(r) : n.push(r))
    const l = e.matched[o]
    l && (t.matched.find((c) => eo(c, l)) || a.push(l))
  }
  return [n, i, a]
}
const Oi = (e, t) => {
    const n = e.__vccOpts || e
    for (const [i, a] of t) n[i] = a
    return n
  },
  nE = {}
function iE(e, t) {
  const n = Se('v-app-bar-nav-icon'),
    i = Se('v-app-bar-title'),
    a = Se('v-btn'),
    s = Se('v-app-bar')
  return (
    Re(),
    Ct(
      s,
      { color: 'blue', density: 'comfortable' },
      {
        prepend: we(() => [m(n)]),
        append: we(() => [m(a, { icon: 'mdi-dots-vertical' })]),
        default: we(() => [m(i, null, { default: we(() => [nt('Easy Phone')]), _: 1 })]),
        _: 1
      }
    )
  )
}
const aE = Oi(nE, [['render', iE]]),
  sE = hn({
    __name: 'App',
    setup(e) {
      te({})
      const t = te(!0),
        n = te(!1)
      return (i, a) => {
        const s = Se('v-btn'),
          o = Se('v-list-item'),
          r = Se('v-divider'),
          l = Se('v-list'),
          c = Se('v-navigation-drawer'),
          u = Se('v-container'),
          d = Se('v-main'),
          f = Se('v-layout'),
          h = Se('v-app')
        return (
          Re(),
          Ct(h, null, {
            default: we(() => [
              m(f, null, {
                default: we(() => [
                  m(
                    c,
                    {
                      color: 'black',
                      modelValue: t.value,
                      'onUpdate:modelValue': a[1] || (a[1] = (v) => (t.value = v)),
                      rail: n.value,
                      permanent: '',
                      onClick: a[2] || (a[2] = (v) => (n.value = !1))
                    },
                    {
                      default: we(() => [
                        m(
                          o,
                          {
                            'prepend-avatar':
                              'data:image/PNG;base64,iVBORw0KGgoAAAANSUhEUgAAAHkAAAAyCAIAAAD3B+OxAAAj/UlEQVR42u1793dTV9Z2/op3YssyJpACsdVMS0hIMpM+eWcmmSQwycwkmRAgYOMuNyAQSiCQHgjFxra6rrpkuVsuuPci965yy7lFMqSs97dvnytMSCCTTHlnfev78DpL61q6Oufc5+zz7Gfvs3UXz9H/VGM4luZYiueomekxhgwIiOJ5huNpgWf+2T7/H293/StYA9CIDrqdRMcVn4BIEfo7mP77saYFjo5wVE9Hs0lbajNrF2YnWETeAfTfjzUGmqXnp8YcJo3dWG41lFe5rQy5BOgLsRvuMMm/za5ZiqND9ZVOl0nrMJa5CI3DounpaInydPQGZfN38P2XscZQstRAT4fLrHMayj1mTaVVB1i7rIa5Kb/AApNQd7D+17AG7HhGAJcIZDE36bbq3YTWY9a6zRo3ofFYtG5CV+uxs1QQnCR3HWtqpdE3XdzB+vv2Y1AEno7EmAEu4F9E+WrcTnOFB7AmtJUWHTSvVQ/XDrO2q60F7oQWU4Q3mvA99MwdrP+eJ4xyTIRjBGiIGh7ospk1HqsOzBkgjmGNG1i6Ve+yGmenxzlEAtwRgbll5eAdtAI39f+Vsd/1i1UHE+UQtNDSnNthdlh0bov2e5TFBu84zRonMInXydJB+NbNihsTC/4XxZqAN8r1dgdr3CJCDBQgBCbCYqx9dVVOMF6LFuz6VqzhTdAkNmN51xVfRMQ3xicxZSLyOMOyDAvXPDSKF/7XXag40A/af2w4Hra1wPwirEWMaBaFOR4AQhGenRgecpr0LkIHmN6KtcgqFU7jZaByu0k7M+GHpfqRXbMQarIkvEK7PiH+F8ief/rh+Z/B+u90fsNK/qEJ3AZr/mewBmrmBGyVJGIZiv3mcoWts73d6yBcZr1rRXjc7BuxXRM6l0XnILQ2s8VkMFa6vBRAykcRF2H5KMtFeD7KIBYhjkHwQUi0cVZ8eMQLYOMr6APDxGg9pnx4JL4fFkSHwXMcx/MsT/I8teIAxOf5vlE8T+LMDL4f+oRrihPCHO4fxiV/4CEExAo0x7HwFVagEE7phHn8LYCJFgQ8OrQb3YqDIg73HLtmeRbuD2OUY06IF+fD4ediYa7Q4cqIP4E1PCGwM8yMDc8sCNkF5y5rqtpbmh2mMqcZ8NVVEj8m60oMPZC16dxXJdtfO7D99aOv/unEzrRzGQUV+wsq0vLL09W45R2oOHupbtAfoDm8XTgEaAdhFB6wwKDAFEnACNyDeI1wPouDSd94BprlRArCuwQ/HocfkuXwH8INFg9uECiaBSuheJaE2xCsMBtjMNimtPj8cKcolvDXaTwa3nA0wqMCNDArxPJ4bcTMD4xIAmQ4JEYMC5YAtoGgN3iTwvEE7FRANhbi4Y9BGYd4WDNQB7A8HPl37JoVODCiAMtS8yH+lb8ef2PnyZHhWYdZ5yHKPcAVhN5ruYVACE0VMLXe+MHpkrWytCR58SrZwUSFWqrITVTkwqtUnheXnC2VZUhT9idvzSDcvRQTQQyMsoiYMLYOBPPmIxy5EuhDxMTywGBcEB4bMRzNBIF/GHaJZRciDH5s8WkDHBvm4Bo3kkckx9DgEmg6iFAYIUAceqY5hmFQkEWBCPAYYAesCICxrIDICEMKcAMbYqgA9MDhaSAOIZzeYWMwAbTQZwh6wxYNyKIww4QYtIS4IM/ifvCCAaaI4hFgDrctMDAQCi0zIZ6hxDwdc9dtmUuADc4HZxf51976TP7wvs6+pSq3220CW67A1GExeC2GH9s1GLtZYzfoT5wpSVKkSzcUJm3Ie3b7h8/v+GDH25/9ec/5P+268NQfTz7wUGaCoiBenivbmt7VH56eJwdHw0OjVIiEQeGZYabY3gWR+GDeEWyYSxTDDY+FRscDoSDgQM4vBgb81JCfHPaHh/2hobHF4bGFEX9wBF8HR8bo0VFycYGanFgaGAoN+OcpmpqcDA/5Q6OTSyTJIIZk2SUwSQ6vQRiWzz+22D+2OD4dnJsPDU3QQ+PU7CzJMgyP4abwnuBQMEwOjAT6R5YWF8OTs4G+0VD/6MLkHKwZMEUYeyDYKIA7g3eJfyLc70eDo8FQAMwcNh7eHLexa/gmLC/NRdXvGZPWZWUVVbR1dmLqMGkqiQqPVVtpA019C9bYtLXA5ifPXFqtyJIq1YptOVqD20JYO9raooIQXf6Gj3zb0r2Y8mi+RJErSd79eWl94XH9vYq9yZv2+DqGER9i8WYE0mQxFQrwnMD0FI3I+uaJNbKd65S73jusR8zy6U9sq1V71yjT1iqy71HmrtmQtWZD+poNGWtTc9ZszFm7MWf9hr1lpvYXXz9834YM2cN7R6aZP24/cr8yXb41s8LYzdBRAcZiQhweLhwkI1ueSL9307s79587e6l67YZ9a1L3FR28IBp3mMOmDRbAtXaOr0nZuS71XY2u/a+7PoKe16fuffWN0wE6yrALOE4Gh4RgeajhUXLLEzCNffdt2Gmt7Ab+ug3WMakABg9rVWG6Ik1OS0pJ15kaHaDkzJpKMzZewBrDfQvQMcp2mXSnzlxOUuRLFQdU23KNWqfDaHKbDQsTw1c5FOEiiPt6x9tfSBUF0uTc4uOWvKOmhOTcJPm++o4JBIaMiZOCDc5FoIHzhN1JB5nIG3vOrZIVxifnKh8tHBilPjhN3Kfce68qbY3q3dUb9ktgOOVBiSLn3o05a1Iz1mzIXKvcdZnoemrH8btTiu7dmDU8F33upeOJioLE1IL7U9PKjZ00vwycg3PufCBIXU3ekgVf/8u750v1LfHyrHhFXk5RCYOA0mjRiwDhc61dM/913+745H3lhu7tOz+LlxcmydSJKekXtI3Yt4BFg4FjG+XT88qTlHm/kuUnpGSZXb23xVp0FIA1QpMz1LZnixIU+ese2mMlKl3mCiw8AGuL3mOLYa29rV27Cf2pj0pXqfKkG4vkj+VodS4rYbWZDV63A9Hg36JTc9yjTx8CGklITv/0fHX++5a4B7NXqdLq26dgqwkIxI8Id4TmIthHgQpq6Zl6YHNmgiz7bkV2nDyv+ANiep4ZGAkNjtJDY6G+cTp5y/6kFPXDzxzsHQKiADYIDY2EpueY57e/HycrBuhH56PPvHQiQVUoUR1IlOeueyij1NRCUYKAIOAKhGnAOjtelvvW3vMVxuYEGcY6t7gCcVGERSqJfSMrYn3/bok8HZZq++5P45RFsHgJsrzHni8C+QCbAHYAzNzXPbFuk/puea4k9WBCcrbV0QOLymPPjH3jDeWEYrIXjOvLkqYkhTpepX7idwctBpvLVA7aw2O5vaz+AYcQppMY6wzAeu1G9Qs7jr+w49DvXjv0uz+9//o7n//5nc82PV0gSc6QyArWpu5r6VoqOmqNA3JXZdS1T7ECg1UEUDSIBGwkPCg2kBS7ss7GJWc++Gjx+scOSWT596dm9gwGgBcZcP0gSoTvkrful8jztj17hGSuMSzNYHMBB8A9+8pJMPm1G7P9s8KTL38AWy1ReTBRmZeoKL53c8Z5TRMwN2iGYDiy/uFMaYr6b3u/qjB2rUoBrPNzinXYT7MYJrz8LN3aMRd3/+54eXaZsX377o8BTVgeGFcqz/richXCCibMsFdf3fV5oqxYolAnKgrjZVkWZ7+ANwiK2TW1cqbFxLAOk8IzfzyeqCy4W5n36lufuAiL21wBBB0D+u9g7TXrK03EydNlq1S58RsOJaYWJqjyE1R5CapceIXhJfLcBLk6MTlnbWr6yS8cNHPtwBG9RJ6xSpVV3zaNqYMVN5yoBCMI3H2osW16jTJTsj738IeuDz6vSkpOT5TtTVNfAK2ESQ/EgvDd+kf2xynytj1/kELLIALQ91ifkigL7t2U65+JgltepSze+sLHb2dXSBXqVaoDa1WZF8vbKEYgyeiDW7OkcvWbe8+BzSZiuy7MPqgHdQ27CqQ8/uOZ5s6Z+HXvxMszKowdO3Z/JlHkrXu4eMtzhyXy/NTfqP3TIcSRZkd3ouLdJHnGf79xMQk4RI6xBslzG6yx/OaoroGA5ME0sAiJqnDHW5+6LCaw61+CdaVZ7zGbTp0uS1LmS1LfS1Llr9+iXrcpc92m9HWb9kNTPpb35B/e25N9vqZ5EgnXBDZy4Ig1PkW9SpndcGVGjAWAx1gxTgksswEw3Z05pQDNA1vSphej88GrDz9ZHKfIuG9zdk8fiC1sdCj67QOP7L9bUbDtOcAaIqaYzqXDVAzr/Ps3q8enrz790snVqsInXzo1Gfx2Z/bZexQFq5RFD2zJKTVeWQhdS96GLfTNtHOXjR3SlCzgh6xDOgbMGoyaxzBxAt3SNRO3bqdEkaExdL6++2yCLEf1WNEFbWeCMjNelnfoBAEz/O32U1JF5s6Mi8c+r06S5SXKMglH361Y41hIDHWYzy5Uw5cliiIguN/vOGk3m7wY35/FWuuyalxW3ckzJavlYDiHVNuKDPpKB2FzEITTbLGbCDthamm5wnFRCCb5CFDE1cJj9rsV6tXKnMa2WVbcqjgo4WPiGnX0Be57KBsE4v4DZv+MMDKF3vu4/r8UWXfL897adz4MKguRTPTa+kcz4pQHtz33PsUsizEFJWLNY6xV+fdvUU9MXX3qxROrVEVPvXQiSPGLYW5v1vk1ikKpKnd1asbpi53rthXGy9V/2/9VmbkjISUzXlGUc0jP4HiHjLBhMWyhmjrn7l63O16xX2vs+POus7APNjxRMD4b3bHvU6ki/4ENuYdP16+W56zbmtXWu3Ti88okCCxkWYRzAJTrj7EWcJxGg3vKKi4D55CgKJYo1Zt/nWuzuJwWzS+xa7dV67LpTn1UslqhTko9pAQdorc7jAYQJ26TwUOYQJg7Ce3s+BAOfIED2OWC48TdyqwkRXYTYI3xhagMB8QQWUBM/XbWhfjkTBAqD6QWJKdmPJi6d92mbIksJ0F+YPWmjPq2CWAaJnIt+ZH98YqDW589EsYcAjIGQiEGsH7m5VMJqQX3bcmdmrn25IvHpKqip188KeprFAgKmfnaREVOQmrR6g0HpKkFUlXx3/afLze1J8oygHnS87UkEiICu8yTERxH8ib7UPyDGXGy9ApDy+u7zoJwUD5RMDPHV7eOrFHtg62ckJKTIMvMfr+cYa6d+sItVWYlpuQS9gEBMT/GGps2TpewuzLPS7BALpSAdFW8c6mUcFi0ELx4xDTez/A1of/wTGmSPD8h9ZDs8Ry9nnDggxtwrTiF4iDKHaDQHYZweJETgJyvFh+1SuQ59yhymtrnYakFPoJAGWL9RDX2TKzdmCVNzvjdX0/uyimBtjP7/K7cr17beW51SkG8KvfP735KMd8x/Neyh9MS5IUPPX8ozC1j5YAzIZhDYliv3Zw9NX3tyZeOSlMPPP3SRySJ42+InoMMl3nIsHpjfmJqEZi/RFb4Vvp5Z81wYnKaVFnwyLPFo9MQpi9zWGFcC4S/fmP3l4nygl89+K67avj1PV/GK/PljxfMzELocvWdjPOJSmB59ZbnD0+GhQgrnPrcLUnNSZTlE/Z+0buiW/U1zuzsySkBB5qgBA+rTpLnZeR+4SbMVRC8xJS1VecldN7bYK2vIiDA0X545vJqVXZC6kHZ45l6vdUJAgbwNWtAybhhqSxGl6Wso7kmijiGjRQes0iTC1fJ819Lu5h+sCyruCL3QMX5kmrEX9v/XplEliV7KHdoAoLfKILHhq3ARxdC3z770kdScLmyvTWtC2TkG9lWUMfFW55/L8R9w4PPxBmJcJgWnnnlaGJq8X2bc8Zmrj71h2NAa0+/fDoMEbjoV1kuEKBRWkHpPYq8+A3F8fIDb6V/NbUY2fDw/kSsMTJSf1OUeVD/6aW6ouO2Z149naTMkSpzNz2ePz8b2bHr41+lqlWPF87MgS+nBvykbGvhParsEqKdxVCzJ8/aE+TFUlme2dnO4pDlllgGwvTFhbn03HPxsnSJqmiVvCgxWf3QbzKMJofLZnISRg9hrLTqK38ilgHjdRG6k6fL1yj2rVEVpz6Sp9daXTiLUuElYJHwd0VdWOI0l8/6J3luufiIdpUsI04OFAkKOleanJMk2/3XvR9391H3pqavkuVl5pdiKwchh50m1v40i0r0vqSUPUmKzFffPBNgvpM/lJUoz3j4ueIgK3B8UOBJgadIevm3Lx+5R1W4DrCeiz77IgiPw0/94TTFRHD2DQlR7J+CASqaVViepMhanZL/t71fcsv/Y7Z3yyC0kWVLgRZkOZKUTAmoQDl2G+u3Zpk9fbTw9Wt7vpCm5ikezZybgSCXRNzVI6esL77+3iIV5fkIxQqnzzmSVGCpWSZbF3ZA3A/tWgC/hML1td6Pz2ilsp3xIPtlxasVRdKUPbuzTlvtLpfV5LXooWFqtt0Wbo3LpL90QffWrvff2PXBvrQTFoPZTVzH2hvD2qLx2Mog5Km2Oelg2O5szX+vPP9YhfqoJu+IIf+IUX34com+yuZqUx/R5B/Vd/ZOCSwVZUic5ITAHdicWwyQ4SMnjHlHjIdOaCZmqCMn9YXHtSc+NjBYk1M8zoLSNI0+O2ctPG4uPqFbCEU+/pIoOkZ8fM5DQze8AI45yjJRWBWBXQqjM5/bD7xvKNM1spFlWIGhceqzC/Xv7P/qlTc/eWH76Rf/cubN9C8/Ol8zPEqDT4cA4JKm8sAR3YnTZgp2nJgEnpgJ9PSPsggIOQxW4W3oVR/TFx7TtXdP4iwkJgx0F3c9R4xPb4f7u8y6clMFsfnXaaCWpLJCqSwfxNADG9M+/MRktxq8xOUas95L6D3WitvwtUXjJQwus8lBmGyEHpjaZcZn7ZX4/RspFHzU4DTqXUZDh68W5iHw3/Hc1xA4IDGFitOj2JIZmqdJgabFLBrPhDiBFCJBvP/ZEGIWERuh+CgrRBGiQCfixA+wa0wycqBxWJwjxZlj2NHYs+FMKxYEWAIgGEdgBPEaXnHeHEwvKtA4bMXJL/g0GgG3AVo9AlxEsxEOloYDz0tdQzipCx0vY1sV8JThezCXiHjwzdNRNhjlKJrBuT7MyDi7fT1djrHmxANWhlx0WvSEttSq02WqP10t37dKkR+nzI1XFoAs37gt86uLJo/N4iWM4Ce9Nl2lVYwkcdrv+kUljuNxKO826VxGLTS3CUgDmBoWBlbI4AUfS2BB4jLDkmidpnL/YJeYX8RZdVFZ4zMEllviUZhFEJUEAWKcyMf7HUw7iLOgLC1mXEGnhAW8HUGM0wyCazYay/RjEBl80MHRkYggHsWJxsSCqGCjgDJAA9o+IgBMHM4vQwQKN5D8cgifSGAbxHkYHuevwfCx4BPwMkDn+LRaXBkUEWhmOYi/HmVE4QRyBSfEl3HeH2J6mG0oApuMC3yPNT6LgpAfhX11AMhlqw6wLr1Uat38GJBg1q825IIrX606kCTPeeQ3uWfPEQ4b4cQ8YHARmhsqMNbcFgMoDSdRDiIPyERUIDo3Lm2owMcLoFJwAkvjBpSJCqe5zGEoc1tNZHAB594xqQkcF0vqkxDOYIpD4sNzXIQVT4Fj58J8SAzlxZS8eCQfS1cBxAAETS0NDvV0tDfPTowKKITIwOhI9/Bo76i/b9I/xsE73NK4f2h0uMcPb470Li1ML85Njo90+4cHx8dHccZZQHNzU/6xgcWl6XH/wNhIv3+ozz86MDM3IXIPGQhMT48NAZvBYs9OjY0M9Y4O9Y8PD44O9S0uTI4M9w8Od434e+bm/RGc2A7zK8nquyI8tSxQ48PdhLaE0FyylF+0ai+aDbrD75euU6UnYqGdFw+CRpUDZi5/aP/hYxdtFpsbAhzwk1hTa1wWnYvQw6vdYrADP5g1LmOF21jhMpW5zBXXGwGvGvEaVgI+qnAaK+yGcouxvKm2OgqMIBqvWOsDpEzSONcI7juECyWAFFgEcEdwghgXbEbgX/FQ//rxmMAgDtN0ODjvthtssK5Oi1lX2t/pW5r16zWXPA5zrcdm02tbGmrCgTmztswOS27Xu2zGof7Oxjq32VDqtBmtZr3dogsuTg30t5uNlwd72902wmbUmnVlHqelq71FHJcc7Gmz6cthMJhDa2O9x2ExV1x26EGkmQd72o0VF+xmrYMwGDSlrY21AkMKN53thhG1BBgZyi6Yyi4QFZcsZSXmihKjwbQ77fQ9snSpmNOQpuYmqtSrFAX3KzLeeOdk6WXCZbW5cGyi85gNwBUigmVOU5nDXG4nKqwWDWHVWC1wfaNVQLMRWrtJZzdqoNkMl636UrO+ZGS4i0dBzAAIMUy0u2eCsNQxsNdxUQotnhmGYtWaP2qCWPHNC7G6b7azvdmgLaXJpWtRbqC3o6bKMTM5bKi4tDg9+l0UtTVWOwlDaGGa0JdNjPRFUEhAwasRuqHWXV1puxZlqOAcTK+pwTvU104Yynk6dE1gO6/4aqsc16LAPwgfVfN0Xw98qoG7gcPBPqIcbTfr25sarkJ3izNGzcXpseEoS/f3tOsqLgbnZyIrp8N3ARkN9HdVe121Xme919lQ5fJ5nb5KT32V01tTnVF0QQrErcqXKnJBcccr1VJFXpJif+pjOe9mfulwtzb5fG2+mvbG6iv1VU2+miZfdbOvCqbrq/c21lc21VU111U318JrVXNtDbTG+urGusrGOo+v1u2r8TTX1LRUezqaqhiaJvmvOwYXdmd+9M6+02PjQBRRrKeRKPyF8E+flDP4BBZWAjG1Xk9NpSsqsFHY6wJWvgvzk7ryr6rc5sYa2HtlfZ0tdHDOrL8M+8lq0lhMFQuzYxhrj+3rCFAt2Vjj9jqJod52i6FcYMJXedQhYr0M3hLHupi1e2NYMyHszgXM4CAE2lobgeWWArMGzaWJ0UHgN5Jc1GlL4Pr7mgXxeBQnIsR6anoZ2B1GBR/CghANwy1nzlYmb8lJVGSLWOeDq5QocuNSILDM3PRk/gcfeXr6ghR8aRlkFBeJsMvQBAQ9LPN8NIIiEEXjVxQFsQQf8cJVPhLlWZhiFMQoOH46OjYW0hBtr7x9Zv3mXcc+IoL0spjqC4FfwozMYnXyM3UNCBNLa0O9y2ICgK5GOODg5ub66ckRo/ZiW3P1QO8Vh0XXWOsGrE36ywO9bYtz40vzE7CfYOFrK+1XIbJngjUeW0O1a7ivw6wv4+gQ2HJ7a2O1174cQcsCJx6oM2CwVr2GBbsWMPoAmg3suqUBY700ayi/OOUfAhtfmB3Xll2Yn5oQVmrq7sJpaxSLGMXSGY5B+MkorGqxVqJgL9c1T299Jv8eWV6i/HCCvEgqz01Q5MSpCiRKYJWc9Ztznn35/aIThqqmcYgsKPabSPRrUTNh/gV8wcQEgQO3z2HPBn9Rfvlbivu2oX3qzFn7yztPJj+WvTpl9+9feb+jc5bGhxxIrB0MCwIpxI7PeervV4Bgz4mY+clxY/klAGdsqMdq1tR4HXPTfl35hfkZP3BFe2u902aiQwtGXSng23GlobOtcXZqBOwaaLq7owkugNzHhnthJQhjOUtjWrvS0lBVZV+Owi4DG+LAYvq72ghNWWdzY8eVpoHezmsR5DDpOlt8YKaBxVld6XlflQcoxW7WQYtQZORmrGNRzQ+qScSTfPyQCD8qLMbcAjr6oX3DE/kJKelSOZh5kUR2AGw8ToVTrxBiJSnz4lLS7klNf/x3B99K+7LoqPGjs1UluiaDrdtRNWx29pdoWz7+0nPwuOmdjPO//v2R+zZkSNenJazfn5SS9sL2k6W6ZpICbwcEDUBzENutVKChGNax8qubW0T0pTGyjvF1RGD9I/1ej91m0TfWexEVCC7MNtR4lhZn4OsT48O++moyMF9T7a7yOquhVTpAZvR2XampclVVOuprPOOjA6CRJ8eG6ms9DB0AZIeHejs6fNEobEoOb8MIGvMP1APlVjq9lQ5fY42ASKBKCE2ioHtCi/VV8JELOvc1ekOBWTxJ9nvfyPyocBSfZ7OxqjtK5BYWawMuhPjw6FToCCD+WN5qWeYqRbFUUQzhZZzqwN2KwjicRy1epYQ1UCcqCxJVxfGyAokc+B24Pk+qzJXIMqFJlVlSRU6iPC8xJePe1D1/2fdJZf0IGVrm8IGTqPRFTEXXJ1Yu4KxNTOrFog/EXy+OuelC4MQW2zdMLE6BQATTGhbUeO9jpPCnSKRyvG+A6yLwr6gUAUERTXZlF4rBTgR7AtDRPEQuy3w0KgjYBFgu5uuwW8b3LC8DbeJ+sCjisP/ET4Erniix4gmt/Ijr52vMmJVYA4lFpwzDLk8vRPW27nfVl7c+W7g2dZ9Uli6RZ0qwNFTHAZUrMKfHY/Txq0QJVl+UIM+HNZAkg1/NUP1a/Wba2bOX63tH5ikkgiVuLNhJV1p9rc31Lb7ayVFw2G0AdyRWCCgWpAnC9ScU43V8YrJShsmJHMVhryig7s4rNBmMxpxHFOJBYC0AESDGt0FkBK8AXJTnMCeI6iKyDO9wuNpLzF3hOwH0624GR/xg4FFs1wA9GyvFwn6So68uc5OTo7MzE/BpBC8qTtjgL8LKRcWeYUT2l9VOrvwagxErTjhcaIILW0iKI0ETk8y1zr6lc2W+tMKy/3795CMvHEt+RH3vxqwHNqvv25i3bkvhus1q+aP5jzx/6Ld/Orqv4NInJbWNHdNLVIRiaZpbEniQqOCQWbF6GJ92Tk/5K922jtZG8GAQxPZ2NAPz8kxwsLejr+cKogND/V0g5sjgXFdHy/BgL7gT2AFTY8Phpdnhvi4qMD/lH3DbzW3N9aODPbBU4yMDPR2tdGjJP9Q/Otg71NeNa/UFZmpqLLAwE5ibDsxNQeACzDs/PU4uQRAzFgrMT0yMwj6AWUGcMtjXMT7aJ7DhkcEe6AqRSwsz411tTXPTY3Dd19Xqq6+CWcGSICY8OjLAovDIUB8VXmxv8/V2t/EMybP/0O8KcClbOKZwcWVQ7LidofHxoHiWA6IsSLFLIW4hwI6MLQwMzfYPzg8MLYB0m18EFmNpCoiI50QnjBBYM8XiAjDsildKWMlYqqC22u0f7r0WpcyGMgDaZtKM9Hd67SaQCt1tPpBiPeB3qt2NNZUOi3HCPwhqrK25DnSnqexid2tDb5vPYzUM97Q5zVp/Xzd4rda6KuBQp8U40N3mIPSwKmCko8P9QLK1bsfkUL/LrJ8aGXCa9OPgE311QNkNdVXgNkBKWaGT4R6YCcDtthl9Ne4Gr8NF6Lpa6m3GinZfzZXGatAtsPxg++HQgttlpYLzEDoN9XeA7GmoqaRDi/xKYfQv/A1HbLeCgwqL1WmMSI34FBtXvLGwDCEgdEEsXRTFjPghYnFaDgd7DD4CYJhlhIDuOLGwEL/CMgliWkP8EQIumOPp+tpKsKBlgYZAjmdCgE5fR4sHnrPW09/VajNpeTrodVrqq9w1Hsekfxiwnp0aNZRfqgcwyi8uzo45CX1ofsplNYLNQdTX2ljT1lQH/y7NTkCgCOEGcBHEOxCAuC2mwPQEBDh0YM5u0ALWjVUe2B++hhrA+irPWmA4NmwltMMDXU6Lobm2srnWS2jLOprqQLz4qtz+fthgDYP9XTBzMrTgtJsXZyZgIvNTo1Uui1FzGfbczTrkl2GN4QGKxKlhAZs5jow58BvXC6gxyWCKwUEzw2KuYWJNLK5gxLNEFDuqx/kaPoQLR3mxQBS3FfXGUu2tTVNjI6C6fXXVTDhQV+UBdKo8dreDWJiZqPE4QfbCDWDUNR4XGQQiYig66HFZp8aG4DaWDdfWVAIPNNZVL81N1Vd7XDbz2HA/BCShpXlfY21gaQ7GAppuqMahVgSRV5rrHRZD55Wm8OKsx07AiJ3tLaCsodVWuRg6WFvjDi7NwdBOq2l6bKS7rcVlNXe2Ns1NjrltZhh6dHQA52SYUGOtt97j9NVWAtbwUZXLDpRzo3jvF/6uQCyHjR23x8JiPpZso8TyWTpWboCdQMxrXa+OpcU8HMUj6nrxNS6Pw4lyQcxsxDJ2ws1KmcUVkeC1Ijifh3DIA4ssxuJR8WdRUVw8hVbyIZwQKynCOpWJBdAQy4Fr4kUXJ1Y245tBe6x40dgGpcOBBavZsDCLk+M4RYdrf2EBxFFw7aQ4N3T9J1W4ZxzZQT+ipMHuTnSP0BXCNMiK8glzBYMrMaOsGJ3golYKP+k/aNe/sKFb2j/8a75YkdsNaG40/pZfKYiV0azwvRphYx7/B0Wg+Brd1Mn1WeEDeDp0a637j767MtD3v4u4cc/KnbHQ5AeP/FO18f9erJlb2j/fm3Bjf/xEVys3xIBgrkc9P3HPTb+hZ36E3X/ske/6v/aXPP+rv7L+92H9H/nt/512B+s7WN9pHP1/APNrQxxj9+p5AAAAAElFTkSuQmCC',
                            title: 'Platinum Credit',
                            nav: ''
                          },
                          {
                            append: we(() => [
                              m(s, {
                                variant: 'text',
                                icon: 'mdi-chevron-left',
                                onClick: a[0] || (a[0] = US((v) => (n.value = !n.value), ['stop']))
                              })
                            ]),
                            _: 1
                          }
                        ),
                        m(r),
                        m(
                          l,
                          { density: 'compact', nav: '' },
                          {
                            default: we(() => [
                              m(
                                Xe(bi),
                                { class: 'link', to: '/' },
                                {
                                  default: we(() => [
                                    m(o, { 'prepend-icon': 'mdi-home-city', title: 'Clients', value: 'home' })
                                  ]),
                                  _: 1
                                }
                              ),
                              m(
                                Xe(bi),
                                { class: 'link', to: '/devices' },
                                {
                                  default: we(() => [
                                    m(o, {
                                      'prepend-icon': 'mdi-devices',
                                      title: 'Devices',
                                      value: 'devices'
                                    })
                                  ]),
                                  _: 1
                                }
                              ),
                              m(
                                Xe(bi),
                                { class: 'link', to: '/lock-history' },
                                {
                                  default: we(() => [
                                    m(o, {
                                      'prepend-icon': 'mdi-lock',
                                      title: 'Lock History',
                                      value: 'lock-history'
                                    })
                                  ]),
                                  _: 1
                                }
                              ),
                              m(
                                Xe(bi),
                                { class: 'link', to: '/reminders' },
                                {
                                  default: we(() => [
                                    m(o, {
                                      'prepend-icon': 'mdi-receipt-text-clock-outline',
                                      title: 'Reminders',
                                      value: 'reminder'
                                    })
                                  ]),
                                  _: 1
                                }
                              ),
                              m(
                                Xe(bi),
                                { class: 'link', to: '/sent-sms' },
                                {
                                  default: we(() => [
                                    m(o, {
                                      'prepend-icon': 'mdi-email-fast-outline',
                                      title: 'Sent Reminders',
                                      value: 'sent-sms'
                                    })
                                  ]),
                                  _: 1
                                }
                              ),
                              m(
                                Xe(bi),
                                { class: 'link', to: '/queued-sms' },
                                {
                                  default: we(() => [
                                    m(o, {
                                      'prepend-icon': 'mdi-tray',
                                      title: 'Queued SMS',
                                      value: 'queuedsms'
                                    })
                                  ]),
                                  _: 1
                                }
                              ),
                              m(
                                Xe(bi),
                                { class: 'link', to: '/charts' },
                                {
                                  default: we(() => [
                                    m(o, {
                                      'prepend-icon': 'mdi-finance',
                                      title: 'Numbers',
                                      value: 'numbers'
                                    })
                                  ]),
                                  _: 1
                                }
                              )
                            ]),
                            _: 1
                          }
                        )
                      ]),
                      _: 1
                    },
                    8,
                    ['modelValue', 'rail']
                  ),
                  m(
                    d,
                    { style: { height: '100vh' } },
                    {
                      default: we(() => [
                        m(aE),
                        m(u, { fluid: !0, class: 'container' }, { default: we(() => [m(Xe(g1))]), _: 1 })
                      ]),
                      _: 1
                    }
                  )
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        )
      }
    }
  })
const oE = Oi(sE, [['__scopeId', 'data-v-7e5170d5']]),
  rE = {
    test: 'https://lgfdeposit.spectrumcreditltd.com/easyphone-test',
    keDev: 'https://lgfdeposit.spectrumcreditltd.com/easyphone-test',
    dev: 'http://localhost:3030',
    ugDev: 'https://lgfdeposit.spectrumcreditltd.com/easyphone-ug-dev'
  },
  lE = rE.keDev,
  cE = localStorage.getItem('mambuUser'),
  uE = localStorage.getItem('mambuUserToken'),
  xo = async (e, t = 'GET', n = {}) => {
    const i = {
      method: t,
      mode: 'cors',
      cache: 'no-cache',
      credentials: 'same-origin',
      headers: {
        'Content-Type': 'application/json',
        mambuUser: JSON.stringify(cE),
        Authorization: `Bearer ${uE}`
      },
      redirect: 'follow',
      referrerPolicy: 'no-referrer'
    }
    return t === 'POST' && (i.body = JSON.stringify(n)), (await fetch(lE + e, i)).json()
  },
  zd = async (e = {}) => {
    const t = { $limit: 15, $skip: 0, ...e }
    return xo('/client?' + new URLSearchParams({ ...t })).then((n) => n)
  },
  dE = async () => xo('/device-lock-history').then((e) => e),
  ar = async (e = {}) => {
    const t = { $limit: 15, $skip: 0, ...e }
    return xo('/device?' + new URLSearchParams({ ...t })).then((n) => n)
  },
  fE = async (e = {}) => {
    const t = { $limit: 20, $skip: 0, ...e }
    return xo('/sms-queue?' + new URLSearchParams({ ...t })).then((n) => n)
  },
  hE = async (e = {}) => {
    const t = { $limit: 20, $skip: 0 }
    return console.log(e), xo('/sent-sms?' + new URLSearchParams({ ...t })).then((n) => n)
  },
  vE = async () => xo('/reminder').then((e) => e),
  Wt = (e) => (e ? new Date(e).toLocaleString() : 'n/a'),
  gE = { class: 'text-h5 mb-6' },
  mE = { class: 'mb-4 text-medium-emphasis text-body-2' },
  pE = z('br', null, null, -1),
  yE = { class: 'text-end' },
  wo = hn({
    __name: 'EmptyState',
    props: { message: {} },
    setup(e) {
      return (t, n) => {
        const i = Se('v-icon'),
          a = Se('v-divider'),
          s = Se('v-btn'),
          o = Se('v-sheet')
        return (
          Re(),
          Ct(
            o,
            {
              elevation: '12',
              'max-width': '600',
              rounded: 'lg',
              width: '100%',
              class: 'pa-4 text-center mx-auto'
            },
            {
              default: we(() => [
                m(i, { class: 'mb-5', color: 'info', icon: 'mdi-information-outline', size: '112' }),
                z('h2', gE, 'No ' + ze(t.message) + ' Recorded Yet', 1),
                z('p', mE, [
                  nt(' New ' + ze(t.message) + ' will appear here ', 1),
                  pE,
                  nt(' Otherwise, navigate to other pages to refresh ')
                ]),
                m(a, { class: 'mb-4' }),
                z('div', yE, [
                  m(
                    s,
                    { class: 'text-none', color: 'success', rounded: '', variant: 'flat' },
                    {
                      default: we(() => [
                        m(
                          Xe(bi),
                          { class: 'link', to: '/devices' },
                          { default: we(() => [nt(' Take me to devices ')]), _: 1 }
                        )
                      ]),
                      _: 1
                    }
                  )
                ])
              ]),
              _: 1
            }
          )
        )
      }
    }
  }),
  bE = z('h2', { class: 'text-h5 mb-6' }, 'You are not authorized to view this page', -1),
  _E = { class: 'mb-4 text-medium-emphasis text-body-2' },
  xE = { class: 'error' },
  wE = z('br', null, null, -1),
  SE = { class: 'text-end' },
  eu = hn({
    __name: 'ErrorAuth',
    props: { message: {} },
    setup(e) {
      return (t, n) => {
        const i = Se('v-icon'),
          a = Se('v-divider'),
          s = Se('v-btn'),
          o = Se('v-sheet')
        return (
          Re(),
          Ct(
            o,
            {
              elevation: '12',
              'max-width': '600',
              rounded: 'lg',
              width: '100%',
              class: 'pa-4 text-center mx-auto'
            },
            {
              default: we(() => [
                m(i, { class: 'mb-5', color: 'red', icon: 'mdi-alert-circle-outline', size: '112' }),
                bE,
                z('p', _E, [
                  nt(' Please ask your admin to give you '),
                  z('span', xE, ze(t.message), 1),
                  nt(' permission '),
                  wE,
                  nt(' Otherwise, navigate to other section ')
                ]),
                m(a, { class: 'mb-4' }),
                z('div', SE, [
                  m(
                    s,
                    { class: 'text-none', color: 'success', rounded: '', variant: 'flat' },
                    {
                      default: we(() => [
                        m(
                          Xe(bi),
                          { class: 'link', to: '/' },
                          { default: we(() => [nt(' Take me home ')]), _: 1 }
                        )
                      ]),
                      _: 1
                    }
                  )
                ])
              ]),
              _: 1
            }
          )
        )
      }
    }
  })
const kE = z('span', { class: 'text-h5' }, 'Filter Options', -1),
  CE = hn({
    __name: 'FilterDialog',
    props: { message: {} },
    setup(e) {
      const t = te({ idNumber: '', phoneNumber: '', status: '' }),
        n = te(!1)
      return (i, a) => {
        const s = Se('v-btn'),
          o = Se('v-card-title'),
          r = Se('v-text-field'),
          l = Se('v-col'),
          c = Se('v-autocomplete'),
          u = Se('v-row'),
          d = Se('v-container'),
          f = Se('v-card-text'),
          h = Se('v-spacer'),
          v = Se('v-card-actions'),
          g = Se('v-card'),
          p = Se('v-dialog')
        return (
          Re(),
          Ct(
            p,
            {
              modelValue: n.value,
              'onUpdate:modelValue': a[5] || (a[5] = (y) => (n.value = y)),
              theme: 'dark',
              width: '600'
            },
            {
              activator: we(({ props: y }) => [
                m(
                  s,
                  xe({ color: 'blue' }, y, { class: 'filter', 'prepend-icon': 'filter' }),
                  { default: we(() => [nt(' Filter ')]), _: 2 },
                  1040
                )
              ]),
              default: we(() => [
                m(g, null, {
                  default: we(() => [
                    m(o, null, { default: we(() => [kE]), _: 1 }),
                    m(f, null, {
                      default: we(() => [
                        m(d, null, {
                          default: we(() => [
                            m(u, null, {
                              default: we(() => [
                                m(
                                  l,
                                  { cols: '12', sm: '6', md: '6' },
                                  {
                                    default: we(() => [
                                      m(
                                        r,
                                        {
                                          modelValue: t.value.idNumber,
                                          'onUpdate:modelValue':
                                            a[0] || (a[0] = (y) => (t.value.idNumber = y)),
                                          label: 'ID Number'
                                        },
                                        null,
                                        8,
                                        ['modelValue']
                                      )
                                    ]),
                                    _: 1
                                  }
                                ),
                                m(
                                  l,
                                  { cols: '12', sm: '6', md: '6' },
                                  {
                                    default: we(() => [
                                      m(
                                        r,
                                        {
                                          label: 'Phone Number',
                                          hint: 'Example 254715775179',
                                          modelValue: t.value.phoneNumber,
                                          'onUpdate:modelValue':
                                            a[1] || (a[1] = (y) => (t.value.phoneNumber = y))
                                        },
                                        null,
                                        8,
                                        ['modelValue']
                                      )
                                    ]),
                                    _: 1
                                  }
                                ),
                                m(
                                  l,
                                  { cols: '12', sm: '6' },
                                  {
                                    default: we(() => [
                                      m(
                                        c,
                                        {
                                          items: [
                                            { label: 'ACTIVE', value: 1 },
                                            { label: 'INACTIVE', value: 0 }
                                          ],
                                          'item-title': 'label',
                                          'item-value': 'value',
                                          label: 'Status',
                                          modelValue: t.value.status,
                                          'onUpdate:modelValue': a[2] || (a[2] = (y) => (t.value.status = y))
                                        },
                                        null,
                                        8,
                                        ['modelValue']
                                      )
                                    ]),
                                    _: 1
                                  }
                                )
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    m(v, null, {
                      default: we(() => [
                        m(h),
                        m(
                          s,
                          {
                            color: 'blue-darken-1',
                            variant: 'text',
                            onClick: a[3] || (a[3] = (y) => (n.value = !1))
                          },
                          { default: we(() => [nt(' Close ')]), _: 1 }
                        ),
                        m(
                          s,
                          {
                            color: 'blue-darken-1',
                            variant: 'text',
                            onClick: a[4] || (a[4] = (y) => (i.$emit('clicked', t.value), (n.value = !1)))
                          },
                          { default: we(() => [nt(' Filter ')]), _: 1 }
                        )
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            },
            8,
            ['modelValue']
          )
        )
      }
    }
  })
/*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com */ var hl = function (t) {
    return String.fromCharCode(t)
  },
  pa = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
function Hg(e) {
  for (var t = '', n = 0, i = 0, a = 0, s = 0, o = 0, r = 0, l = 0, c = 0; c < e.length; )
    (n = e.charCodeAt(c++)),
      (s = n >> 2),
      (i = e.charCodeAt(c++)),
      (o = ((n & 3) << 4) | (i >> 4)),
      (a = e.charCodeAt(c++)),
      (r = ((i & 15) << 2) | (a >> 6)),
      (l = a & 63),
      isNaN(i) ? (r = l = 64) : isNaN(a) && (l = 64),
      (t += pa.charAt(s) + pa.charAt(o) + pa.charAt(r) + pa.charAt(l))
  return t
}
function Wg(e) {
  var t = '',
    n = 0,
    i = 0,
    a = 0,
    s = 0,
    o = 0,
    r = 0,
    l = 0
  e = e.replace(/[^\w\+\/\=]/g, '')
  for (var c = 0; c < e.length; )
    (s = pa.indexOf(e.charAt(c++))),
      (o = pa.indexOf(e.charAt(c++))),
      (n = (s << 2) | (o >> 4)),
      (t += String.fromCharCode(n)),
      (r = pa.indexOf(e.charAt(c++))),
      (i = ((o & 15) << 4) | (r >> 2)),
      r !== 64 && (t += String.fromCharCode(i)),
      (l = pa.indexOf(e.charAt(c++))),
      (a = ((r & 3) << 6) | l),
      l !== 64 && (t += String.fromCharCode(a))
  return t
}
var Pt = (function () {
    return (
      typeof Buffer < 'u' && typeof process < 'u' && typeof process.versions < 'u' && !!process.versions.node
    )
  })(),
  ks = (function () {
    if (typeof Buffer < 'u') {
      var e = !Buffer.from
      if (!e)
        try {
          Buffer.from('foo', 'utf8')
        } catch {
          e = !0
        }
      return e
        ? function (t, n) {
            return n ? new Buffer(t, n) : new Buffer(t)
          }
        : Buffer.from.bind(Buffer)
    }
    return function () {}
  })()
function no(e) {
  return Pt
    ? Buffer.alloc
      ? Buffer.alloc(e)
      : new Buffer(e)
    : typeof Uint8Array < 'u'
    ? new Uint8Array(e)
    : new Array(e)
}
function jg(e) {
  return Pt
    ? Buffer.allocUnsafe
      ? Buffer.allocUnsafe(e)
      : new Buffer(e)
    : typeof Uint8Array < 'u'
    ? new Uint8Array(e)
    : new Array(e)
}
var Rs = function (t) {
  return Pt
    ? ks(t, 'binary')
    : t.split('').map(function (n) {
        return n.charCodeAt(0) & 255
      })
}
function tu(e) {
  if (typeof ArrayBuffer > 'u') return Rs(e)
  for (var t = new ArrayBuffer(e.length), n = new Uint8Array(t), i = 0; i != e.length; ++i)
    n[i] = e.charCodeAt(i) & 255
  return t
}
function ME(e) {
  if (Array.isArray(e))
    return e
      .map(function (i) {
        return String.fromCharCode(i)
      })
      .join('')
  for (var t = [], n = 0; n < e.length; ++n) t[n] = String.fromCharCode(e[n])
  return t.join('')
}
function AE(e) {
  if (typeof Uint8Array > 'u') throw new Error('Unsupported')
  return new Uint8Array(e)
}
var Bs = Pt
  ? function (e) {
      return Buffer.concat(
        e.map(function (t) {
          return Buffer.isBuffer(t) ? t : ks(t)
        })
      )
    }
  : function (e) {
      if (typeof Uint8Array < 'u') {
        var t = 0,
          n = 0
        for (t = 0; t < e.length; ++t) n += e[t].length
        var i = new Uint8Array(n),
          a = 0
        for (t = 0, n = 0; t < e.length; n += a, ++t)
          if (((a = e[t].length), e[t] instanceof Uint8Array)) i.set(e[t], n)
          else {
            if (typeof e[t] == 'string') throw 'wtf'
            i.set(new Uint8Array(e[t]), n)
          }
        return i
      }
      return [].concat.apply(
        [],
        e.map(function (s) {
          return Array.isArray(s) ? s : [].slice.call(s)
        })
      )
    }
function PE(e) {
  for (var t = [], n = 0, i = e.length + 250, a = no(e.length + 255), s = 0; s < e.length; ++s) {
    var o = e.charCodeAt(s)
    if (o < 128) a[n++] = o
    else if (o < 2048) (a[n++] = 192 | ((o >> 6) & 31)), (a[n++] = 128 | (o & 63))
    else if (o >= 55296 && o < 57344) {
      o = (o & 1023) + 64
      var r = e.charCodeAt(++s) & 1023
      ;(a[n++] = 240 | ((o >> 8) & 7)),
        (a[n++] = 128 | ((o >> 2) & 63)),
        (a[n++] = 128 | ((r >> 6) & 15) | ((o & 3) << 4)),
        (a[n++] = 128 | (r & 63))
    } else (a[n++] = 224 | ((o >> 12) & 15)), (a[n++] = 128 | ((o >> 6) & 63)), (a[n++] = 128 | (o & 63))
    n > i && (t.push(a.slice(0, n)), (n = 0), (a = no(65535)), (i = 65530))
  }
  return t.push(a.slice(0, n)), Bs(t)
}
var sr = /\u0000/g,
  vl = /[\u0001-\u0006]/g
function Ys(e) {
  for (var t = '', n = e.length - 1; n >= 0; ) t += e.charAt(n--)
  return t
}
function ai(e, t) {
  var n = '' + e
  return n.length >= t ? n : Cn('0', t - n.length) + n
}
function bh(e, t) {
  var n = '' + e
  return n.length >= t ? n : Cn(' ', t - n.length) + n
}
function fc(e, t) {
  var n = '' + e
  return n.length >= t ? n : n + Cn(' ', t - n.length)
}
function TE(e, t) {
  var n = '' + Math.round(e)
  return n.length >= t ? n : Cn('0', t - n.length) + n
}
function VE(e, t) {
  var n = '' + e
  return n.length >= t ? n : Cn('0', t - n.length) + n
}
var Ug = Math.pow(2, 32)
function Ls(e, t) {
  if (e > Ug || e < -Ug) return TE(e, t)
  var n = Math.round(e)
  return VE(n, t)
}
function hc(e, t) {
  return (
    (t = t || 0),
    e.length >= 7 + t &&
      (e.charCodeAt(t) | 32) === 103 &&
      (e.charCodeAt(t + 1) | 32) === 101 &&
      (e.charCodeAt(t + 2) | 32) === 110 &&
      (e.charCodeAt(t + 3) | 32) === 101 &&
      (e.charCodeAt(t + 4) | 32) === 114 &&
      (e.charCodeAt(t + 5) | 32) === 97 &&
      (e.charCodeAt(t + 6) | 32) === 108
  )
}
var Yg = [
    ['Sun', 'Sunday'],
    ['Mon', 'Monday'],
    ['Tue', 'Tuesday'],
    ['Wed', 'Wednesday'],
    ['Thu', 'Thursday'],
    ['Fri', 'Friday'],
    ['Sat', 'Saturday']
  ],
  Vu = [
    ['J', 'Jan', 'January'],
    ['F', 'Feb', 'February'],
    ['M', 'Mar', 'March'],
    ['A', 'Apr', 'April'],
    ['M', 'May', 'May'],
    ['J', 'Jun', 'June'],
    ['J', 'Jul', 'July'],
    ['A', 'Aug', 'August'],
    ['S', 'Sep', 'September'],
    ['O', 'Oct', 'October'],
    ['N', 'Nov', 'November'],
    ['D', 'Dec', 'December']
  ]
function EE(e) {
  return (
    e || (e = {}),
    (e[0] = 'General'),
    (e[1] = '0'),
    (e[2] = '0.00'),
    (e[3] = '#,##0'),
    (e[4] = '#,##0.00'),
    (e[9] = '0%'),
    (e[10] = '0.00%'),
    (e[11] = '0.00E+00'),
    (e[12] = '# ?/?'),
    (e[13] = '# ??/??'),
    (e[14] = 'm/d/yy'),
    (e[15] = 'd-mmm-yy'),
    (e[16] = 'd-mmm'),
    (e[17] = 'mmm-yy'),
    (e[18] = 'h:mm AM/PM'),
    (e[19] = 'h:mm:ss AM/PM'),
    (e[20] = 'h:mm'),
    (e[21] = 'h:mm:ss'),
    (e[22] = 'm/d/yy h:mm'),
    (e[37] = '#,##0 ;(#,##0)'),
    (e[38] = '#,##0 ;[Red](#,##0)'),
    (e[39] = '#,##0.00;(#,##0.00)'),
    (e[40] = '#,##0.00;[Red](#,##0.00)'),
    (e[45] = 'mm:ss'),
    (e[46] = '[h]:mm:ss'),
    (e[47] = 'mmss.0'),
    (e[48] = '##0.0E+0'),
    (e[49] = '@'),
    (e[56] = '"上午/下午 "hh"時"mm"分"ss"秒 "'),
    e
  )
}
var ci = {
    0: 'General',
    1: '0',
    2: '0.00',
    3: '#,##0',
    4: '#,##0.00',
    9: '0%',
    10: '0.00%',
    11: '0.00E+00',
    12: '# ?/?',
    13: '# ??/??',
    14: 'm/d/yy',
    15: 'd-mmm-yy',
    16: 'd-mmm',
    17: 'mmm-yy',
    18: 'h:mm AM/PM',
    19: 'h:mm:ss AM/PM',
    20: 'h:mm',
    21: 'h:mm:ss',
    22: 'm/d/yy h:mm',
    37: '#,##0 ;(#,##0)',
    38: '#,##0 ;[Red](#,##0)',
    39: '#,##0.00;(#,##0.00)',
    40: '#,##0.00;[Red](#,##0.00)',
    45: 'mm:ss',
    46: '[h]:mm:ss',
    47: 'mmss.0',
    48: '##0.0E+0',
    49: '@',
    56: '"上午/下午 "hh"時"mm"分"ss"秒 "'
  },
  Gg = {
    5: 37,
    6: 38,
    7: 39,
    8: 40,
    23: 0,
    24: 0,
    25: 0,
    26: 0,
    27: 14,
    28: 14,
    29: 14,
    30: 14,
    31: 14,
    50: 14,
    51: 14,
    52: 14,
    53: 14,
    54: 14,
    55: 14,
    56: 14,
    57: 14,
    58: 14,
    59: 1,
    60: 2,
    61: 3,
    62: 4,
    67: 9,
    68: 10,
    69: 12,
    70: 13,
    71: 14,
    72: 14,
    73: 15,
    74: 16,
    75: 17,
    76: 20,
    77: 21,
    78: 22,
    79: 45,
    80: 46,
    81: 47,
    82: 0
  },
  LE = {
    5: '"$"#,##0_);\\("$"#,##0\\)',
    63: '"$"#,##0_);\\("$"#,##0\\)',
    6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
    64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
    7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
    65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
    8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
    42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
    43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
    44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
  }
function vc(e, t, n) {
  for (
    var i = e < 0 ? -1 : 1, a = e * i, s = 0, o = 1, r = 0, l = 1, c = 0, u = 0, d = Math.floor(a);
    c < t && ((d = Math.floor(a)), (r = d * o + s), (u = d * c + l), !(a - d < 5e-8));

  )
    (a = 1 / (a - d)), (s = o), (o = r), (l = c), (c = u)
  if ((u > t && (c > t ? ((u = l), (r = s)) : ((u = c), (r = o))), !n)) return [0, i * r, u]
  var f = Math.floor((i * r) / u)
  return [f, i * r - f * u, u]
}
function gl(e, t, n) {
  if (e > 2958465 || e < 0) return null
  var i = e | 0,
    a = Math.floor(86400 * (e - i)),
    s = 0,
    o = [],
    r = { D: i, T: a, u: 86400 * (e - i) - a, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 }
  if (
    (Math.abs(r.u) < 1e-6 && (r.u = 0),
    t && t.date1904 && (i += 1462),
    r.u > 0.9999 && ((r.u = 0), ++a == 86400 && ((r.T = a = 0), ++i, ++r.D)),
    i === 60)
  )
    (o = n ? [1317, 10, 29] : [1900, 2, 29]), (s = 3)
  else if (i === 0) (o = n ? [1317, 8, 29] : [1900, 1, 0]), (s = 6)
  else {
    i > 60 && --i
    var l = new Date(1900, 0, 1)
    l.setDate(l.getDate() + i - 1),
      (o = [l.getFullYear(), l.getMonth() + 1, l.getDate()]),
      (s = l.getDay()),
      i < 60 && (s = (s + 6) % 7),
      n && (s = NE(l, o))
  }
  return (
    (r.y = o[0]),
    (r.m = o[1]),
    (r.d = o[2]),
    (r.S = a % 60),
    (a = Math.floor(a / 60)),
    (r.M = a % 60),
    (a = Math.floor(a / 60)),
    (r.H = a),
    (r.q = s),
    r
  )
}
var m1 = new Date(1899, 11, 31, 0, 0, 0),
  OE = m1.getTime(),
  IE = new Date(1900, 2, 1, 0, 0, 0)
function p1(e, t) {
  var n = e.getTime()
  return (
    t ? (n -= 1461 * 24 * 60 * 60 * 1e3) : e >= IE && (n += 24 * 60 * 60 * 1e3),
    (n - (OE + (e.getTimezoneOffset() - m1.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3)
  )
}
function _h(e) {
  return e.indexOf('.') == -1 ? e : e.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, '$1')
}
function DE(e) {
  return e.indexOf('E') == -1
    ? e
    : e.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, '$1E').replace(/(E[+-])(\d)$/, '$10$2')
}
function FE(e) {
  var t = e < 0 ? 12 : 11,
    n = _h(e.toFixed(12))
  return n.length <= t || ((n = e.toPrecision(10)), n.length <= t) ? n : e.toExponential(5)
}
function RE(e) {
  var t = _h(e.toFixed(11))
  return t.length > (e < 0 ? 12 : 11) || t === '0' || t === '-0' ? e.toPrecision(6) : t
}
function BE(e) {
  var t = Math.floor(Math.log(Math.abs(e)) * Math.LOG10E),
    n
  return (
    t >= -4 && t <= -1
      ? (n = e.toPrecision(10 + t))
      : Math.abs(t) <= 9
      ? (n = FE(e))
      : t === 10
      ? (n = e.toFixed(10).substr(0, 12))
      : (n = RE(e)),
    _h(DE(n.toUpperCase()))
  )
}
function Hd(e, t) {
  switch (typeof e) {
    case 'string':
      return e
    case 'boolean':
      return e ? 'TRUE' : 'FALSE'
    case 'number':
      return (e | 0) === e ? e.toString(10) : BE(e)
    case 'undefined':
      return ''
    case 'object':
      if (e == null) return ''
      if (e instanceof Date) return Pr(14, p1(e, t && t.date1904), t)
  }
  throw new Error('unsupported value in General format: ' + e)
}
function NE(e, t) {
  t[0] -= 581
  var n = e.getDay()
  return e < 60 && (n = (n + 6) % 7), n
}
function $E(e, t, n, i) {
  var a = '',
    s = 0,
    o = 0,
    r = n.y,
    l,
    c = 0
  switch (e) {
    case 98:
      r = n.y + 543
    case 121:
      switch (t.length) {
        case 1:
        case 2:
          ;(l = r % 100), (c = 2)
          break
        default:
          ;(l = r % 1e4), (c = 4)
          break
      }
      break
    case 109:
      switch (t.length) {
        case 1:
        case 2:
          ;(l = n.m), (c = t.length)
          break
        case 3:
          return Vu[n.m - 1][1]
        case 5:
          return Vu[n.m - 1][0]
        default:
          return Vu[n.m - 1][2]
      }
      break
    case 100:
      switch (t.length) {
        case 1:
        case 2:
          ;(l = n.d), (c = t.length)
          break
        case 3:
          return Yg[n.q][0]
        default:
          return Yg[n.q][1]
      }
      break
    case 104:
      switch (t.length) {
        case 1:
        case 2:
          ;(l = 1 + ((n.H + 11) % 12)), (c = t.length)
          break
        default:
          throw 'bad hour format: ' + t
      }
      break
    case 72:
      switch (t.length) {
        case 1:
        case 2:
          ;(l = n.H), (c = t.length)
          break
        default:
          throw 'bad hour format: ' + t
      }
      break
    case 77:
      switch (t.length) {
        case 1:
        case 2:
          ;(l = n.M), (c = t.length)
          break
        default:
          throw 'bad minute format: ' + t
      }
      break
    case 115:
      if (t != 's' && t != 'ss' && t != '.0' && t != '.00' && t != '.000') throw 'bad second format: ' + t
      return n.u === 0 && (t == 's' || t == 'ss')
        ? ai(n.S, t.length)
        : (i >= 2 ? (o = i === 3 ? 1e3 : 100) : (o = i === 1 ? 10 : 1),
          (s = Math.round(o * (n.S + n.u))),
          s >= 60 * o && (s = 0),
          t === 's'
            ? s === 0
              ? '0'
              : '' + s / o
            : ((a = ai(s, 2 + i)), t === 'ss' ? a.substr(0, 2) : '.' + a.substr(2, t.length - 1)))
    case 90:
      switch (t) {
        case '[h]':
        case '[hh]':
          l = n.D * 24 + n.H
          break
        case '[m]':
        case '[mm]':
          l = (n.D * 24 + n.H) * 60 + n.M
          break
        case '[s]':
        case '[ss]':
          l = ((n.D * 24 + n.H) * 60 + n.M) * 60 + Math.round(n.S + n.u)
          break
        default:
          throw 'bad abstime format: ' + t
      }
      c = t.length === 3 ? 1 : 2
      break
    case 101:
      ;(l = r), (c = 1)
      break
  }
  var u = c > 0 ? ai(l, c) : ''
  return u
}
function ya(e) {
  var t = 3
  if (e.length <= t) return e
  for (var n = e.length % t, i = e.substr(0, n); n != e.length; n += t)
    i += (i.length > 0 ? ',' : '') + e.substr(n, t)
  return i
}
var y1 = /%/g
function zE(e, t, n) {
  var i = t.replace(y1, ''),
    a = t.length - i.length
  return Ki(e, i, n * Math.pow(10, 2 * a)) + Cn('%', a)
}
function HE(e, t, n) {
  for (var i = t.length - 1; t.charCodeAt(i - 1) === 44; ) --i
  return Ki(e, t.substr(0, i), n / Math.pow(10, 3 * (t.length - i)))
}
function b1(e, t) {
  var n,
    i = e.indexOf('E') - e.indexOf('.') - 1
  if (e.match(/^#+0.0E\+0$/)) {
    if (t == 0) return '0.0E+0'
    if (t < 0) return '-' + b1(e, -t)
    var a = e.indexOf('.')
    a === -1 && (a = e.indexOf('E'))
    var s = Math.floor(Math.log(t) * Math.LOG10E) % a
    if (
      (s < 0 && (s += a),
      (n = (t / Math.pow(10, s)).toPrecision(i + 1 + ((a + s) % a))),
      n.indexOf('e') === -1)
    ) {
      var o = Math.floor(Math.log(t) * Math.LOG10E)
      for (
        n.indexOf('.') === -1
          ? (n = n.charAt(0) + '.' + n.substr(1) + 'E+' + (o - n.length + s))
          : (n += 'E+' + (o - s));
        n.substr(0, 2) === '0.';

      )
        (n = n.charAt(0) + n.substr(2, a) + '.' + n.substr(2 + a)),
          (n = n.replace(/^0+([1-9])/, '$1').replace(/^0+\./, '0.'))
      n = n.replace(/\+-/, '-')
    }
    n = n.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function (r, l, c, u) {
      return l + c + u.substr(0, (a + s) % a) + '.' + u.substr(s) + 'E'
    })
  } else n = t.toExponential(i)
  return (
    e.match(/E\+00$/) &&
      n.match(/e[+-]\d$/) &&
      (n = n.substr(0, n.length - 1) + '0' + n.charAt(n.length - 1)),
    e.match(/E\-/) && n.match(/e\+/) && (n = n.replace(/e\+/, 'e')),
    n.replace('e', 'E')
  )
}
var _1 = /# (\?+)( ?)\/( ?)(\d+)/
function WE(e, t, n) {
  var i = parseInt(e[4], 10),
    a = Math.round(t * i),
    s = Math.floor(a / i),
    o = a - s * i,
    r = i
  return (
    n +
    (s === 0 ? '' : '' + s) +
    ' ' +
    (o === 0
      ? Cn(' ', e[1].length + 1 + e[4].length)
      : bh(o, e[1].length) + e[2] + '/' + e[3] + ai(r, e[4].length))
  )
}
function jE(e, t, n) {
  return n + (t === 0 ? '' : '' + t) + Cn(' ', e[1].length + 2 + e[4].length)
}
var x1 = /^#*0*\.([0#]+)/,
  w1 = /\).*[0#]/,
  S1 = /\(###\) ###\\?-####/
function pn(e) {
  for (var t = '', n, i = 0; i != e.length; ++i)
    switch ((n = e.charCodeAt(i))) {
      case 35:
        break
      case 63:
        t += ' '
        break
      case 48:
        t += '0'
        break
      default:
        t += String.fromCharCode(n)
    }
  return t
}
function Xg(e, t) {
  var n = Math.pow(10, t)
  return '' + Math.round(e * n) / n
}
function Kg(e, t) {
  var n = e - Math.floor(e),
    i = Math.pow(10, t)
  return t < ('' + Math.round(n * i)).length ? 0 : Math.round(n * i)
}
function UE(e, t) {
  return t < ('' + Math.round((e - Math.floor(e)) * Math.pow(10, t))).length ? 1 : 0
}
function YE(e) {
  return e < 2147483647 && e > -2147483648 ? '' + (e >= 0 ? e | 0 : (e - 1) | 0) : '' + Math.floor(e)
}
function Hn(e, t, n) {
  if (e.charCodeAt(0) === 40 && !t.match(w1)) {
    var i = t.replace(/\( */, '').replace(/ \)/, '').replace(/\)/, '')
    return n >= 0 ? Hn('n', i, n) : '(' + Hn('n', i, -n) + ')'
  }
  if (t.charCodeAt(t.length - 1) === 44) return HE(e, t, n)
  if (t.indexOf('%') !== -1) return zE(e, t, n)
  if (t.indexOf('E') !== -1) return b1(t, n)
  if (t.charCodeAt(0) === 36) return '$' + Hn(e, t.substr(t.charAt(1) == ' ' ? 2 : 1), n)
  var a,
    s,
    o,
    r,
    l = Math.abs(n),
    c = n < 0 ? '-' : ''
  if (t.match(/^00+$/)) return c + Ls(l, t.length)
  if (t.match(/^[#?]+$/))
    return (
      (a = Ls(n, 0)),
      a === '0' && (a = ''),
      a.length > t.length ? a : pn(t.substr(0, t.length - a.length)) + a
    )
  if ((s = t.match(_1))) return WE(s, l, c)
  if (t.match(/^#+0+$/)) return c + Ls(l, t.length - t.indexOf('0'))
  if ((s = t.match(x1)))
    return (
      (a = Xg(n, s[1].length)
        .replace(/^([^\.]+)$/, '$1.' + pn(s[1]))
        .replace(/\.$/, '.' + pn(s[1]))
        .replace(/\.(\d*)$/, function (v, g) {
          return '.' + g + Cn('0', pn(s[1]).length - g.length)
        })),
      t.indexOf('0.') !== -1 ? a : a.replace(/^0\./, '.')
    )
  if (((t = t.replace(/^#+([0.])/, '$1')), (s = t.match(/^(0*)\.(#*)$/))))
    return (
      c +
      Xg(l, s[2].length)
        .replace(/\.(\d*[1-9])0*$/, '.$1')
        .replace(/^(-?\d*)$/, '$1.')
        .replace(/^0\./, s[1].length ? '0.' : '.')
    )
  if ((s = t.match(/^#{1,3},##0(\.?)$/))) return c + ya(Ls(l, 0))
  if ((s = t.match(/^#,##0\.([#0]*0)$/)))
    return n < 0
      ? '-' + Hn(e, t, -n)
      : ya('' + (Math.floor(n) + UE(n, s[1].length))) + '.' + ai(Kg(n, s[1].length), s[1].length)
  if ((s = t.match(/^#,#*,#0/))) return Hn(e, t.replace(/^#,#*,/, ''), n)
  if ((s = t.match(/^([0#]+)(\\?-([0#]+))+$/)))
    return (
      (a = Ys(Hn(e, t.replace(/[\\-]/g, ''), n))),
      (o = 0),
      Ys(
        Ys(t.replace(/\\/g, '')).replace(/[0#]/g, function (v) {
          return o < a.length ? a.charAt(o++) : v === '0' ? '0' : ''
        })
      )
    )
  if (t.match(S1))
    return (a = Hn(e, '##########', n)), '(' + a.substr(0, 3) + ') ' + a.substr(3, 3) + '-' + a.substr(6)
  var u = ''
  if ((s = t.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)))
    return (
      (o = Math.min(s[4].length, 7)),
      (r = vc(l, Math.pow(10, o) - 1, !1)),
      (a = '' + c),
      (u = Ki('n', s[1], r[1])),
      u.charAt(u.length - 1) == ' ' && (u = u.substr(0, u.length - 1) + '0'),
      (a += u + s[2] + '/' + s[3]),
      (u = fc(r[2], o)),
      u.length < s[4].length && (u = pn(s[4].substr(s[4].length - u.length)) + u),
      (a += u),
      a
    )
  if ((s = t.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)))
    return (
      (o = Math.min(Math.max(s[1].length, s[4].length), 7)),
      (r = vc(l, Math.pow(10, o) - 1, !0)),
      c +
        (r[0] || (r[1] ? '' : '0')) +
        ' ' +
        (r[1]
          ? bh(r[1], o) + s[2] + '/' + s[3] + fc(r[2], o)
          : Cn(' ', 2 * o + 1 + s[2].length + s[3].length))
    )
  if ((s = t.match(/^[#0?]+$/)))
    return (a = Ls(n, 0)), t.length <= a.length ? a : pn(t.substr(0, t.length - a.length)) + a
  if ((s = t.match(/^([#0?]+)\.([#0]+)$/))) {
    ;(a = '' + n.toFixed(Math.min(s[2].length, 10)).replace(/([^0])0+$/, '$1')), (o = a.indexOf('.'))
    var d = t.indexOf('.') - o,
      f = t.length - a.length - d
    return pn(t.substr(0, d) + a + t.substr(t.length - f))
  }
  if ((s = t.match(/^00,000\.([#0]*0)$/)))
    return (
      (o = Kg(n, s[1].length)),
      n < 0
        ? '-' + Hn(e, t, -n)
        : ya(YE(n))
            .replace(/^\d,\d{3}$/, '0$&')
            .replace(/^\d*$/, function (v) {
              return '00,' + (v.length < 3 ? ai(0, 3 - v.length) : '') + v
            }) +
          '.' +
          ai(o, s[1].length)
    )
  switch (t) {
    case '###,##0.00':
      return Hn(e, '#,##0.00', n)
    case '###,###':
    case '##,###':
    case '#,###':
      var h = ya(Ls(l, 0))
      return h !== '0' ? c + h : ''
    case '###,###.00':
      return Hn(e, '###,##0.00', n).replace(/^0\./, '.')
    case '#,###.00':
      return Hn(e, '#,##0.00', n).replace(/^0\./, '.')
  }
  throw new Error('unsupported format |' + t + '|')
}
function GE(e, t, n) {
  for (var i = t.length - 1; t.charCodeAt(i - 1) === 44; ) --i
  return Ki(e, t.substr(0, i), n / Math.pow(10, 3 * (t.length - i)))
}
function XE(e, t, n) {
  var i = t.replace(y1, ''),
    a = t.length - i.length
  return Ki(e, i, n * Math.pow(10, 2 * a)) + Cn('%', a)
}
function k1(e, t) {
  var n,
    i = e.indexOf('E') - e.indexOf('.') - 1
  if (e.match(/^#+0.0E\+0$/)) {
    if (t == 0) return '0.0E+0'
    if (t < 0) return '-' + k1(e, -t)
    var a = e.indexOf('.')
    a === -1 && (a = e.indexOf('E'))
    var s = Math.floor(Math.log(t) * Math.LOG10E) % a
    if (
      (s < 0 && (s += a), (n = (t / Math.pow(10, s)).toPrecision(i + 1 + ((a + s) % a))), !n.match(/[Ee]/))
    ) {
      var o = Math.floor(Math.log(t) * Math.LOG10E)
      n.indexOf('.') === -1
        ? (n = n.charAt(0) + '.' + n.substr(1) + 'E+' + (o - n.length + s))
        : (n += 'E+' + (o - s)),
        (n = n.replace(/\+-/, '-'))
    }
    n = n.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function (r, l, c, u) {
      return l + c + u.substr(0, (a + s) % a) + '.' + u.substr(s) + 'E'
    })
  } else n = t.toExponential(i)
  return (
    e.match(/E\+00$/) &&
      n.match(/e[+-]\d$/) &&
      (n = n.substr(0, n.length - 1) + '0' + n.charAt(n.length - 1)),
    e.match(/E\-/) && n.match(/e\+/) && (n = n.replace(/e\+/, 'e')),
    n.replace('e', 'E')
  )
}
function mi(e, t, n) {
  if (e.charCodeAt(0) === 40 && !t.match(w1)) {
    var i = t.replace(/\( */, '').replace(/ \)/, '').replace(/\)/, '')
    return n >= 0 ? mi('n', i, n) : '(' + mi('n', i, -n) + ')'
  }
  if (t.charCodeAt(t.length - 1) === 44) return GE(e, t, n)
  if (t.indexOf('%') !== -1) return XE(e, t, n)
  if (t.indexOf('E') !== -1) return k1(t, n)
  if (t.charCodeAt(0) === 36) return '$' + mi(e, t.substr(t.charAt(1) == ' ' ? 2 : 1), n)
  var a,
    s,
    o,
    r,
    l = Math.abs(n),
    c = n < 0 ? '-' : ''
  if (t.match(/^00+$/)) return c + ai(l, t.length)
  if (t.match(/^[#?]+$/))
    return (
      (a = '' + n), n === 0 && (a = ''), a.length > t.length ? a : pn(t.substr(0, t.length - a.length)) + a
    )
  if ((s = t.match(_1))) return jE(s, l, c)
  if (t.match(/^#+0+$/)) return c + ai(l, t.length - t.indexOf('0'))
  if ((s = t.match(x1)))
    return (
      (a = ('' + n).replace(/^([^\.]+)$/, '$1.' + pn(s[1])).replace(/\.$/, '.' + pn(s[1]))),
      (a = a.replace(/\.(\d*)$/, function (v, g) {
        return '.' + g + Cn('0', pn(s[1]).length - g.length)
      })),
      t.indexOf('0.') !== -1 ? a : a.replace(/^0\./, '.')
    )
  if (((t = t.replace(/^#+([0.])/, '$1')), (s = t.match(/^(0*)\.(#*)$/))))
    return (
      c +
      ('' + l)
        .replace(/\.(\d*[1-9])0*$/, '.$1')
        .replace(/^(-?\d*)$/, '$1.')
        .replace(/^0\./, s[1].length ? '0.' : '.')
    )
  if ((s = t.match(/^#{1,3},##0(\.?)$/))) return c + ya('' + l)
  if ((s = t.match(/^#,##0\.([#0]*0)$/)))
    return n < 0 ? '-' + mi(e, t, -n) : ya('' + n) + '.' + Cn('0', s[1].length)
  if ((s = t.match(/^#,#*,#0/))) return mi(e, t.replace(/^#,#*,/, ''), n)
  if ((s = t.match(/^([0#]+)(\\?-([0#]+))+$/)))
    return (
      (a = Ys(mi(e, t.replace(/[\\-]/g, ''), n))),
      (o = 0),
      Ys(
        Ys(t.replace(/\\/g, '')).replace(/[0#]/g, function (v) {
          return o < a.length ? a.charAt(o++) : v === '0' ? '0' : ''
        })
      )
    )
  if (t.match(S1))
    return (a = mi(e, '##########', n)), '(' + a.substr(0, 3) + ') ' + a.substr(3, 3) + '-' + a.substr(6)
  var u = ''
  if ((s = t.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)))
    return (
      (o = Math.min(s[4].length, 7)),
      (r = vc(l, Math.pow(10, o) - 1, !1)),
      (a = '' + c),
      (u = Ki('n', s[1], r[1])),
      u.charAt(u.length - 1) == ' ' && (u = u.substr(0, u.length - 1) + '0'),
      (a += u + s[2] + '/' + s[3]),
      (u = fc(r[2], o)),
      u.length < s[4].length && (u = pn(s[4].substr(s[4].length - u.length)) + u),
      (a += u),
      a
    )
  if ((s = t.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)))
    return (
      (o = Math.min(Math.max(s[1].length, s[4].length), 7)),
      (r = vc(l, Math.pow(10, o) - 1, !0)),
      c +
        (r[0] || (r[1] ? '' : '0')) +
        ' ' +
        (r[1]
          ? bh(r[1], o) + s[2] + '/' + s[3] + fc(r[2], o)
          : Cn(' ', 2 * o + 1 + s[2].length + s[3].length))
    )
  if ((s = t.match(/^[#0?]+$/)))
    return (a = '' + n), t.length <= a.length ? a : pn(t.substr(0, t.length - a.length)) + a
  if ((s = t.match(/^([#0]+)\.([#0]+)$/))) {
    ;(a = '' + n.toFixed(Math.min(s[2].length, 10)).replace(/([^0])0+$/, '$1')), (o = a.indexOf('.'))
    var d = t.indexOf('.') - o,
      f = t.length - a.length - d
    return pn(t.substr(0, d) + a + t.substr(t.length - f))
  }
  if ((s = t.match(/^00,000\.([#0]*0)$/)))
    return n < 0
      ? '-' + mi(e, t, -n)
      : ya('' + n)
          .replace(/^\d,\d{3}$/, '0$&')
          .replace(/^\d*$/, function (v) {
            return '00,' + (v.length < 3 ? ai(0, 3 - v.length) : '') + v
          }) +
          '.' +
          ai(0, s[1].length)
  switch (t) {
    case '###,###':
    case '##,###':
    case '#,###':
      var h = ya('' + l)
      return h !== '0' ? c + h : ''
    default:
      if (t.match(/\.[0#?]*$/))
        return mi(e, t.slice(0, t.lastIndexOf('.')), n) + pn(t.slice(t.lastIndexOf('.')))
  }
  throw new Error('unsupported format |' + t + '|')
}
function Ki(e, t, n) {
  return (n | 0) === n ? mi(e, t, n) : Hn(e, t, n)
}
function KE(e) {
  for (var t = [], n = !1, i = 0, a = 0; i < e.length; ++i)
    switch (e.charCodeAt(i)) {
      case 34:
        n = !n
        break
      case 95:
      case 42:
      case 92:
        ++i
        break
      case 59:
        ;(t[t.length] = e.substr(a, i - a)), (a = i + 1)
    }
  if (((t[t.length] = e.substr(a)), n === !0)) throw new Error('Format |' + e + '| unterminated string ')
  return t
}
var C1 = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/
function qE(e) {
  for (var t = 0, n = '', i = ''; t < e.length; )
    switch ((n = e.charAt(t))) {
      case 'G':
        hc(e, t) && (t += 6), t++
        break
      case '"':
        for (; e.charCodeAt(++t) !== 34 && t < e.length; );
        ++t
        break
      case '\\':
        t += 2
        break
      case '_':
        t += 2
        break
      case '@':
        ++t
        break
      case 'B':
      case 'b':
        if (e.charAt(t + 1) === '1' || e.charAt(t + 1) === '2') return !0
      case 'M':
      case 'D':
      case 'Y':
      case 'H':
      case 'S':
      case 'E':
      case 'm':
      case 'd':
      case 'y':
      case 'h':
      case 's':
      case 'e':
      case 'g':
        return !0
      case 'A':
      case 'a':
      case '上':
        if (
          e.substr(t, 3).toUpperCase() === 'A/P' ||
          e.substr(t, 5).toUpperCase() === 'AM/PM' ||
          e.substr(t, 5).toUpperCase() === '上午/下午'
        )
          return !0
        ++t
        break
      case '[':
        for (i = n; e.charAt(t++) !== ']' && t < e.length; ) i += e.charAt(t)
        if (i.match(C1)) return !0
        break
      case '.':
      case '0':
      case '#':
        for (
          ;
          t < e.length &&
          ('0#?.,E+-%'.indexOf((n = e.charAt(++t))) > -1 ||
            (n == '\\' && e.charAt(t + 1) == '-' && '0#'.indexOf(e.charAt(t + 2)) > -1));

        );
        break
      case '?':
        for (; e.charAt(++t) === n; );
        break
      case '*':
        ++t, (e.charAt(t) == ' ' || e.charAt(t) == '*') && ++t
        break
      case '(':
      case ')':
        ++t
        break
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        for (; t < e.length && '0123456789'.indexOf(e.charAt(++t)) > -1; );
        break
      case ' ':
        ++t
        break
      default:
        ++t
        break
    }
  return !1
}
function ZE(e, t, n, i) {
  for (var a = [], s = '', o = 0, r = '', l = 't', c, u, d, f = 'H'; o < e.length; )
    switch ((r = e.charAt(o))) {
      case 'G':
        if (!hc(e, o)) throw new Error('unrecognized character ' + r + ' in ' + e)
        ;(a[a.length] = { t: 'G', v: 'General' }), (o += 7)
        break
      case '"':
        for (s = ''; (d = e.charCodeAt(++o)) !== 34 && o < e.length; ) s += String.fromCharCode(d)
        ;(a[a.length] = { t: 't', v: s }), ++o
        break
      case '\\':
        var h = e.charAt(++o),
          v = h === '(' || h === ')' ? h : 't'
        ;(a[a.length] = { t: v, v: h }), ++o
        break
      case '_':
        ;(a[a.length] = { t: 't', v: ' ' }), (o += 2)
        break
      case '@':
        ;(a[a.length] = { t: 'T', v: t }), ++o
        break
      case 'B':
      case 'b':
        if (e.charAt(o + 1) === '1' || e.charAt(o + 1) === '2') {
          if (c == null && ((c = gl(t, n, e.charAt(o + 1) === '2')), c == null)) return ''
          ;(a[a.length] = { t: 'X', v: e.substr(o, 2) }), (l = r), (o += 2)
          break
        }
      case 'M':
      case 'D':
      case 'Y':
      case 'H':
      case 'S':
      case 'E':
        r = r.toLowerCase()
      case 'm':
      case 'd':
      case 'y':
      case 'h':
      case 's':
      case 'e':
      case 'g':
        if (t < 0 || (c == null && ((c = gl(t, n)), c == null))) return ''
        for (s = r; ++o < e.length && e.charAt(o).toLowerCase() === r; ) s += r
        r === 'm' && l.toLowerCase() === 'h' && (r = 'M'),
          r === 'h' && (r = f),
          (a[a.length] = { t: r, v: s }),
          (l = r)
        break
      case 'A':
      case 'a':
      case '上':
        var g = { t: r, v: r }
        if (
          (c == null && (c = gl(t, n)),
          e.substr(o, 3).toUpperCase() === 'A/P'
            ? (c != null && (g.v = c.H >= 12 ? 'P' : 'A'), (g.t = 'T'), (f = 'h'), (o += 3))
            : e.substr(o, 5).toUpperCase() === 'AM/PM'
            ? (c != null && (g.v = c.H >= 12 ? 'PM' : 'AM'), (g.t = 'T'), (o += 5), (f = 'h'))
            : e.substr(o, 5).toUpperCase() === '上午/下午'
            ? (c != null && (g.v = c.H >= 12 ? '下午' : '上午'), (g.t = 'T'), (o += 5), (f = 'h'))
            : ((g.t = 't'), ++o),
          c == null && g.t === 'T')
        )
          return ''
        ;(a[a.length] = g), (l = r)
        break
      case '[':
        for (s = r; e.charAt(o++) !== ']' && o < e.length; ) s += e.charAt(o)
        if (s.slice(-1) !== ']') throw 'unterminated "[" block: |' + s + '|'
        if (s.match(C1)) {
          if (c == null && ((c = gl(t, n)), c == null)) return ''
          ;(a[a.length] = { t: 'Z', v: s.toLowerCase() }), (l = s.charAt(1))
        } else
          s.indexOf('$') > -1 &&
            ((s = (s.match(/\$([^-\[\]]*)/) || [])[1] || '$'), qE(e) || (a[a.length] = { t: 't', v: s }))
        break
      case '.':
        if (c != null) {
          for (s = r; ++o < e.length && (r = e.charAt(o)) === '0'; ) s += r
          a[a.length] = { t: 's', v: s }
          break
        }
      case '0':
      case '#':
        for (s = r; ++o < e.length && '0#?.,E+-%'.indexOf((r = e.charAt(o))) > -1; ) s += r
        a[a.length] = { t: 'n', v: s }
        break
      case '?':
        for (s = r; e.charAt(++o) === r; ) s += r
        ;(a[a.length] = { t: r, v: s }), (l = r)
        break
      case '*':
        ++o, (e.charAt(o) == ' ' || e.charAt(o) == '*') && ++o
        break
      case '(':
      case ')':
        ;(a[a.length] = { t: i === 1 ? 't' : r, v: r }), ++o
        break
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        for (s = r; o < e.length && '0123456789'.indexOf(e.charAt(++o)) > -1; ) s += e.charAt(o)
        a[a.length] = { t: 'D', v: s }
        break
      case ' ':
        ;(a[a.length] = { t: r, v: r }), ++o
        break
      case '$':
        ;(a[a.length] = { t: 't', v: '$' }), ++o
        break
      default:
        if (",$-+/():!^&'~{}<>=€acfijklopqrtuvwxzP".indexOf(r) === -1)
          throw new Error('unrecognized character ' + r + ' in ' + e)
        ;(a[a.length] = { t: 't', v: r }), ++o
        break
    }
  var p = 0,
    y = 0,
    b
  for (o = a.length - 1, l = 't'; o >= 0; --o)
    switch (a[o].t) {
      case 'h':
      case 'H':
        ;(a[o].t = f), (l = 'h'), p < 1 && (p = 1)
        break
      case 's':
        ;(b = a[o].v.match(/\.0+$/)) && (y = Math.max(y, b[0].length - 1)), p < 3 && (p = 3)
      case 'd':
      case 'y':
      case 'M':
      case 'e':
        l = a[o].t
        break
      case 'm':
        l === 's' && ((a[o].t = 'M'), p < 2 && (p = 2))
        break
      case 'X':
        break
      case 'Z':
        p < 1 && a[o].v.match(/[Hh]/) && (p = 1),
          p < 2 && a[o].v.match(/[Mm]/) && (p = 2),
          p < 3 && a[o].v.match(/[Ss]/) && (p = 3)
    }
  switch (p) {
    case 0:
      break
    case 1:
      c.u >= 0.5 && ((c.u = 0), ++c.S), c.S >= 60 && ((c.S = 0), ++c.M), c.M >= 60 && ((c.M = 0), ++c.H)
      break
    case 2:
      c.u >= 0.5 && ((c.u = 0), ++c.S), c.S >= 60 && ((c.S = 0), ++c.M)
      break
  }
  var x = '',
    w
  for (o = 0; o < a.length; ++o)
    switch (a[o].t) {
      case 't':
      case 'T':
      case ' ':
      case 'D':
        break
      case 'X':
        ;(a[o].v = ''), (a[o].t = ';')
        break
      case 'd':
      case 'm':
      case 'y':
      case 'h':
      case 'H':
      case 'M':
      case 's':
      case 'e':
      case 'b':
      case 'Z':
        ;(a[o].v = $E(a[o].t.charCodeAt(0), a[o].v, c, y)), (a[o].t = 't')
        break
      case 'n':
      case '?':
        for (
          w = o + 1;
          a[w] != null &&
          ((r = a[w].t) === '?' ||
            r === 'D' ||
            ((r === ' ' || r === 't') &&
              a[w + 1] != null &&
              (a[w + 1].t === '?' || (a[w + 1].t === 't' && a[w + 1].v === '/'))) ||
            (a[o].t === '(' && (r === ' ' || r === 'n' || r === ')')) ||
            (r === 't' && (a[w].v === '/' || (a[w].v === ' ' && a[w + 1] != null && a[w + 1].t == '?'))));

        )
          (a[o].v += a[w].v), (a[w] = { v: '', t: ';' }), ++w
        ;(x += a[o].v), (o = w - 1)
        break
      case 'G':
        ;(a[o].t = 't'), (a[o].v = Hd(t, n))
        break
    }
  var C = '',
    P,
    k
  if (x.length > 0) {
    x.charCodeAt(0) == 40
      ? ((P = t < 0 && x.charCodeAt(0) === 45 ? -t : t), (k = Ki('n', x, P)))
      : ((P = t < 0 && i > 1 ? -t : t),
        (k = Ki('n', x, P)),
        P < 0 && a[0] && a[0].t == 't' && ((k = k.substr(1)), (a[0].v = '-' + a[0].v))),
      (w = k.length - 1)
    var S = a.length
    for (o = 0; o < a.length; ++o)
      if (a[o] != null && a[o].t != 't' && a[o].v.indexOf('.') > -1) {
        S = o
        break
      }
    var _ = a.length
    if (S === a.length && k.indexOf('E') === -1) {
      for (o = a.length - 1; o >= 0; --o)
        a[o] == null ||
          'n?'.indexOf(a[o].t) === -1 ||
          (w >= a[o].v.length - 1
            ? ((w -= a[o].v.length), (a[o].v = k.substr(w + 1, a[o].v.length)))
            : w < 0
            ? (a[o].v = '')
            : ((a[o].v = k.substr(0, w + 1)), (w = -1)),
          (a[o].t = 't'),
          (_ = o))
      w >= 0 && _ < a.length && (a[_].v = k.substr(0, w + 1) + a[_].v)
    } else if (S !== a.length && k.indexOf('E') === -1) {
      for (w = k.indexOf('.') - 1, o = S; o >= 0; --o)
        if (!(a[o] == null || 'n?'.indexOf(a[o].t) === -1)) {
          for (
            u = a[o].v.indexOf('.') > -1 && o === S ? a[o].v.indexOf('.') - 1 : a[o].v.length - 1,
              C = a[o].v.substr(u + 1);
            u >= 0;
            --u
          )
            w >= 0 && (a[o].v.charAt(u) === '0' || a[o].v.charAt(u) === '#') && (C = k.charAt(w--) + C)
          ;(a[o].v = C), (a[o].t = 't'), (_ = o)
        }
      for (
        w >= 0 && _ < a.length && (a[_].v = k.substr(0, w + 1) + a[_].v), w = k.indexOf('.') + 1, o = S;
        o < a.length;
        ++o
      )
        if (!(a[o] == null || ('n?('.indexOf(a[o].t) === -1 && o !== S))) {
          for (
            u = a[o].v.indexOf('.') > -1 && o === S ? a[o].v.indexOf('.') + 1 : 0, C = a[o].v.substr(0, u);
            u < a[o].v.length;
            ++u
          )
            w < k.length && (C += k.charAt(w++))
          ;(a[o].v = C), (a[o].t = 't'), (_ = o)
        }
    }
  }
  for (o = 0; o < a.length; ++o)
    a[o] != null &&
      'n?'.indexOf(a[o].t) > -1 &&
      ((P = i > 1 && t < 0 && o > 0 && a[o - 1].v === '-' ? -t : t),
      (a[o].v = Ki(a[o].t, a[o].v, P)),
      (a[o].t = 't'))
  var T = ''
  for (o = 0; o !== a.length; ++o) a[o] != null && (T += a[o].v)
  return T
}
var qg = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/
function Zg(e, t) {
  if (t == null) return !1
  var n = parseFloat(t[2])
  switch (t[1]) {
    case '=':
      if (e == n) return !0
      break
    case '>':
      if (e > n) return !0
      break
    case '<':
      if (e < n) return !0
      break
    case '<>':
      if (e != n) return !0
      break
    case '>=':
      if (e >= n) return !0
      break
    case '<=':
      if (e <= n) return !0
      break
  }
  return !1
}
function JE(e, t) {
  var n = KE(e),
    i = n.length,
    a = n[i - 1].indexOf('@')
  if ((i < 4 && a > -1 && --i, n.length > 4))
    throw new Error('cannot find right format for |' + n.join('|') + '|')
  if (typeof t != 'number') return [4, n.length === 4 || a > -1 ? n[n.length - 1] : '@']
  switch (n.length) {
    case 1:
      n = a > -1 ? ['General', 'General', 'General', n[0]] : [n[0], n[0], n[0], '@']
      break
    case 2:
      n = a > -1 ? [n[0], n[0], n[0], n[1]] : [n[0], n[1], n[0], '@']
      break
    case 3:
      n = a > -1 ? [n[0], n[1], n[0], n[2]] : [n[0], n[1], n[2], '@']
      break
  }
  var s = t > 0 ? n[0] : t < 0 ? n[1] : n[2]
  if (n[0].indexOf('[') === -1 && n[1].indexOf('[') === -1) return [i, s]
  if (n[0].match(/\[[=<>]/) != null || n[1].match(/\[[=<>]/) != null) {
    var o = n[0].match(qg),
      r = n[1].match(qg)
    return Zg(t, o) ? [i, n[0]] : Zg(t, r) ? [i, n[1]] : [i, n[o != null && r != null ? 2 : 1]]
  }
  return [i, s]
}
function Pr(e, t, n) {
  n == null && (n = {})
  var i = ''
  switch (typeof e) {
    case 'string':
      e == 'm/d/yy' && n.dateNF ? (i = n.dateNF) : (i = e)
      break
    case 'number':
      e == 14 && n.dateNF ? (i = n.dateNF) : (i = (n.table != null ? n.table : ci)[e]),
        i == null && (i = (n.table && n.table[Gg[e]]) || ci[Gg[e]]),
        i == null && (i = LE[e] || 'General')
      break
  }
  if (hc(i, 0)) return Hd(t, n)
  t instanceof Date && (t = p1(t, n.date1904))
  var a = JE(i, t)
  if (hc(a[1])) return Hd(t, n)
  if (t === !0) t = 'TRUE'
  else if (t === !1) t = 'FALSE'
  else if (t === '' || t == null) return ''
  return ZE(a[1], t, n, a[0])
}
function M1(e, t) {
  if (typeof t != 'number') {
    t = +t || -1
    for (var n = 0; n < 392; ++n) {
      if (ci[n] == null) {
        t < 0 && (t = n)
        continue
      }
      if (ci[n] == e) {
        t = n
        break
      }
    }
    t < 0 && (t = 391)
  }
  return (ci[t] = e), t
}
function QE(e) {
  for (var t = 0; t != 392; ++t) e[t] !== void 0 && M1(e[t], t)
}
function eL() {
  ci = EE()
}
var tL = (function () {
    var e = {}
    e.version = '1.2.0'
    function t() {
      for (var k = 0, S = new Array(256), _ = 0; _ != 256; ++_)
        (k = _),
          (k = k & 1 ? -306674912 ^ (k >>> 1) : k >>> 1),
          (k = k & 1 ? -306674912 ^ (k >>> 1) : k >>> 1),
          (k = k & 1 ? -306674912 ^ (k >>> 1) : k >>> 1),
          (k = k & 1 ? -306674912 ^ (k >>> 1) : k >>> 1),
          (k = k & 1 ? -306674912 ^ (k >>> 1) : k >>> 1),
          (k = k & 1 ? -306674912 ^ (k >>> 1) : k >>> 1),
          (k = k & 1 ? -306674912 ^ (k >>> 1) : k >>> 1),
          (k = k & 1 ? -306674912 ^ (k >>> 1) : k >>> 1),
          (S[_] = k)
      return typeof Int32Array < 'u' ? new Int32Array(S) : S
    }
    var n = t()
    function i(k) {
      var S = 0,
        _ = 0,
        T = 0,
        B = typeof Int32Array < 'u' ? new Int32Array(4096) : new Array(4096)
      for (T = 0; T != 256; ++T) B[T] = k[T]
      for (T = 0; T != 256; ++T)
        for (_ = k[T], S = 256 + T; S < 4096; S += 256) _ = B[S] = (_ >>> 8) ^ k[_ & 255]
      var O = []
      for (T = 1; T != 16; ++T)
        O[T - 1] =
          typeof Int32Array < 'u' ? B.subarray(T * 256, T * 256 + 256) : B.slice(T * 256, T * 256 + 256)
      return O
    }
    var a = i(n),
      s = a[0],
      o = a[1],
      r = a[2],
      l = a[3],
      c = a[4],
      u = a[5],
      d = a[6],
      f = a[7],
      h = a[8],
      v = a[9],
      g = a[10],
      p = a[11],
      y = a[12],
      b = a[13],
      x = a[14]
    function w(k, S) {
      for (var _ = S ^ -1, T = 0, B = k.length; T < B; ) _ = (_ >>> 8) ^ n[(_ ^ k.charCodeAt(T++)) & 255]
      return ~_
    }
    function C(k, S) {
      for (var _ = S ^ -1, T = k.length - 15, B = 0; B < T; )
        _ =
          x[k[B++] ^ (_ & 255)] ^
          b[k[B++] ^ ((_ >> 8) & 255)] ^
          y[k[B++] ^ ((_ >> 16) & 255)] ^
          p[k[B++] ^ (_ >>> 24)] ^
          g[k[B++]] ^
          v[k[B++]] ^
          h[k[B++]] ^
          f[k[B++]] ^
          d[k[B++]] ^
          u[k[B++]] ^
          c[k[B++]] ^
          l[k[B++]] ^
          r[k[B++]] ^
          o[k[B++]] ^
          s[k[B++]] ^
          n[k[B++]]
      for (T += 15; B < T; ) _ = (_ >>> 8) ^ n[(_ ^ k[B++]) & 255]
      return ~_
    }
    function P(k, S) {
      for (var _ = S ^ -1, T = 0, B = k.length, O = 0, N = 0; T < B; )
        (O = k.charCodeAt(T++)),
          O < 128
            ? (_ = (_ >>> 8) ^ n[(_ ^ O) & 255])
            : O < 2048
            ? ((_ = (_ >>> 8) ^ n[(_ ^ (192 | ((O >> 6) & 31))) & 255]),
              (_ = (_ >>> 8) ^ n[(_ ^ (128 | (O & 63))) & 255]))
            : O >= 55296 && O < 57344
            ? ((O = (O & 1023) + 64),
              (N = k.charCodeAt(T++) & 1023),
              (_ = (_ >>> 8) ^ n[(_ ^ (240 | ((O >> 8) & 7))) & 255]),
              (_ = (_ >>> 8) ^ n[(_ ^ (128 | ((O >> 2) & 63))) & 255]),
              (_ = (_ >>> 8) ^ n[(_ ^ (128 | ((N >> 6) & 15) | ((O & 3) << 4))) & 255]),
              (_ = (_ >>> 8) ^ n[(_ ^ (128 | (N & 63))) & 255]))
            : ((_ = (_ >>> 8) ^ n[(_ ^ (224 | ((O >> 12) & 15))) & 255]),
              (_ = (_ >>> 8) ^ n[(_ ^ (128 | ((O >> 6) & 63))) & 255]),
              (_ = (_ >>> 8) ^ n[(_ ^ (128 | (O & 63))) & 255]))
      return ~_
    }
    return (e.table = n), (e.bstr = w), (e.buf = C), (e.str = P), e
  })(),
  ti = (function () {
    var t = {}
    t.version = '1.2.1'
    function n(M, I) {
      for (
        var V = M.split('/'), E = I.split('/'), F = 0, R = 0, K = Math.min(V.length, E.length);
        F < K;
        ++F
      ) {
        if ((R = V[F].length - E[F].length)) return R
        if (V[F] != E[F]) return V[F] < E[F] ? -1 : 1
      }
      return V.length - E.length
    }
    function i(M) {
      if (M.charAt(M.length - 1) == '/') return M.slice(0, -1).indexOf('/') === -1 ? M : i(M.slice(0, -1))
      var I = M.lastIndexOf('/')
      return I === -1 ? M : M.slice(0, I + 1)
    }
    function a(M) {
      if (M.charAt(M.length - 1) == '/') return a(M.slice(0, -1))
      var I = M.lastIndexOf('/')
      return I === -1 ? M : M.slice(I + 1)
    }
    function s(M, I) {
      typeof I == 'string' && (I = new Date(I))
      var V = I.getHours()
      ;(V = (V << 6) | I.getMinutes()), (V = (V << 5) | (I.getSeconds() >>> 1)), M.write_shift(2, V)
      var E = I.getFullYear() - 1980
      ;(E = (E << 4) | (I.getMonth() + 1)), (E = (E << 5) | I.getDate()), M.write_shift(2, E)
    }
    function o(M) {
      var I = M.read_shift(2) & 65535,
        V = M.read_shift(2) & 65535,
        E = new Date(),
        F = V & 31
      V >>>= 5
      var R = V & 15
      ;(V >>>= 4), E.setMilliseconds(0), E.setFullYear(V + 1980), E.setMonth(R - 1), E.setDate(F)
      var K = I & 31
      I >>>= 5
      var re = I & 63
      return (I >>>= 6), E.setHours(I), E.setMinutes(re), E.setSeconds(K << 1), E
    }
    function r(M) {
      va(M, 0)
      for (var I = {}, V = 0; M.l <= M.length - 4; ) {
        var E = M.read_shift(2),
          F = M.read_shift(2),
          R = M.l + F,
          K = {}
        switch (E) {
          case 21589:
            ;(V = M.read_shift(1)),
              V & 1 && (K.mtime = M.read_shift(4)),
              F > 5 && (V & 2 && (K.atime = M.read_shift(4)), V & 4 && (K.ctime = M.read_shift(4))),
              K.mtime && (K.mt = new Date(K.mtime * 1e3))
            break
        }
        ;(M.l = R), (I[E] = K)
      }
      return I
    }
    var l
    function c() {
      return l || (l = {})
    }
    function u(M, I) {
      if (M[0] == 80 && M[1] == 75) return jh(M, I)
      if ((M[0] | 32) == 109 && (M[1] | 32) == 105) return dx(M, I)
      if (M.length < 512) throw new Error('CFB file size ' + M.length + ' < 512')
      var V = 3,
        E = 512,
        F = 0,
        R = 0,
        K = 0,
        re = 0,
        G = 0,
        q = [],
        J = M.slice(0, 512)
      va(J, 0)
      var me = d(J)
      switch (((V = me[0]), V)) {
        case 3:
          E = 512
          break
        case 4:
          E = 4096
          break
        case 0:
          if (me[1] == 0) return jh(M, I)
        default:
          throw new Error('Major Version: Expected 3 or 4 saw ' + V)
      }
      E !== 512 && ((J = M.slice(0, E)), va(J, 28))
      var Ae = M.slice(0, E)
      f(J, V)
      var Ie = J.read_shift(4, 'i')
      if (V === 3 && Ie !== 0) throw new Error('# Directory Sectors: Expected 0 saw ' + Ie)
      ;(J.l += 4),
        (K = J.read_shift(4, 'i')),
        (J.l += 4),
        J.chk('00100000', 'Mini Stream Cutoff Size: '),
        (re = J.read_shift(4, 'i')),
        (F = J.read_shift(4, 'i')),
        (G = J.read_shift(4, 'i')),
        (R = J.read_shift(4, 'i'))
      for (var be = -1, Ee = 0; Ee < 109 && ((be = J.read_shift(4, 'i')), !(be < 0)); ++Ee) q[Ee] = be
      var qe = h(M, E)
      p(G, R, qe, E, q)
      var Mt = b(qe, K, q, E)
      ;(Mt[K].name = '!Directory'),
        F > 0 && re !== N && (Mt[re].name = '!MiniFAT'),
        (Mt[q[0]].name = '!FAT'),
        (Mt.fat_addrs = q),
        (Mt.ssz = E)
      var At = {},
        sn = [],
        Ao = [],
        Po = []
      x(K, Mt, qe, sn, F, At, Ao, re), v(Ao, Po, sn), sn.shift()
      var To = { FileIndex: Ao, FullPaths: Po }
      return I && I.raw && (To.raw = { header: Ae, sectors: qe }), To
    }
    function d(M) {
      if (M[M.l] == 80 && M[M.l + 1] == 75) return [0, 0]
      M.chk(Q, 'Header Signature: '), (M.l += 16)
      var I = M.read_shift(2, 'u')
      return [M.read_shift(2, 'u'), I]
    }
    function f(M, I) {
      var V = 9
      switch (((M.l += 2), (V = M.read_shift(2)))) {
        case 9:
          if (I != 3) throw new Error('Sector Shift: Expected 9 saw ' + V)
          break
        case 12:
          if (I != 4) throw new Error('Sector Shift: Expected 12 saw ' + V)
          break
        default:
          throw new Error('Sector Shift: Expected 9 or 12 saw ' + V)
      }
      M.chk('0600', 'Mini Sector Shift: '), M.chk('000000000000', 'Reserved: ')
    }
    function h(M, I) {
      for (var V = Math.ceil(M.length / I) - 1, E = [], F = 1; F < V; ++F)
        E[F - 1] = M.slice(F * I, (F + 1) * I)
      return (E[V - 1] = M.slice(V * I)), E
    }
    function v(M, I, V) {
      for (var E = 0, F = 0, R = 0, K = 0, re = 0, G = V.length, q = [], J = []; E < G; ++E)
        (q[E] = J[E] = E), (I[E] = V[E])
      for (; re < J.length; ++re)
        (E = J[re]),
          (F = M[E].L),
          (R = M[E].R),
          (K = M[E].C),
          q[E] === E && (F !== -1 && q[F] !== F && (q[E] = q[F]), R !== -1 && q[R] !== R && (q[E] = q[R])),
          K !== -1 && (q[K] = E),
          F !== -1 && E != q[E] && ((q[F] = q[E]), J.lastIndexOf(F) < re && J.push(F)),
          R !== -1 && E != q[E] && ((q[R] = q[E]), J.lastIndexOf(R) < re && J.push(R))
      for (E = 1; E < G; ++E)
        q[E] === E && (R !== -1 && q[R] !== R ? (q[E] = q[R]) : F !== -1 && q[F] !== F && (q[E] = q[F]))
      for (E = 1; E < G; ++E)
        if (M[E].type !== 0) {
          if (((re = E), re != q[re]))
            do (re = q[re]), (I[E] = I[re] + '/' + I[E])
            while (re !== 0 && q[re] !== -1 && re != q[re])
          q[E] = -1
        }
      for (I[0] += '/', E = 1; E < G; ++E) M[E].type !== 2 && (I[E] += '/')
    }
    function g(M, I, V) {
      for (var E = M.start, F = M.size, R = [], K = E; V && F > 0 && K >= 0; )
        R.push(I.slice(K * O, K * O + O)), (F -= O), (K = $s(V, K * 4))
      return R.length === 0 ? Ri(0) : Bs(R).slice(0, M.size)
    }
    function p(M, I, V, E, F) {
      var R = N
      if (M === N) {
        if (I !== 0) throw new Error('DIFAT chain shorter than expected')
      } else if (M !== -1) {
        var K = V[M],
          re = (E >>> 2) - 1
        if (!K) return
        for (var G = 0; G < re && (R = $s(K, G * 4)) !== N; ++G) F.push(R)
        p($s(K, E - 4), I - 1, V, E, F)
      }
    }
    function y(M, I, V, E, F) {
      var R = [],
        K = []
      F || (F = [])
      var re = E - 1,
        G = 0,
        q = 0
      for (G = I; G >= 0; ) {
        ;(F[G] = !0), (R[R.length] = G), K.push(M[G])
        var J = V[Math.floor((G * 4) / E)]
        if (((q = (G * 4) & re), E < 4 + q)) throw new Error('FAT boundary crossed: ' + G + ' 4 ' + E)
        if (!M[J]) break
        G = $s(M[J], q)
      }
      return { nodes: R, data: am([K]) }
    }
    function b(M, I, V, E) {
      var F = M.length,
        R = [],
        K = [],
        re = [],
        G = [],
        q = E - 1,
        J = 0,
        me = 0,
        Ae = 0,
        Ie = 0
      for (J = 0; J < F; ++J)
        if (((re = []), (Ae = J + I), Ae >= F && (Ae -= F), !K[Ae])) {
          G = []
          var be = []
          for (me = Ae; me >= 0; ) {
            ;(be[me] = !0), (K[me] = !0), (re[re.length] = me), G.push(M[me])
            var Ee = V[Math.floor((me * 4) / E)]
            if (((Ie = (me * 4) & q), E < 4 + Ie)) throw new Error('FAT boundary crossed: ' + me + ' 4 ' + E)
            if (!M[Ee] || ((me = $s(M[Ee], Ie)), be[me])) break
          }
          R[Ae] = { nodes: re, data: am([G]) }
        }
      return R
    }
    function x(M, I, V, E, F, R, K, re) {
      for (var G = 0, q = E.length ? 2 : 0, J = I[M].data, me = 0, Ae = 0, Ie; me < J.length; me += 128) {
        var be = J.slice(me, me + 128)
        va(be, 64), (Ae = be.read_shift(2)), (Ie = xh(be, 0, Ae - q)), E.push(Ie)
        var Ee = {
            name: Ie,
            type: be.read_shift(1),
            color: be.read_shift(1),
            L: be.read_shift(4, 'i'),
            R: be.read_shift(4, 'i'),
            C: be.read_shift(4, 'i'),
            clsid: be.read_shift(16),
            state: be.read_shift(4, 'i'),
            start: 0,
            size: 0
          },
          qe = be.read_shift(2) + be.read_shift(2) + be.read_shift(2) + be.read_shift(2)
        qe !== 0 && (Ee.ct = w(be, be.l - 8))
        var Mt = be.read_shift(2) + be.read_shift(2) + be.read_shift(2) + be.read_shift(2)
        Mt !== 0 && (Ee.mt = w(be, be.l - 8)),
          (Ee.start = be.read_shift(4, 'i')),
          (Ee.size = be.read_shift(4, 'i')),
          Ee.size < 0 && Ee.start < 0 && ((Ee.size = Ee.type = 0), (Ee.start = N), (Ee.name = '')),
          Ee.type === 5
            ? ((G = Ee.start), F > 0 && G !== N && (I[G].name = '!StreamData'))
            : Ee.size >= 4096
            ? ((Ee.storage = 'fat'),
              I[Ee.start] === void 0 && (I[Ee.start] = y(V, Ee.start, I.fat_addrs, I.ssz)),
              (I[Ee.start].name = Ee.name),
              (Ee.content = I[Ee.start].data.slice(0, Ee.size)))
            : ((Ee.storage = 'minifat'),
              Ee.size < 0
                ? (Ee.size = 0)
                : G !== N && Ee.start !== N && I[G] && (Ee.content = g(Ee, I[G].data, (I[re] || {}).data))),
          Ee.content && va(Ee.content, 0),
          (R[Ie] = Ee),
          K.push(Ee)
      }
    }
    function w(M, I) {
      return new Date(((Ln(M, I + 4) / 1e7) * Math.pow(2, 32) + Ln(M, I) / 1e7 - 11644473600) * 1e3)
    }
    function C(M, I) {
      return c(), u(l.readFileSync(M), I)
    }
    function P(M, I) {
      var V = I && I.type
      switch ((V || (Pt && Buffer.isBuffer(M) && (V = 'buffer')), V || 'base64')) {
        case 'file':
          return C(M, I)
        case 'base64':
          return u(Rs(Wg(M)), I)
        case 'binary':
          return u(Rs(M), I)
      }
      return u(M, I)
    }
    function k(M, I) {
      var V = I || {},
        E = V.root || 'Root Entry'
      if (
        (M.FullPaths || (M.FullPaths = []),
        M.FileIndex || (M.FileIndex = []),
        M.FullPaths.length !== M.FileIndex.length)
      )
        throw new Error('inconsistent CFB structure')
      M.FullPaths.length === 0 && ((M.FullPaths[0] = E + '/'), (M.FileIndex[0] = { name: E, type: 5 })),
        V.CLSID && (M.FileIndex[0].clsid = V.CLSID),
        S(M)
    }
    function S(M) {
      var I = 'Sh33tJ5'
      if (!ti.find(M, '/' + I)) {
        var V = Ri(4)
        ;(V[0] = 55),
          (V[1] = V[3] = 50),
          (V[2] = 54),
          M.FileIndex.push({ name: I, type: 2, content: V, size: 4, L: 69, R: 69, C: 69 }),
          M.FullPaths.push(M.FullPaths[0] + I),
          _(M)
      }
    }
    function _(M, I) {
      k(M)
      for (var V = !1, E = !1, F = M.FullPaths.length - 1; F >= 0; --F) {
        var R = M.FileIndex[F]
        switch (R.type) {
          case 0:
            E ? (V = !0) : (M.FileIndex.pop(), M.FullPaths.pop())
            break
          case 1:
          case 2:
          case 5:
            ;(E = !0), isNaN(R.R * R.L * R.C) && (V = !0), R.R > -1 && R.L > -1 && R.R == R.L && (V = !0)
            break
          default:
            V = !0
            break
        }
      }
      if (!(!V && !I)) {
        var K = new Date(1987, 1, 19),
          re = 0,
          G = Object.create ? Object.create(null) : {},
          q = []
        for (F = 0; F < M.FullPaths.length; ++F)
          (G[M.FullPaths[F]] = !0), M.FileIndex[F].type !== 0 && q.push([M.FullPaths[F], M.FileIndex[F]])
        for (F = 0; F < q.length; ++F) {
          var J = i(q[F][0])
          ;(E = G[J]),
            E ||
              (q.push([J, { name: a(J).replace('/', ''), type: 1, clsid: j, ct: K, mt: K, content: null }]),
              (G[J] = !0))
        }
        for (
          q.sort(function (Ie, be) {
            return n(Ie[0], be[0])
          }),
            M.FullPaths = [],
            M.FileIndex = [],
            F = 0;
          F < q.length;
          ++F
        )
          (M.FullPaths[F] = q[F][0]), (M.FileIndex[F] = q[F][1])
        for (F = 0; F < q.length; ++F) {
          var me = M.FileIndex[F],
            Ae = M.FullPaths[F]
          if (
            ((me.name = a(Ae).replace('/', '')),
            (me.L = me.R = me.C = -(me.color = 1)),
            (me.size = me.content ? me.content.length : 0),
            (me.start = 0),
            (me.clsid = me.clsid || j),
            F === 0)
          )
            (me.C = q.length > 1 ? 1 : -1), (me.size = 0), (me.type = 5)
          else if (Ae.slice(-1) == '/') {
            for (re = F + 1; re < q.length && i(M.FullPaths[re]) != Ae; ++re);
            for (
              me.C = re >= q.length ? -1 : re, re = F + 1;
              re < q.length && i(M.FullPaths[re]) != i(Ae);
              ++re
            );
            ;(me.R = re >= q.length ? -1 : re), (me.type = 1)
          } else i(M.FullPaths[F + 1] || '') == i(Ae) && (me.R = F + 1), (me.type = 2)
        }
      }
    }
    function T(M, I) {
      var V = I || {}
      if (V.fileType == 'mad') return fx(M, V)
      switch ((_(M), V.fileType)) {
        case 'zip':
          return sx(M, V)
      }
      var E = (function (Ie) {
          for (var be = 0, Ee = 0, qe = 0; qe < Ie.FileIndex.length; ++qe) {
            var Mt = Ie.FileIndex[qe]
            if (Mt.content) {
              var At = Mt.content.length
              At > 0 && (At < 4096 ? (be += (At + 63) >> 6) : (Ee += (At + 511) >> 9))
            }
          }
          for (
            var sn = (Ie.FullPaths.length + 3) >> 2,
              Ao = (be + 7) >> 3,
              Po = (be + 127) >> 7,
              To = Ao + Ee + sn + Po,
              Na = (To + 127) >> 7,
              uu = Na <= 109 ? 0 : Math.ceil((Na - 109) / 127);
            (To + Na + uu + 127) >> 7 > Na;

          )
            uu = ++Na <= 109 ? 0 : Math.ceil((Na - 109) / 127)
          var Di = [1, uu, Na, Po, sn, Ee, be, 0]
          return (
            (Ie.FileIndex[0].size = be << 6),
            (Di[7] =
              (Ie.FileIndex[0].start = Di[0] + Di[1] + Di[2] + Di[3] + Di[4] + Di[5]) + ((Di[6] + 7) >> 3)),
            Di
          )
        })(M),
        F = Ri(E[7] << 9),
        R = 0,
        K = 0
      {
        for (R = 0; R < 8; ++R) F.write_shift(1, ue[R])
        for (R = 0; R < 8; ++R) F.write_shift(2, 0)
        for (
          F.write_shift(2, 62),
            F.write_shift(2, 3),
            F.write_shift(2, 65534),
            F.write_shift(2, 9),
            F.write_shift(2, 6),
            R = 0;
          R < 3;
          ++R
        )
          F.write_shift(2, 0)
        for (
          F.write_shift(4, 0),
            F.write_shift(4, E[2]),
            F.write_shift(4, E[0] + E[1] + E[2] + E[3] - 1),
            F.write_shift(4, 0),
            F.write_shift(4, 4096),
            F.write_shift(4, E[3] ? E[0] + E[1] + E[2] - 1 : N),
            F.write_shift(4, E[3]),
            F.write_shift(-4, E[1] ? E[0] - 1 : N),
            F.write_shift(4, E[1]),
            R = 0;
          R < 109;
          ++R
        )
          F.write_shift(-4, R < E[2] ? E[1] + R : -1)
      }
      if (E[1])
        for (K = 0; K < E[1]; ++K) {
          for (; R < 236 + K * 127; ++R) F.write_shift(-4, R < E[2] ? E[1] + R : -1)
          F.write_shift(-4, K === E[1] - 1 ? N : K + 1)
        }
      var re = function (Ie) {
        for (K += Ie; R < K - 1; ++R) F.write_shift(-4, R + 1)
        Ie && (++R, F.write_shift(-4, N))
      }
      for (K = R = 0, K += E[1]; R < K; ++R) F.write_shift(-4, U.DIFSECT)
      for (K += E[2]; R < K; ++R) F.write_shift(-4, U.FATSECT)
      re(E[3]), re(E[4])
      for (var G = 0, q = 0, J = M.FileIndex[0]; G < M.FileIndex.length; ++G)
        (J = M.FileIndex[G]),
          J.content && ((q = J.content.length), !(q < 4096) && ((J.start = K), re((q + 511) >> 9)))
      for (re((E[6] + 7) >> 3); F.l & 511; ) F.write_shift(-4, U.ENDOFCHAIN)
      for (K = R = 0, G = 0; G < M.FileIndex.length; ++G)
        (J = M.FileIndex[G]),
          J.content && ((q = J.content.length), !(!q || q >= 4096) && ((J.start = K), re((q + 63) >> 6)))
      for (; F.l & 511; ) F.write_shift(-4, U.ENDOFCHAIN)
      for (R = 0; R < E[4] << 2; ++R) {
        var me = M.FullPaths[R]
        if (!me || me.length === 0) {
          for (G = 0; G < 17; ++G) F.write_shift(4, 0)
          for (G = 0; G < 3; ++G) F.write_shift(4, -1)
          for (G = 0; G < 12; ++G) F.write_shift(4, 0)
          continue
        }
        ;(J = M.FileIndex[R]), R === 0 && (J.start = J.size ? J.start - 1 : N)
        var Ae = (R === 0 && V.root) || J.name
        if (
          ((q = 2 * (Ae.length + 1)),
          F.write_shift(64, Ae, 'utf16le'),
          F.write_shift(2, q),
          F.write_shift(1, J.type),
          F.write_shift(1, J.color),
          F.write_shift(-4, J.L),
          F.write_shift(-4, J.R),
          F.write_shift(-4, J.C),
          J.clsid)
        )
          F.write_shift(16, J.clsid, 'hex')
        else for (G = 0; G < 4; ++G) F.write_shift(4, 0)
        F.write_shift(4, J.state || 0),
          F.write_shift(4, 0),
          F.write_shift(4, 0),
          F.write_shift(4, 0),
          F.write_shift(4, 0),
          F.write_shift(4, J.start),
          F.write_shift(4, J.size),
          F.write_shift(4, 0)
      }
      for (R = 1; R < M.FileIndex.length; ++R)
        if (((J = M.FileIndex[R]), J.size >= 4096))
          if (((F.l = (J.start + 1) << 9), Pt && Buffer.isBuffer(J.content)))
            J.content.copy(F, F.l, 0, J.size), (F.l += (J.size + 511) & -512)
          else {
            for (G = 0; G < J.size; ++G) F.write_shift(1, J.content[G])
            for (; G & 511; ++G) F.write_shift(1, 0)
          }
      for (R = 1; R < M.FileIndex.length; ++R)
        if (((J = M.FileIndex[R]), J.size > 0 && J.size < 4096))
          if (Pt && Buffer.isBuffer(J.content))
            J.content.copy(F, F.l, 0, J.size), (F.l += (J.size + 63) & -64)
          else {
            for (G = 0; G < J.size; ++G) F.write_shift(1, J.content[G])
            for (; G & 63; ++G) F.write_shift(1, 0)
          }
      if (Pt) F.l = F.length
      else for (; F.l < F.length; ) F.write_shift(1, 0)
      return F
    }
    function B(M, I) {
      var V = M.FullPaths.map(function (G) {
          return G.toUpperCase()
        }),
        E = V.map(function (G) {
          var q = G.split('/')
          return q[q.length - (G.slice(-1) == '/' ? 2 : 1)]
        }),
        F = !1
      I.charCodeAt(0) === 47 ? ((F = !0), (I = V[0].slice(0, -1) + I)) : (F = I.indexOf('/') !== -1)
      var R = I.toUpperCase(),
        K = F === !0 ? V.indexOf(R) : E.indexOf(R)
      if (K !== -1) return M.FileIndex[K]
      var re = !R.match(vl)
      for (R = R.replace(sr, ''), re && (R = R.replace(vl, '!')), K = 0; K < V.length; ++K)
        if (
          (re ? V[K].replace(vl, '!') : V[K]).replace(sr, '') == R ||
          (re ? E[K].replace(vl, '!') : E[K]).replace(sr, '') == R
        )
          return M.FileIndex[K]
      return null
    }
    var O = 64,
      N = -2,
      Q = 'd0cf11e0a1b11ae1',
      ue = [208, 207, 17, 224, 161, 177, 26, 225],
      j = '00000000000000000000000000000000',
      U = {
        MAXREGSECT: -6,
        DIFSECT: -4,
        FATSECT: -3,
        ENDOFCHAIN: N,
        FREESECT: -1,
        HEADER_SIGNATURE: Q,
        HEADER_MINOR_VERSION: '3e00',
        MAXREGSID: -6,
        NOSTREAM: -1,
        HEADER_CLSID: j,
        EntryTypes: ['unknown', 'storage', 'stream', 'lockbytes', 'property', 'root']
      }
    function X(M, I, V) {
      c()
      var E = T(M, V)
      l.writeFileSync(I, E)
    }
    function oe(M) {
      for (var I = new Array(M.length), V = 0; V < M.length; ++V) I[V] = String.fromCharCode(M[V])
      return I.join('')
    }
    function de(M, I) {
      var V = T(M, I)
      switch ((I && I.type) || 'buffer') {
        case 'file':
          return c(), l.writeFileSync(I.filename, V), V
        case 'binary':
          return typeof V == 'string' ? V : oe(V)
        case 'base64':
          return Hg(typeof V == 'string' ? V : oe(V))
        case 'buffer':
          if (Pt) return Buffer.isBuffer(V) ? V : ks(V)
        case 'array':
          return typeof V == 'string' ? Rs(V) : V
      }
      return V
    }
    var ce
    function Te(M) {
      try {
        var I = M.InflateRaw,
          V = new I()
        if ((V._processChunk(new Uint8Array([3, 0]), V._finishFlushFlag), V.bytesRead)) ce = M
        else throw new Error('zlib does not expose bytesRead')
      } catch (E) {
        console.error('cannot use native zlib: ' + (E.message || E))
      }
    }
    function $e(M, I) {
      if (!ce) return Hh(M, I)
      var V = ce.InflateRaw,
        E = new V(),
        F = E._processChunk(M.slice(M.l), E._finishFlushFlag)
      return (M.l += E.bytesRead), F
    }
    function He(M) {
      return ce ? ce.deflateRawSync(M) : xn(M)
    }
    var Ue = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
      ie = [
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163,
        195, 227, 258
      ],
      Y = [
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073,
        4097, 6145, 8193, 12289, 16385, 24577
      ]
    function ne(M) {
      var I = (((M << 1) | (M << 11)) & 139536) | (((M << 5) | (M << 15)) & 558144)
      return ((I >> 16) | (I >> 8) | I) & 255
    }
    for (var W = typeof Uint8Array < 'u', le = W ? new Uint8Array(256) : [], De = 0; De < 256; ++De)
      le[De] = ne(De)
    function L(M, I) {
      var V = le[M & 255]
      return I <= 8
        ? V >>> (8 - I)
        : ((V = (V << 8) | le[(M >> 8) & 255]),
          I <= 16 ? V >>> (16 - I) : ((V = (V << 8) | le[(M >> 16) & 255]), V >>> (24 - I)))
    }
    function D(M, I) {
      var V = I & 7,
        E = I >>> 3
      return ((M[E] | (V <= 6 ? 0 : M[E + 1] << 8)) >>> V) & 3
    }
    function H(M, I) {
      var V = I & 7,
        E = I >>> 3
      return ((M[E] | (V <= 5 ? 0 : M[E + 1] << 8)) >>> V) & 7
    }
    function Z(M, I) {
      var V = I & 7,
        E = I >>> 3
      return ((M[E] | (V <= 4 ? 0 : M[E + 1] << 8)) >>> V) & 15
    }
    function ae(M, I) {
      var V = I & 7,
        E = I >>> 3
      return ((M[E] | (V <= 3 ? 0 : M[E + 1] << 8)) >>> V) & 31
    }
    function se(M, I) {
      var V = I & 7,
        E = I >>> 3
      return ((M[E] | (V <= 1 ? 0 : M[E + 1] << 8)) >>> V) & 127
    }
    function ye(M, I, V) {
      var E = I & 7,
        F = I >>> 3,
        R = (1 << V) - 1,
        K = M[F] >>> E
      return (
        V < 8 - E ||
          ((K |= M[F + 1] << (8 - E)), V < 16 - E) ||
          ((K |= M[F + 2] << (16 - E)), V < 24 - E) ||
          (K |= M[F + 3] << (24 - E)),
        K & R
      )
    }
    function pe(M, I, V) {
      var E = I & 7,
        F = I >>> 3
      return (
        E <= 5 ? (M[F] |= (V & 7) << E) : ((M[F] |= (V << E) & 255), (M[F + 1] = (V & 7) >> (8 - E))), I + 3
      )
    }
    function _e(M, I, V) {
      var E = I & 7,
        F = I >>> 3
      return (V = (V & 1) << E), (M[F] |= V), I + 1
    }
    function he(M, I, V) {
      var E = I & 7,
        F = I >>> 3
      return (V <<= E), (M[F] |= V & 255), (V >>>= 8), (M[F + 1] = V), I + 8
    }
    function Fe(M, I, V) {
      var E = I & 7,
        F = I >>> 3
      return (V <<= E), (M[F] |= V & 255), (V >>>= 8), (M[F + 1] = V & 255), (M[F + 2] = V >>> 8), I + 16
    }
    function Le(M, I) {
      var V = M.length,
        E = 2 * V > I ? 2 * V : I + 5,
        F = 0
      if (V >= I) return M
      if (Pt) {
        var R = jg(E)
        if (M.copy) M.copy(R)
        else for (; F < M.length; ++F) R[F] = M[F]
        return R
      } else if (W) {
        var K = new Uint8Array(E)
        if (K.set) K.set(M)
        else for (; F < V; ++F) K[F] = M[F]
        return K
      }
      return (M.length = E), M
    }
    function Be(M) {
      for (var I = new Array(M), V = 0; V < M; ++V) I[V] = 0
      return I
    }
    function je(M, I, V) {
      var E = 1,
        F = 0,
        R = 0,
        K = 0,
        re = 0,
        G = M.length,
        q = W ? new Uint16Array(32) : Be(32)
      for (R = 0; R < 32; ++R) q[R] = 0
      for (R = G; R < V; ++R) M[R] = 0
      G = M.length
      var J = W ? new Uint16Array(G) : Be(G)
      for (R = 0; R < G; ++R) q[(F = M[R])]++, E < F && (E = F), (J[R] = 0)
      for (q[0] = 0, R = 1; R <= E; ++R) q[R + 16] = re = (re + q[R - 1]) << 1
      for (R = 0; R < G; ++R) (re = M[R]), re != 0 && (J[R] = q[re + 16]++)
      var me = 0
      for (R = 0; R < G; ++R)
        if (((me = M[R]), me != 0))
          for (re = L(J[R], E) >> (E - me), K = (1 << (E + 4 - me)) - 1; K >= 0; --K)
            I[re | (K << me)] = (me & 15) | (R << 4)
      return E
    }
    var tt = W ? new Uint16Array(512) : Be(512),
      dt = W ? new Uint16Array(32) : Be(32)
    if (!W) {
      for (var it = 0; it < 512; ++it) tt[it] = 0
      for (it = 0; it < 32; ++it) dt[it] = 0
    }
    ;(function () {
      for (var M = [], I = 0; I < 32; I++) M.push(5)
      je(M, dt, 32)
      var V = []
      for (I = 0; I <= 143; I++) V.push(8)
      for (; I <= 255; I++) V.push(9)
      for (; I <= 279; I++) V.push(7)
      for (; I <= 287; I++) V.push(8)
      je(V, tt, 288)
    })()
    var Ot = (function () {
      for (var I = W ? new Uint8Array(32768) : [], V = 0, E = 0; V < Y.length - 1; ++V)
        for (; E < Y[V + 1]; ++E) I[E] = V
      for (; E < 32768; ++E) I[E] = 29
      var F = W ? new Uint8Array(259) : []
      for (V = 0, E = 0; V < ie.length - 1; ++V) for (; E < ie[V + 1]; ++E) F[E] = V
      function R(re, G) {
        for (var q = 0; q < re.length; ) {
          var J = Math.min(65535, re.length - q),
            me = q + J == re.length
          for (G.write_shift(1, +me), G.write_shift(2, J), G.write_shift(2, ~J & 65535); J-- > 0; )
            G[G.l++] = re[q++]
        }
        return G.l
      }
      function K(re, G) {
        for (var q = 0, J = 0, me = W ? new Uint16Array(32768) : []; J < re.length; ) {
          var Ae = Math.min(65535, re.length - J)
          if (Ae < 10) {
            for (
              q = pe(G, q, +(J + Ae == re.length)),
                q & 7 && (q += 8 - (q & 7)),
                G.l = (q / 8) | 0,
                G.write_shift(2, Ae),
                G.write_shift(2, ~Ae & 65535);
              Ae-- > 0;

            )
              G[G.l++] = re[J++]
            q = G.l * 8
            continue
          }
          q = pe(G, q, +(J + Ae == re.length) + 2)
          for (var Ie = 0; Ae-- > 0; ) {
            var be = re[J]
            Ie = ((Ie << 5) ^ be) & 32767
            var Ee = -1,
              qe = 0
            if ((Ee = me[Ie]) && ((Ee |= J & -32768), Ee > J && (Ee -= 32768), Ee < J))
              for (; re[Ee + qe] == re[J + qe] && qe < 250; ) ++qe
            if (qe > 2) {
              ;(be = F[qe]),
                be <= 22
                  ? (q = he(G, q, le[be + 1] >> 1) - 1)
                  : (he(G, q, 3), (q += 5), he(G, q, le[be - 23] >> 5), (q += 3))
              var Mt = be < 8 ? 0 : (be - 4) >> 2
              Mt > 0 && (Fe(G, q, qe - ie[be]), (q += Mt)),
                (be = I[J - Ee]),
                (q = he(G, q, le[be] >> 3)),
                (q -= 3)
              var At = be < 4 ? 0 : (be - 2) >> 1
              At > 0 && (Fe(G, q, J - Ee - Y[be]), (q += At))
              for (var sn = 0; sn < qe; ++sn) (me[Ie] = J & 32767), (Ie = ((Ie << 5) ^ re[J]) & 32767), ++J
              Ae -= qe - 1
            } else
              be <= 143 ? (be = be + 48) : (q = _e(G, q, 1)),
                (q = he(G, q, le[be])),
                (me[Ie] = J & 32767),
                ++J
          }
          q = he(G, q, 0) - 1
        }
        return (G.l = ((q + 7) / 8) | 0), G.l
      }
      return function (G, q) {
        return G.length < 8 ? R(G, q) : K(G, q)
      }
    })()
    function xn(M) {
      var I = Ri(50 + Math.floor(M.length * 1.1)),
        V = Ot(M, I)
      return I.slice(0, V)
    }
    var Ii = W ? new Uint16Array(32768) : Be(32768),
      Co = W ? new Uint16Array(32768) : Be(32768),
      ca = W ? new Uint16Array(128) : Be(128),
      Mo = 1,
      an = 1
    function Nn(M, I) {
      var V = ae(M, I) + 257
      I += 5
      var E = ae(M, I) + 1
      I += 5
      var F = Z(M, I) + 4
      I += 4
      for (
        var R = 0,
          K = W ? new Uint8Array(19) : Be(19),
          re = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          G = 1,
          q = W ? new Uint8Array(8) : Be(8),
          J = W ? new Uint8Array(8) : Be(8),
          me = K.length,
          Ae = 0;
        Ae < F;
        ++Ae
      )
        (K[Ue[Ae]] = R = H(M, I)), G < R && (G = R), q[R]++, (I += 3)
      var Ie = 0
      for (q[0] = 0, Ae = 1; Ae <= G; ++Ae) J[Ae] = Ie = (Ie + q[Ae - 1]) << 1
      for (Ae = 0; Ae < me; ++Ae) (Ie = K[Ae]) != 0 && (re[Ae] = J[Ie]++)
      var be = 0
      for (Ae = 0; Ae < me; ++Ae)
        if (((be = K[Ae]), be != 0)) {
          Ie = le[re[Ae]] >> (8 - be)
          for (var Ee = (1 << (7 - be)) - 1; Ee >= 0; --Ee) ca[Ie | (Ee << be)] = (be & 7) | (Ae << 3)
        }
      var qe = []
      for (G = 1; qe.length < V + E; )
        switch (((Ie = ca[se(M, I)]), (I += Ie & 7), (Ie >>>= 3))) {
          case 16:
            for (R = 3 + D(M, I), I += 2, Ie = qe[qe.length - 1]; R-- > 0; ) qe.push(Ie)
            break
          case 17:
            for (R = 3 + H(M, I), I += 3; R-- > 0; ) qe.push(0)
            break
          case 18:
            for (R = 11 + se(M, I), I += 7; R-- > 0; ) qe.push(0)
            break
          default:
            qe.push(Ie), G < Ie && (G = Ie)
            break
        }
      var Mt = qe.slice(0, V),
        At = qe.slice(V)
      for (Ae = V; Ae < 286; ++Ae) Mt[Ae] = 0
      for (Ae = E; Ae < 30; ++Ae) At[Ae] = 0
      return (Mo = je(Mt, Ii, 286)), (an = je(At, Co, 30)), I
    }
    function el(M, I) {
      if (M[0] == 3 && !(M[1] & 3)) return [no(I), 2]
      for (var V = 0, E = 0, F = jg(I || 1 << 18), R = 0, K = F.length >>> 0, re = 0, G = 0; !(E & 1); ) {
        if (((E = H(M, V)), (V += 3), E >>> 1))
          E >> 1 == 1 ? ((re = 9), (G = 5)) : ((V = Nn(M, V)), (re = Mo), (G = an))
        else {
          V & 7 && (V += 8 - (V & 7))
          var q = M[V >>> 3] | (M[(V >>> 3) + 1] << 8)
          if (((V += 32), q > 0))
            for (!I && K < R + q && ((F = Le(F, R + q)), (K = F.length)); q-- > 0; )
              (F[R++] = M[V >>> 3]), (V += 8)
          continue
        }
        for (;;) {
          !I && K < R + 32767 && ((F = Le(F, R + 32767)), (K = F.length))
          var J = ye(M, V, re),
            me = E >>> 1 == 1 ? tt[J] : Ii[J]
          if (((V += me & 15), (me >>>= 4), !((me >>> 8) & 255))) F[R++] = me
          else {
            if (me == 256) break
            me -= 257
            var Ae = me < 8 ? 0 : (me - 4) >> 2
            Ae > 5 && (Ae = 0)
            var Ie = R + ie[me]
            Ae > 0 && ((Ie += ye(M, V, Ae)), (V += Ae)),
              (J = ye(M, V, G)),
              (me = E >>> 1 == 1 ? dt[J] : Co[J]),
              (V += me & 15),
              (me >>>= 4)
            var be = me < 4 ? 0 : (me - 2) >> 1,
              Ee = Y[me]
            for (
              be > 0 && ((Ee += ye(M, V, be)), (V += be)),
                !I && K < Ie && ((F = Le(F, Ie + 100)), (K = F.length));
              R < Ie;

            )
              (F[R] = F[R - Ee]), ++R
          }
        }
      }
      return I ? [F, (V + 7) >>> 3] : [F.slice(0, R), (V + 7) >>> 3]
    }
    function Hh(M, I) {
      var V = M.slice(M.l || 0),
        E = el(V, I)
      return (M.l += E[1]), E[0]
    }
    function Wh(M, I) {
      if (M) typeof console < 'u' && console.error(I)
      else throw new Error(I)
    }
    function jh(M, I) {
      var V = M
      va(V, 0)
      var E = [],
        F = [],
        R = { FileIndex: E, FullPaths: F }
      k(R, { root: I.root })
      for (var K = V.length - 4; (V[K] != 80 || V[K + 1] != 75 || V[K + 2] != 5 || V[K + 3] != 6) && K >= 0; )
        --K
      ;(V.l = K + 4), (V.l += 4)
      var re = V.read_shift(2)
      V.l += 6
      var G = V.read_shift(4)
      for (V.l = G, K = 0; K < re; ++K) {
        V.l += 20
        var q = V.read_shift(4),
          J = V.read_shift(4),
          me = V.read_shift(2),
          Ae = V.read_shift(2),
          Ie = V.read_shift(2)
        V.l += 8
        var be = V.read_shift(4),
          Ee = r(V.slice(V.l + me, V.l + me + Ae))
        V.l += me + Ae + Ie
        var qe = V.l
        ;(V.l = be + 4), ax(V, q, J, R, Ee), (V.l = qe)
      }
      return R
    }
    function ax(M, I, V, E, F) {
      M.l += 2
      var R = M.read_shift(2),
        K = M.read_shift(2),
        re = o(M)
      if (R & 8257) throw new Error('Unsupported ZIP encryption')
      for (
        var G = M.read_shift(4),
          q = M.read_shift(4),
          J = M.read_shift(4),
          me = M.read_shift(2),
          Ae = M.read_shift(2),
          Ie = '',
          be = 0;
        be < me;
        ++be
      )
        Ie += String.fromCharCode(M[M.l++])
      if (Ae) {
        var Ee = r(M.slice(M.l, M.l + Ae))
        ;(Ee[21589] || {}).mt && (re = Ee[21589].mt), ((F || {})[21589] || {}).mt && (re = F[21589].mt)
      }
      M.l += Ae
      var qe = M.slice(M.l, M.l + q)
      switch (K) {
        case 8:
          qe = $e(M, J)
          break
        case 0:
          break
        default:
          throw new Error('Unsupported ZIP Compression method ' + K)
      }
      var Mt = !1
      R & 8 &&
        ((G = M.read_shift(4)),
        G == 134695760 && ((G = M.read_shift(4)), (Mt = !0)),
        (q = M.read_shift(4)),
        (J = M.read_shift(4))),
        q != I && Wh(Mt, 'Bad compressed size: ' + I + ' != ' + q),
        J != V && Wh(Mt, 'Bad uncompressed size: ' + V + ' != ' + J),
        cu(E, Ie, qe, { unsafe: !0, mt: re })
    }
    function sx(M, I) {
      var V = I || {},
        E = [],
        F = [],
        R = Ri(1),
        K = V.compression ? 8 : 0,
        re = 0,
        G = 0,
        q = 0,
        J = 0,
        me = 0,
        Ae = M.FullPaths[0],
        Ie = Ae,
        be = M.FileIndex[0],
        Ee = [],
        qe = 0
      for (G = 1; G < M.FullPaths.length; ++G)
        if (
          ((Ie = M.FullPaths[G].slice(Ae.length)),
          (be = M.FileIndex[G]),
          !(!be.size || !be.content || Ie == 'Sh33tJ5'))
        ) {
          var Mt = J,
            At = Ri(Ie.length)
          for (q = 0; q < Ie.length; ++q) At.write_shift(1, Ie.charCodeAt(q) & 127)
          ;(At = At.slice(0, At.l)), (Ee[me] = tL.buf(be.content, 0))
          var sn = be.content
          K == 8 && (sn = He(sn)),
            (R = Ri(30)),
            R.write_shift(4, 67324752),
            R.write_shift(2, 20),
            R.write_shift(2, re),
            R.write_shift(2, K),
            be.mt ? s(R, be.mt) : R.write_shift(4, 0),
            R.write_shift(-4, Ee[me]),
            R.write_shift(4, sn.length),
            R.write_shift(4, be.content.length),
            R.write_shift(2, At.length),
            R.write_shift(2, 0),
            (J += R.length),
            E.push(R),
            (J += At.length),
            E.push(At),
            (J += sn.length),
            E.push(sn),
            (R = Ri(46)),
            R.write_shift(4, 33639248),
            R.write_shift(2, 0),
            R.write_shift(2, 20),
            R.write_shift(2, re),
            R.write_shift(2, K),
            R.write_shift(4, 0),
            R.write_shift(-4, Ee[me]),
            R.write_shift(4, sn.length),
            R.write_shift(4, be.content.length),
            R.write_shift(2, At.length),
            R.write_shift(2, 0),
            R.write_shift(2, 0),
            R.write_shift(2, 0),
            R.write_shift(2, 0),
            R.write_shift(4, 0),
            R.write_shift(4, Mt),
            (qe += R.l),
            F.push(R),
            (qe += At.length),
            F.push(At),
            ++me
        }
      return (
        (R = Ri(22)),
        R.write_shift(4, 101010256),
        R.write_shift(2, 0),
        R.write_shift(2, 0),
        R.write_shift(2, me),
        R.write_shift(2, me),
        R.write_shift(4, qe),
        R.write_shift(4, J),
        R.write_shift(2, 0),
        Bs([Bs(E), Bs(F), R])
      )
    }
    var tl = {
      htm: 'text/html',
      xml: 'text/xml',
      gif: 'image/gif',
      jpg: 'image/jpeg',
      png: 'image/png',
      mso: 'application/x-mso',
      thmx: 'application/vnd.ms-officetheme',
      sh33tj5: 'application/octet-stream'
    }
    function ox(M, I) {
      if (M.ctype) return M.ctype
      var V = M.name || '',
        E = V.match(/\.([^\.]+)$/)
      return (E && tl[E[1]]) || (I && ((E = (V = I).match(/[\.\\]([^\.\\])+$/)), E && tl[E[1]]))
        ? tl[E[1]]
        : 'application/octet-stream'
    }
    function rx(M) {
      for (var I = Hg(M), V = [], E = 0; E < I.length; E += 76) V.push(I.slice(E, E + 76))
      return (
        V.join(`\r
`) +
        `\r
`
      )
    }
    function lx(M) {
      var I = M.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function (q) {
        var J = q.charCodeAt(0).toString(16).toUpperCase()
        return '=' + (J.length == 1 ? '0' + J : J)
      })
      ;(I = I.replace(/ $/gm, '=20').replace(/\t$/gm, '=09')),
        I.charAt(0) ==
          `
` && (I = '=0D' + I.slice(1)),
        (I = I.replace(/\r(?!\n)/gm, '=0D')
          .replace(
            /\n\n/gm,
            `
=0A`
          )
          .replace(/([^\r\n])\n/gm, '$1=0A'))
      for (
        var V = [],
          E = I.split(`\r
`),
          F = 0;
        F < E.length;
        ++F
      ) {
        var R = E[F]
        if (R.length == 0) {
          V.push('')
          continue
        }
        for (var K = 0; K < R.length; ) {
          var re = 76,
            G = R.slice(K, K + re)
          G.charAt(re - 1) == '='
            ? re--
            : G.charAt(re - 2) == '='
            ? (re -= 2)
            : G.charAt(re - 3) == '=' && (re -= 3),
            (G = R.slice(K, K + re)),
            (K += re),
            K < R.length && (G += '='),
            V.push(G)
        }
      }
      return V.join(`\r
`)
    }
    function cx(M) {
      for (var I = [], V = 0; V < M.length; ++V) {
        for (var E = M[V]; V <= M.length && E.charAt(E.length - 1) == '='; )
          E = E.slice(0, E.length - 1) + M[++V]
        I.push(E)
      }
      for (var F = 0; F < I.length; ++F)
        I[F] = I[F].replace(/[=][0-9A-Fa-f]{2}/g, function (R) {
          return String.fromCharCode(parseInt(R.slice(1), 16))
        })
      return Rs(
        I.join(`\r
`)
      )
    }
    function ux(M, I, V) {
      for (var E = '', F = '', R = '', K, re = 0; re < 10; ++re) {
        var G = I[re]
        if (!G || G.match(/^\s*$/)) break
        var q = G.match(/^(.*?):\s*([^\s].*)$/)
        if (q)
          switch (q[1].toLowerCase()) {
            case 'content-location':
              E = q[2].trim()
              break
            case 'content-type':
              R = q[2].trim()
              break
            case 'content-transfer-encoding':
              F = q[2].trim()
              break
          }
      }
      switch ((++re, F.toLowerCase())) {
        case 'base64':
          K = Rs(Wg(I.slice(re).join('')))
          break
        case 'quoted-printable':
          K = cx(I.slice(re))
          break
        default:
          throw new Error('Unsupported Content-Transfer-Encoding ' + F)
      }
      var J = cu(M, E.slice(V.length), K, { unsafe: !0 })
      R && (J.ctype = R)
    }
    function dx(M, I) {
      if (oe(M.slice(0, 13)).toLowerCase() != 'mime-version:') throw new Error('Unsupported MAD header')
      var V = (I && I.root) || '',
        E = (Pt && Buffer.isBuffer(M) ? M.toString('binary') : oe(M)).split(`\r
`),
        F = 0,
        R = ''
      for (F = 0; F < E.length; ++F)
        if (
          ((R = E[F]),
          !!/^Content-Location:/i.test(R) &&
            ((R = R.slice(R.indexOf('file'))),
            V || (V = R.slice(0, R.lastIndexOf('/') + 1)),
            R.slice(0, V.length) != V))
        )
          for (
            ;
            V.length > 0 &&
            ((V = V.slice(0, V.length - 1)),
            (V = V.slice(0, V.lastIndexOf('/') + 1)),
            R.slice(0, V.length) != V);

          );
      var K = (E[1] || '').match(/boundary="(.*?)"/)
      if (!K) throw new Error('MAD cannot find boundary')
      var re = '--' + (K[1] || ''),
        G = [],
        q = [],
        J = { FileIndex: G, FullPaths: q }
      k(J)
      var me,
        Ae = 0
      for (F = 0; F < E.length; ++F) {
        var Ie = E[F]
        ;(Ie !== re && Ie !== re + '--') || (Ae++ && ux(J, E.slice(me, F), V), (me = F))
      }
      return J
    }
    function fx(M, I) {
      var V = I || {},
        E = V.boundary || 'SheetJS'
      E = '------=' + E
      for (
        var F = [
            'MIME-Version: 1.0',
            'Content-Type: multipart/related; boundary="' + E.slice(2) + '"',
            '',
            '',
            ''
          ],
          R = M.FullPaths[0],
          K = R,
          re = M.FileIndex[0],
          G = 1;
        G < M.FullPaths.length;
        ++G
      )
        if (
          ((K = M.FullPaths[G].slice(R.length)),
          (re = M.FileIndex[G]),
          !(!re.size || !re.content || K == 'Sh33tJ5'))
        ) {
          K = K.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function (qe) {
            return '_x' + qe.charCodeAt(0).toString(16) + '_'
          }).replace(/[\u0080-\uFFFF]/g, function (qe) {
            return '_u' + qe.charCodeAt(0).toString(16) + '_'
          })
          for (
            var q = re.content,
              J = Pt && Buffer.isBuffer(q) ? q.toString('binary') : oe(q),
              me = 0,
              Ae = Math.min(1024, J.length),
              Ie = 0,
              be = 0;
            be <= Ae;
            ++be
          )
            (Ie = J.charCodeAt(be)) >= 32 && Ie < 128 && ++me
          var Ee = me >= (Ae * 4) / 5
          F.push(E),
            F.push('Content-Location: ' + (V.root || 'file:///C:/SheetJS/') + K),
            F.push('Content-Transfer-Encoding: ' + (Ee ? 'quoted-printable' : 'base64')),
            F.push('Content-Type: ' + ox(re, K)),
            F.push(''),
            F.push(Ee ? lx(J) : rx(J))
        }
      return (
        F.push(
          E +
            `--\r
`
        ),
        F.join(`\r
`)
      )
    }
    function hx(M) {
      var I = {}
      return k(I, M), I
    }
    function cu(M, I, V, E) {
      var F = E && E.unsafe
      F || k(M)
      var R = !F && ti.find(M, I)
      if (!R) {
        var K = M.FullPaths[0]
        I.slice(0, K.length) == K
          ? (K = I)
          : (K.slice(-1) != '/' && (K += '/'), (K = (K + I).replace('//', '/'))),
          (R = { name: a(I), type: 2 }),
          M.FileIndex.push(R),
          M.FullPaths.push(K),
          F || ti.utils.cfb_gc(M)
      }
      return (
        (R.content = V),
        (R.size = V ? V.length : 0),
        E && (E.CLSID && (R.clsid = E.CLSID), E.mt && (R.mt = E.mt), E.ct && (R.ct = E.ct)),
        R
      )
    }
    function vx(M, I) {
      k(M)
      var V = ti.find(M, I)
      if (V) {
        for (var E = 0; E < M.FileIndex.length; ++E)
          if (M.FileIndex[E] == V) return M.FileIndex.splice(E, 1), M.FullPaths.splice(E, 1), !0
      }
      return !1
    }
    function gx(M, I, V) {
      k(M)
      var E = ti.find(M, I)
      if (E) {
        for (var F = 0; F < M.FileIndex.length; ++F)
          if (M.FileIndex[F] == E) return (M.FileIndex[F].name = a(V)), (M.FullPaths[F] = V), !0
      }
      return !1
    }
    function mx(M) {
      _(M, !0)
    }
    return (
      (t.find = B),
      (t.read = P),
      (t.parse = u),
      (t.write = de),
      (t.writeFile = X),
      (t.utils = {
        cfb_new: hx,
        cfb_add: cu,
        cfb_del: vx,
        cfb_mov: gx,
        cfb_gc: mx,
        ReadShift: or,
        CheckField: Y1,
        prep_blob: va,
        bconcat: Bs,
        use_zlib: Te,
        _deflateRaw: xn,
        _inflateRaw: Hh,
        consts: U
      }),
      t
    )
  })()
function nL(e) {
  return typeof e == 'string' ? tu(e) : Array.isArray(e) ? AE(e) : e
}
function A1(e, t, n) {
  if (typeof Deno < 'u') {
    if (n && typeof t == 'string')
      switch (n) {
        case 'utf8':
          t = new TextEncoder(n).encode(t)
          break
        case 'binary':
          t = tu(t)
          break
        default:
          throw new Error('Unsupported encoding ' + n)
      }
    return Deno.writeFileSync(e, t)
  }
  var i = n == 'utf8' ? E1(t) : t
  if (typeof IE_SaveFile < 'u') return IE_SaveFile(i, e)
  if (typeof Blob < 'u') {
    var a = new Blob([nL(i)], { type: 'application/octet-stream' })
    if (typeof navigator < 'u' && navigator.msSaveBlob) return navigator.msSaveBlob(a, e)
    if (typeof saveAs < 'u') return saveAs(a, e)
    if (typeof URL < 'u' && typeof document < 'u' && document.createElement && URL.createObjectURL) {
      var s = URL.createObjectURL(a)
      if (typeof chrome == 'object' && typeof (chrome.downloads || {}).download == 'function')
        return (
          URL.revokeObjectURL &&
            typeof setTimeout < 'u' &&
            setTimeout(function () {
              URL.revokeObjectURL(s)
            }, 6e4),
          chrome.downloads.download({ url: s, filename: e, saveAs: !0 })
        )
      var o = document.createElement('a')
      if (o.download != null)
        return (
          (o.download = e),
          (o.href = s),
          document.body.appendChild(o),
          o.click(),
          document.body.removeChild(o),
          URL.revokeObjectURL &&
            typeof setTimeout < 'u' &&
            setTimeout(function () {
              URL.revokeObjectURL(s)
            }, 6e4),
          s
        )
    }
  }
  if (typeof $ < 'u' && typeof File < 'u' && typeof Folder < 'u')
    try {
      var r = File(e)
      return r.open('w'), (r.encoding = 'binary'), Array.isArray(t) && (t = ME(t)), r.write(t), r.close(), t
    } catch (l) {
      if (!l.message || !l.message.match(/onstruct/)) throw l
    }
  throw new Error('cannot save file ' + e)
}
function Ra(e) {
  for (var t = Object.keys(e), n = [], i = 0; i < t.length; ++i)
    Object.prototype.hasOwnProperty.call(e, t[i]) && n.push(t[i])
  return n
}
function iL(e) {
  for (var t = [], n = Ra(e), i = 0; i !== n.length; ++i) t[e[n[i]]] = n[i]
  return t
}
function aL(e) {
  for (var t = [], n = Ra(e), i = 0; i !== n.length; ++i) t[e[n[i]]] = parseInt(n[i], 10)
  return t
}
function sL(e) {
  for (var t = [], n = Ra(e), i = 0; i !== n.length; ++i)
    t[e[n[i]]] == null && (t[e[n[i]]] = []), t[e[n[i]]].push(n[i])
  return t
}
var Jg = new Date(1899, 11, 30, 0, 0, 0)
function gs(e, t) {
  var n = e.getTime()
  t && (n -= 1462 * 24 * 60 * 60 * 1e3)
  var i = Jg.getTime() + (e.getTimezoneOffset() - Jg.getTimezoneOffset()) * 6e4
  return (n - i) / (24 * 60 * 60 * 1e3)
}
var Qg = new Date('2017-02-19T19:06:09.000Z'),
  P1 = isNaN(Qg.getFullYear()) ? new Date('2/19/17') : Qg,
  oL = P1.getFullYear() == 2017
function Wd(e, t) {
  var n = new Date(e)
  if (oL)
    return (
      t > 0
        ? n.setTime(n.getTime() + n.getTimezoneOffset() * 60 * 1e3)
        : t < 0 && n.setTime(n.getTime() - n.getTimezoneOffset() * 60 * 1e3),
      n
    )
  if (e instanceof Date) return e
  if (P1.getFullYear() == 1917 && !isNaN(n.getFullYear())) {
    var i = n.getFullYear()
    return e.indexOf('' + i) > -1 || n.setFullYear(n.getFullYear() + 100), n
  }
  var a = e.match(/\d+/g) || ['2017', '2', '19', '0', '0', '0'],
    s = new Date(+a[0], +a[1] - 1, +a[2], +a[3] || 0, +a[4] || 0, +a[5] || 0)
  return e.indexOf('Z') > -1 && (s = new Date(s.getTime() - s.getTimezoneOffset() * 60 * 1e3)), s
}
function Xr(e) {
  if (typeof JSON < 'u' && !Array.isArray(e)) return JSON.parse(JSON.stringify(e))
  if (typeof e != 'object' || e == null) return e
  if (e instanceof Date) return new Date(e.getTime())
  var t = {}
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = Xr(e[n]))
  return t
}
function Cn(e, t) {
  for (var n = ''; n.length < t; ) n += e
  return n
}
function em(e) {
  var t = Number(e)
  if (!isNaN(t)) return isFinite(t) ? t : NaN
  if (!/\d/.test(e)) return t
  var n = 1,
    i = e
      .replace(/([\d]),([\d])/g, '$1$2')
      .replace(/[$]/g, '')
      .replace(/[%]/g, function () {
        return (n *= 100), ''
      })
  return !isNaN((t = Number(i))) ||
    ((i = i.replace(/[(](.*)[)]/, function (a, s) {
      return (n = -n), s
    })),
    !isNaN((t = Number(i))))
    ? t / n
    : t
}
var rL = [
  'january',
  'february',
  'march',
  'april',
  'may',
  'june',
  'july',
  'august',
  'september',
  'october',
  'november',
  'december'
]
function lL(e) {
  var t = new Date(e),
    n = new Date(NaN),
    i = t.getYear(),
    a = t.getMonth(),
    s = t.getDate()
  if (isNaN(s)) return n
  var o = e.toLowerCase()
  if (o.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
    if (
      ((o = o.replace(/[^a-z]/g, '').replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, '')),
      o.length > 3 && rL.indexOf(o) == -1)
    )
      return n
  } else if (o.match(/[a-z]/)) return n
  return i < 0 || i > 8099 ? n : (a > 0 || s > 1) && i != 101 ? t : e.match(/[^-0-9:,\/\\]/) ? n : t
}
function Xt(e, t, n) {
  if (e.FullPaths) {
    if (typeof n == 'string') {
      var i
      return Pt ? (i = ks(n)) : (i = PE(n)), ti.utils.cfb_add(e, t, i)
    }
    ti.utils.cfb_add(e, t, n)
  } else e.file(t, n)
}
function cL() {
  return ti.utils.cfb_new()
}
var Pn = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r
`,
  uL = { '&quot;': '"', '&apos;': "'", '&gt;': '>', '&lt;': '<', '&amp;': '&' },
  T1 = iL(uL),
  V1 = /[&<>'"]/g,
  dL = /[\u0000-\u0008\u000b-\u001f]/g
function $t(e) {
  var t = e + ''
  return t
    .replace(V1, function (n) {
      return T1[n]
    })
    .replace(dL, function (n) {
      return '_x' + ('000' + n.charCodeAt(0).toString(16)).slice(-4) + '_'
    })
}
var fL = /[\u0000-\u001f]/g
function hL(e) {
  var t = e + ''
  return t
    .replace(V1, function (n) {
      return T1[n]
    })
    .replace(/\n/g, '<br/>')
    .replace(fL, function (n) {
      return '&#x' + ('000' + n.charCodeAt(0).toString(16)).slice(-4) + ';'
    })
}
function Eu(e) {
  for (var t = '', n = 0, i = 0, a = 0, s = 0, o = 0, r = 0; n < e.length; ) {
    if (((i = e.charCodeAt(n++)), i < 128)) {
      t += String.fromCharCode(i)
      continue
    }
    if (((a = e.charCodeAt(n++)), i > 191 && i < 224)) {
      ;(o = (i & 31) << 6), (o |= a & 63), (t += String.fromCharCode(o))
      continue
    }
    if (((s = e.charCodeAt(n++)), i < 240)) {
      t += String.fromCharCode(((i & 15) << 12) | ((a & 63) << 6) | (s & 63))
      continue
    }
    ;(o = e.charCodeAt(n++)),
      (r = (((i & 7) << 18) | ((a & 63) << 12) | ((s & 63) << 6) | (o & 63)) - 65536),
      (t += String.fromCharCode(55296 + ((r >>> 10) & 1023))),
      (t += String.fromCharCode(56320 + (r & 1023)))
  }
  return t
}
function tm(e) {
  var t = no(2 * e.length),
    n,
    i,
    a = 1,
    s = 0,
    o = 0,
    r
  for (i = 0; i < e.length; i += a)
    (a = 1),
      (r = e.charCodeAt(i)) < 128
        ? (n = r)
        : r < 224
        ? ((n = (r & 31) * 64 + (e.charCodeAt(i + 1) & 63)), (a = 2))
        : r < 240
        ? ((n = (r & 15) * 4096 + (e.charCodeAt(i + 1) & 63) * 64 + (e.charCodeAt(i + 2) & 63)), (a = 3))
        : ((a = 4),
          (n =
            (r & 7) * 262144 +
            (e.charCodeAt(i + 1) & 63) * 4096 +
            (e.charCodeAt(i + 2) & 63) * 64 +
            (e.charCodeAt(i + 3) & 63)),
          (n -= 65536),
          (o = 55296 + ((n >>> 10) & 1023)),
          (n = 56320 + (n & 1023))),
      o !== 0 && ((t[s++] = o & 255), (t[s++] = o >>> 8), (o = 0)),
      (t[s++] = n % 256),
      (t[s++] = n >>> 8)
  return t.slice(0, s).toString('ucs2')
}
function nm(e) {
  return ks(e, 'binary').toString('utf8')
}
var ml = 'foo bar bazâð£',
  vL = (Pt && ((nm(ml) == Eu(ml) && nm) || (tm(ml) == Eu(ml) && tm))) || Eu,
  E1 = Pt
    ? function (e) {
        return ks(e, 'utf8').toString('binary')
      }
    : function (e) {
        for (var t = [], n = 0, i = 0, a = 0; n < e.length; )
          switch (((i = e.charCodeAt(n++)), !0)) {
            case i < 128:
              t.push(String.fromCharCode(i))
              break
            case i < 2048:
              t.push(String.fromCharCode(192 + (i >> 6))), t.push(String.fromCharCode(128 + (i & 63)))
              break
            case i >= 55296 && i < 57344:
              ;(i -= 55296),
                (a = e.charCodeAt(n++) - 56320 + (i << 10)),
                t.push(String.fromCharCode(240 + ((a >> 18) & 7))),
                t.push(String.fromCharCode(144 + ((a >> 12) & 63))),
                t.push(String.fromCharCode(128 + ((a >> 6) & 63))),
                t.push(String.fromCharCode(128 + (a & 63)))
              break
            default:
              t.push(String.fromCharCode(224 + (i >> 12))),
                t.push(String.fromCharCode(128 + ((i >> 6) & 63))),
                t.push(String.fromCharCode(128 + (i & 63)))
          }
        return t.join('')
      },
  gL = (function () {
    var e = [
      ['nbsp', ' '],
      ['middot', '·'],
      ['quot', '"'],
      ['apos', "'"],
      ['gt', '>'],
      ['lt', '<'],
      ['amp', '&']
    ].map(function (t) {
      return [new RegExp('&' + t[0] + ';', 'ig'), t[1]]
    })
    return function (n) {
      for (
        var i = n
            .replace(/^[\t\n\r ]+/, '')
            .replace(/[\t\n\r ]+$/, '')
            .replace(/>\s+/g, '>')
            .replace(/\s+</g, '<')
            .replace(/[\t\n\r ]+/g, ' ')
            .replace(
              /<\s*[bB][rR]\s*\/?>/g,
              `
`
            )
            .replace(/<[^>]*>/g, ''),
          a = 0;
        a < e.length;
        ++a
      )
        i = i.replace(e[a][0], e[a][1])
      return i
    }
  })(),
  L1 = /(^\s|\s$|\n)/
function si(e, t) {
  return '<' + e + (t.match(L1) ? ' xml:space="preserve"' : '') + '>' + t + '</' + e + '>'
}
function O1(e) {
  return Ra(e)
    .map(function (t) {
      return ' ' + t + '="' + e[t] + '"'
    })
    .join('')
}
function Ne(e, t, n) {
  return (
    '<' +
    e +
    (n != null ? O1(n) : '') +
    (t != null ? (t.match(L1) ? ' xml:space="preserve"' : '') + '>' + t + '</' + e : '/') +
    '>'
  )
}
function jd(e, t) {
  try {
    return e.toISOString().replace(/\.\d*/, '')
  } catch (n) {
    if (t) throw n
  }
  return ''
}
function mL(e, t) {
  switch (typeof e) {
    case 'string':
      var n = Ne('vt:lpwstr', $t(e))
      return t && (n = n.replace(/&quot;/g, '_x0022_')), n
    case 'number':
      return Ne((e | 0) == e ? 'vt:i4' : 'vt:r8', $t(String(e)))
    case 'boolean':
      return Ne('vt:bool', e ? 'true' : 'false')
  }
  if (e instanceof Date) return Ne('vt:filetime', jd(e))
  throw new Error('Unable to serialize ' + e)
}
var qt = {
    CORE_PROPS: 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties',
    CUST_PROPS: 'http://schemas.openxmlformats.org/officeDocument/2006/custom-properties',
    EXT_PROPS: 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties',
    CT: 'http://schemas.openxmlformats.org/package/2006/content-types',
    RELS: 'http://schemas.openxmlformats.org/package/2006/relationships',
    TCMNT: 'http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments',
    dc: 'http://purl.org/dc/elements/1.1/',
    dcterms: 'http://purl.org/dc/terms/',
    dcmitype: 'http://purl.org/dc/dcmitype/',
    mx: 'http://schemas.microsoft.com/office/mac/excel/2008/main',
    r: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
    sjs: 'http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties',
    vt: 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',
    xsi: 'http://www.w3.org/2001/XMLSchema-instance',
    xsd: 'http://www.w3.org/2001/XMLSchema'
  },
  So = [
    'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
    'http://purl.oclc.org/ooxml/spreadsheetml/main',
    'http://schemas.microsoft.com/office/excel/2006/main',
    'http://schemas.microsoft.com/office/excel/2006/2'
  ],
  pl = {
    o: 'urn:schemas-microsoft-com:office:office',
    x: 'urn:schemas-microsoft-com:office:excel',
    ss: 'urn:schemas-microsoft-com:office:spreadsheet',
    dt: 'uuid:C2F41010-65B3-11d1-A29F-00AA00C14882',
    mv: 'http://macVmlSchemaUri',
    v: 'urn:schemas-microsoft-com:vml',
    html: 'http://www.w3.org/TR/REC-html40'
  }
function pL(e, t) {
  for (
    var n = 1 - 2 * (e[t + 7] >>> 7),
      i = ((e[t + 7] & 127) << 4) + ((e[t + 6] >>> 4) & 15),
      a = e[t + 6] & 15,
      s = 5;
    s >= 0;
    --s
  )
    a = a * 256 + e[t + s]
  return i == 2047
    ? a == 0
      ? n * (1 / 0)
      : NaN
    : (i == 0 ? (i = -1022) : ((i -= 1023), (a += Math.pow(2, 52))), n * Math.pow(2, i - 52) * a)
}
function yL(e, t, n) {
  var i = (t < 0 || 1 / t == -1 / 0 ? 1 : 0) << 7,
    a = 0,
    s = 0,
    o = i ? -t : t
  isFinite(o)
    ? o == 0
      ? (a = s = 0)
      : ((a = Math.floor(Math.log(o) / Math.LN2)),
        (s = o * Math.pow(2, 52 - a)),
        a <= -1023 && (!isFinite(s) || s < Math.pow(2, 52))
          ? (a = -1022)
          : ((s -= Math.pow(2, 52)), (a += 1023)))
    : ((a = 2047), (s = isNaN(t) ? 26985 : 0))
  for (var r = 0; r <= 5; ++r, s /= 256) e[n + r] = s & 255
  ;(e[n + 6] = ((a & 15) << 4) | (s & 15)), (e[n + 7] = (a >> 4) | i)
}
var im = function (e) {
    for (var t = [], n = 10240, i = 0; i < e[0].length; ++i)
      if (e[0][i]) for (var a = 0, s = e[0][i].length; a < s; a += n) t.push.apply(t, e[0][i].slice(a, a + n))
    return t
  },
  am = Pt
    ? function (e) {
        return e[0].length > 0 && Buffer.isBuffer(e[0][0])
          ? Buffer.concat(
              e[0].map(function (t) {
                return Buffer.isBuffer(t) ? t : ks(t)
              })
            )
          : im(e)
      }
    : im,
  sm = function (e, t, n) {
    for (var i = [], a = t; a < n; a += 2) i.push(String.fromCharCode(Wo(e, a)))
    return i.join('').replace(sr, '')
  },
  xh = Pt
    ? function (e, t, n) {
        return Buffer.isBuffer(e) ? e.toString('utf16le', t, n).replace(sr, '') : sm(e, t, n)
      }
    : sm,
  om = function (e, t, n) {
    for (var i = [], a = t; a < t + n; ++a) i.push(('0' + e[a].toString(16)).slice(-2))
    return i.join('')
  },
  I1 = Pt
    ? function (e, t, n) {
        return Buffer.isBuffer(e) ? e.toString('hex', t, t + n) : om(e, t, n)
      }
    : om,
  rm = function (e, t, n) {
    for (var i = [], a = t; a < n; a++) i.push(String.fromCharCode(Ns(e, a)))
    return i.join('')
  },
  Kr = Pt
    ? function (t, n, i) {
        return Buffer.isBuffer(t) ? t.toString('utf8', n, i) : rm(t, n, i)
      }
    : rm,
  D1 = function (e, t) {
    var n = Ln(e, t)
    return n > 0 ? Kr(e, t + 4, t + 4 + n - 1) : ''
  },
  F1 = D1,
  R1 = function (e, t) {
    var n = Ln(e, t)
    return n > 0 ? Kr(e, t + 4, t + 4 + n - 1) : ''
  },
  B1 = R1,
  N1 = function (e, t) {
    var n = 2 * Ln(e, t)
    return n > 0 ? Kr(e, t + 4, t + 4 + n - 1) : ''
  },
  $1 = N1,
  z1 = function (t, n) {
    var i = Ln(t, n)
    return i > 0 ? xh(t, n + 4, n + 4 + i) : ''
  },
  H1 = z1,
  W1 = function (e, t) {
    var n = Ln(e, t)
    return n > 0 ? Kr(e, t + 4, t + 4 + n) : ''
  },
  j1 = W1,
  U1 = function (e, t) {
    return pL(e, t)
  },
  Ud = U1
Pt &&
  ((F1 = function (t, n) {
    if (!Buffer.isBuffer(t)) return D1(t, n)
    var i = t.readUInt32LE(n)
    return i > 0 ? t.toString('utf8', n + 4, n + 4 + i - 1) : ''
  }),
  (B1 = function (t, n) {
    if (!Buffer.isBuffer(t)) return R1(t, n)
    var i = t.readUInt32LE(n)
    return i > 0 ? t.toString('utf8', n + 4, n + 4 + i - 1) : ''
  }),
  ($1 = function (t, n) {
    if (!Buffer.isBuffer(t)) return N1(t, n)
    var i = 2 * t.readUInt32LE(n)
    return t.toString('utf16le', n + 4, n + 4 + i - 1)
  }),
  (H1 = function (t, n) {
    if (!Buffer.isBuffer(t)) return z1(t, n)
    var i = t.readUInt32LE(n)
    return t.toString('utf16le', n + 4, n + 4 + i)
  }),
  (j1 = function (t, n) {
    if (!Buffer.isBuffer(t)) return W1(t, n)
    var i = t.readUInt32LE(n)
    return t.toString('utf8', n + 4, n + 4 + i)
  }),
  (Ud = function (t, n) {
    return Buffer.isBuffer(t) ? t.readDoubleLE(n) : U1(t, n)
  }))
var Ns = function (e, t) {
    return e[t]
  },
  Wo = function (e, t) {
    return e[t + 1] * 256 + e[t]
  },
  bL = function (e, t) {
    var n = e[t + 1] * 256 + e[t]
    return n < 32768 ? n : (65535 - n + 1) * -1
  },
  Ln = function (e, t) {
    return e[t + 3] * (1 << 24) + (e[t + 2] << 16) + (e[t + 1] << 8) + e[t]
  },
  $s = function (e, t) {
    return (e[t + 3] << 24) | (e[t + 2] << 16) | (e[t + 1] << 8) | e[t]
  },
  _L = function (e, t) {
    return (e[t] << 24) | (e[t + 1] << 16) | (e[t + 2] << 8) | e[t + 3]
  }
function or(e, t) {
  var n = '',
    i,
    a,
    s = [],
    o,
    r,
    l,
    c
  switch (t) {
    case 'dbcs':
      if (((c = this.l), Pt && Buffer.isBuffer(this)))
        n = this.slice(this.l, this.l + 2 * e).toString('utf16le')
      else for (l = 0; l < e; ++l) (n += String.fromCharCode(Wo(this, c))), (c += 2)
      e *= 2
      break
    case 'utf8':
      n = Kr(this, this.l, this.l + e)
      break
    case 'utf16le':
      ;(e *= 2), (n = xh(this, this.l, this.l + e))
      break
    case 'wstr':
      return or.call(this, e, 'dbcs')
    case 'lpstr-ansi':
      ;(n = F1(this, this.l)), (e = 4 + Ln(this, this.l))
      break
    case 'lpstr-cp':
      ;(n = B1(this, this.l)), (e = 4 + Ln(this, this.l))
      break
    case 'lpwstr':
      ;(n = $1(this, this.l)), (e = 4 + 2 * Ln(this, this.l))
      break
    case 'lpp4':
      ;(e = 4 + Ln(this, this.l)), (n = H1(this, this.l)), e & 2 && (e += 2)
      break
    case '8lpp4':
      ;(e = 4 + Ln(this, this.l)), (n = j1(this, this.l)), e & 3 && (e += 4 - (e & 3))
      break
    case 'cstr':
      for (e = 0, n = ''; (o = Ns(this, this.l + e++)) !== 0; ) s.push(hl(o))
      n = s.join('')
      break
    case '_wstr':
      for (e = 0, n = ''; (o = Wo(this, this.l + e)) !== 0; ) s.push(hl(o)), (e += 2)
      ;(e += 2), (n = s.join(''))
      break
    case 'dbcs-cont':
      for (n = '', c = this.l, l = 0; l < e; ++l) {
        if (this.lens && this.lens.indexOf(c) !== -1)
          return (
            (o = Ns(this, c)),
            (this.l = c + 1),
            (r = or.call(this, e - l, o ? 'dbcs-cont' : 'sbcs-cont')),
            s.join('') + r
          )
        s.push(hl(Wo(this, c))), (c += 2)
      }
      ;(n = s.join('')), (e *= 2)
      break
    case 'cpstr':
    case 'sbcs-cont':
      for (n = '', c = this.l, l = 0; l != e; ++l) {
        if (this.lens && this.lens.indexOf(c) !== -1)
          return (
            (o = Ns(this, c)),
            (this.l = c + 1),
            (r = or.call(this, e - l, o ? 'dbcs-cont' : 'sbcs-cont')),
            s.join('') + r
          )
        s.push(hl(Ns(this, c))), (c += 1)
      }
      n = s.join('')
      break
    default:
      switch (e) {
        case 1:
          return (i = Ns(this, this.l)), this.l++, i
        case 2:
          return (i = (t === 'i' ? bL : Wo)(this, this.l)), (this.l += 2), i
        case 4:
        case -4:
          return t === 'i' || !(this[this.l + 3] & 128)
            ? ((i = (e > 0 ? $s : _L)(this, this.l)), (this.l += 4), i)
            : ((a = Ln(this, this.l)), (this.l += 4), a)
        case 8:
        case -8:
          if (t === 'f')
            return (
              e == 8
                ? (a = Ud(this, this.l))
                : (a = Ud(
                    [
                      this[this.l + 7],
                      this[this.l + 6],
                      this[this.l + 5],
                      this[this.l + 4],
                      this[this.l + 3],
                      this[this.l + 2],
                      this[this.l + 1],
                      this[this.l + 0]
                    ],
                    0
                  )),
              (this.l += 8),
              a
            )
          e = 8
        case 16:
          n = I1(this, this.l, e)
          break
      }
  }
  return (this.l += e), n
}
var xL = function (e, t, n) {
    ;(e[n] = t & 255),
      (e[n + 1] = (t >>> 8) & 255),
      (e[n + 2] = (t >>> 16) & 255),
      (e[n + 3] = (t >>> 24) & 255)
  },
  wL = function (e, t, n) {
    ;(e[n] = t & 255), (e[n + 1] = (t >> 8) & 255), (e[n + 2] = (t >> 16) & 255), (e[n + 3] = (t >> 24) & 255)
  },
  SL = function (e, t, n) {
    ;(e[n] = t & 255), (e[n + 1] = (t >>> 8) & 255)
  }
function kL(e, t, n) {
  var i = 0,
    a = 0
  if (n === 'dbcs') {
    for (a = 0; a != t.length; ++a) SL(this, t.charCodeAt(a), this.l + 2 * a)
    i = 2 * t.length
  } else if (n === 'sbcs') {
    for (t = t.replace(/[^\x00-\x7F]/g, '_'), a = 0; a != t.length; ++a)
      this[this.l + a] = t.charCodeAt(a) & 255
    i = t.length
  } else if (n === 'hex') {
    for (; a < e; ++a) this[this.l++] = parseInt(t.slice(2 * a, 2 * a + 2), 16) || 0
    return this
  } else if (n === 'utf16le') {
    var s = Math.min(this.l + e, this.length)
    for (a = 0; a < Math.min(t.length, e); ++a) {
      var o = t.charCodeAt(a)
      ;(this[this.l++] = o & 255), (this[this.l++] = o >> 8)
    }
    for (; this.l < s; ) this[this.l++] = 0
    return this
  } else
    switch (e) {
      case 1:
        ;(i = 1), (this[this.l] = t & 255)
        break
      case 2:
        ;(i = 2), (this[this.l] = t & 255), (t >>>= 8), (this[this.l + 1] = t & 255)
        break
      case 3:
        ;(i = 3),
          (this[this.l] = t & 255),
          (t >>>= 8),
          (this[this.l + 1] = t & 255),
          (t >>>= 8),
          (this[this.l + 2] = t & 255)
        break
      case 4:
        ;(i = 4), xL(this, t, this.l)
        break
      case 8:
        if (((i = 8), n === 'f')) {
          yL(this, t, this.l)
          break
        }
      case 16:
        break
      case -4:
        ;(i = 4), wL(this, t, this.l)
        break
    }
  return (this.l += i), this
}
function Y1(e, t) {
  var n = I1(this, this.l, e.length >> 1)
  if (n !== e) throw new Error(t + 'Expected ' + e + ' saw ' + n)
  this.l += e.length >> 1
}
function va(e, t) {
  ;(e.l = t), (e.read_shift = or), (e.chk = Y1), (e.write_shift = kL)
}
function Ri(e) {
  var t = no(e)
  return va(t, 0), t
}
function CL(e) {
  return parseInt(ML(e), 10) - 1
}
function Cs(e) {
  return '' + (e + 1)
}
function ML(e) {
  return e.replace(/\$(\d+)$/, '$1')
}
function AL(e) {
  for (var t = PL(e), n = 0, i = 0; i !== t.length; ++i) n = 26 * n + t.charCodeAt(i) - 64
  return n - 1
}
function ko(e) {
  if (e < 0) throw new Error('invalid column ' + e)
  var t = ''
  for (++e; e; e = Math.floor((e - 1) / 26)) t = String.fromCharCode(((e - 1) % 26) + 65) + t
  return t
}
function PL(e) {
  return e.replace(/^\$([A-Z])/, '$1')
}
function TL(e) {
  return e.replace(/(\$?[A-Z]*)(\$?\d*)/, '$1,$2').split(',')
}
function Ci(e) {
  for (var t = 0, n = 0, i = 0; i < e.length; ++i) {
    var a = e.charCodeAt(i)
    a >= 48 && a <= 57 ? (t = 10 * t + (a - 48)) : a >= 65 && a <= 90 && (n = 26 * n + (a - 64))
  }
  return { c: n - 1, r: t - 1 }
}
function ta(e) {
  for (var t = e.c + 1, n = ''; t; t = ((t - 1) / 26) | 0) n = String.fromCharCode(((t - 1) % 26) + 65) + n
  return n + (e.r + 1)
}
function Tr(e) {
  var t = e.indexOf(':')
  return t == -1 ? { s: Ci(e), e: Ci(e) } : { s: Ci(e.slice(0, t)), e: Ci(e.slice(t + 1)) }
}
function fi(e, t) {
  return typeof t > 'u' || typeof t == 'number'
    ? fi(e.s, e.e)
    : (typeof e != 'string' && (e = ta(e)), typeof t != 'string' && (t = ta(t)), e == t ? e : e + ':' + t)
}
function Vi(e) {
  var t = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } },
    n = 0,
    i = 0,
    a = 0,
    s = e.length
  for (n = 0; i < s && !((a = e.charCodeAt(i) - 64) < 1 || a > 26); ++i) n = 26 * n + a
  for (t.s.c = --n, n = 0; i < s && !((a = e.charCodeAt(i) - 48) < 0 || a > 9); ++i) n = 10 * n + a
  if (((t.s.r = --n), i === s || a != 10)) return (t.e.c = t.s.c), (t.e.r = t.s.r), t
  for (++i, n = 0; i != s && !((a = e.charCodeAt(i) - 64) < 1 || a > 26); ++i) n = 26 * n + a
  for (t.e.c = --n, n = 0; i != s && !((a = e.charCodeAt(i) - 48) < 0 || a > 9); ++i) n = 10 * n + a
  return (t.e.r = --n), t
}
function lm(e, t) {
  var n = e.t == 'd' && t instanceof Date
  if (e.z != null)
    try {
      return (e.w = Pr(e.z, n ? gs(t) : t))
    } catch {}
  try {
    return (e.w = Pr((e.XF || {}).numFmtId || (n ? 14 : 0), n ? gs(t) : t))
  } catch {
    return '' + t
  }
}
function qr(e, t, n) {
  return e == null || e.t == null || e.t == 'z'
    ? ''
    : e.w !== void 0
    ? e.w
    : (e.t == 'd' && !e.z && n && n.dateNF && (e.z = n.dateNF),
      e.t == 'e' ? X1[e.v] || e.v : t == null ? lm(e, e.v) : lm(e, t))
}
function VL(e, t) {
  var n = t && t.sheet ? t.sheet : 'Sheet1',
    i = {}
  return (i[n] = e), { SheetNames: [n], Sheets: i }
}
function G1(e, t, n) {
  var i = n || {},
    a = e ? Array.isArray(e) : i.dense,
    s = e || (a ? [] : {}),
    o = 0,
    r = 0
  if (s && i.origin != null) {
    if (typeof i.origin == 'number') o = i.origin
    else {
      var l = typeof i.origin == 'string' ? Ci(i.origin) : i.origin
      ;(o = l.r), (r = l.c)
    }
    s['!ref'] || (s['!ref'] = 'A1:A1')
  }
  var c = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } }
  if (s['!ref']) {
    var u = Vi(s['!ref'])
    ;(c.s.c = u.s.c),
      (c.s.r = u.s.r),
      (c.e.c = Math.max(c.e.c, u.e.c)),
      (c.e.r = Math.max(c.e.r, u.e.r)),
      o == -1 && (c.e.r = o = u.e.r + 1)
  }
  for (var d = 0; d != t.length; ++d)
    if (t[d]) {
      if (!Array.isArray(t[d])) throw new Error('aoa_to_sheet expects an array of arrays')
      for (var f = 0; f != t[d].length; ++f)
        if (!(typeof t[d][f] > 'u')) {
          var h = { v: t[d][f] },
            v = o + d,
            g = r + f
          if (
            (c.s.r > v && (c.s.r = v),
            c.s.c > g && (c.s.c = g),
            c.e.r < v && (c.e.r = v),
            c.e.c < g && (c.e.c = g),
            t[d][f] && typeof t[d][f] == 'object' && !Array.isArray(t[d][f]) && !(t[d][f] instanceof Date))
          )
            h = t[d][f]
          else if ((Array.isArray(h.v) && ((h.f = t[d][f][1]), (h.v = h.v[0])), h.v === null))
            if (h.f) h.t = 'n'
            else if (i.nullError) (h.t = 'e'), (h.v = 0)
            else if (i.sheetStubs) h.t = 'z'
            else continue
          else
            typeof h.v == 'number'
              ? (h.t = 'n')
              : typeof h.v == 'boolean'
              ? (h.t = 'b')
              : h.v instanceof Date
              ? ((h.z = i.dateNF || ci[14]),
                i.cellDates
                  ? ((h.t = 'd'), (h.w = Pr(h.z, gs(h.v))))
                  : ((h.t = 'n'), (h.v = gs(h.v)), (h.w = Pr(h.z, h.v))))
              : (h.t = 's')
          if (a) s[v] || (s[v] = []), s[v][g] && s[v][g].z && (h.z = s[v][g].z), (s[v][g] = h)
          else {
            var p = ta({ c: g, r: v })
            s[p] && s[p].z && (h.z = s[p].z), (s[p] = h)
          }
        }
    }
  return c.s.c < 1e7 && (s['!ref'] = fi(c)), s
}
function EL(e, t) {
  return G1(null, e, t)
}
var X1 = {
    0: '#NULL!',
    7: '#DIV/0!',
    15: '#VALUE!',
    23: '#REF!',
    29: '#NAME?',
    36: '#NUM!',
    42: '#N/A',
    43: '#GETTING_DATA',
    255: '#WTF?'
  },
  LL = {
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml': 'workbooks',
    'application/vnd.ms-excel.sheet.macroEnabled.main+xml': 'workbooks',
    'application/vnd.ms-excel.sheet.binary.macroEnabled.main': 'workbooks',
    'application/vnd.ms-excel.addin.macroEnabled.main+xml': 'workbooks',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml': 'workbooks',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml': 'sheets',
    'application/vnd.ms-excel.worksheet': 'sheets',
    'application/vnd.ms-excel.binIndexWs': 'TODO',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml': 'charts',
    'application/vnd.ms-excel.chartsheet': 'charts',
    'application/vnd.ms-excel.macrosheet+xml': 'macros',
    'application/vnd.ms-excel.macrosheet': 'macros',
    'application/vnd.ms-excel.intlmacrosheet': 'TODO',
    'application/vnd.ms-excel.binIndexMs': 'TODO',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml': 'dialogs',
    'application/vnd.ms-excel.dialogsheet': 'dialogs',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml': 'strs',
    'application/vnd.ms-excel.sharedStrings': 'strs',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml': 'styles',
    'application/vnd.ms-excel.styles': 'styles',
    'application/vnd.openxmlformats-package.core-properties+xml': 'coreprops',
    'application/vnd.openxmlformats-officedocument.custom-properties+xml': 'custprops',
    'application/vnd.openxmlformats-officedocument.extended-properties+xml': 'extprops',
    'application/vnd.openxmlformats-officedocument.customXmlProperties+xml': 'TODO',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty': 'TODO',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml': 'comments',
    'application/vnd.ms-excel.comments': 'comments',
    'application/vnd.ms-excel.threadedcomments+xml': 'threadedcomments',
    'application/vnd.ms-excel.person+xml': 'people',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml': 'metadata',
    'application/vnd.ms-excel.sheetMetadata': 'metadata',
    'application/vnd.ms-excel.pivotTable': 'TODO',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml': 'TODO',
    'application/vnd.openxmlformats-officedocument.drawingml.chart+xml': 'TODO',
    'application/vnd.ms-office.chartcolorstyle+xml': 'TODO',
    'application/vnd.ms-office.chartstyle+xml': 'TODO',
    'application/vnd.ms-office.chartex+xml': 'TODO',
    'application/vnd.ms-excel.calcChain': 'calcchains',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml': 'calcchains',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings': 'TODO',
    'application/vnd.ms-office.activeX': 'TODO',
    'application/vnd.ms-office.activeX+xml': 'TODO',
    'application/vnd.ms-excel.attachedToolbars': 'TODO',
    'application/vnd.ms-excel.connections': 'TODO',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml': 'TODO',
    'application/vnd.ms-excel.externalLink': 'links',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml': 'links',
    'application/vnd.ms-excel.pivotCacheDefinition': 'TODO',
    'application/vnd.ms-excel.pivotCacheRecords': 'TODO',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml': 'TODO',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml': 'TODO',
    'application/vnd.ms-excel.queryTable': 'TODO',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml': 'TODO',
    'application/vnd.ms-excel.userNames': 'TODO',
    'application/vnd.ms-excel.revisionHeaders': 'TODO',
    'application/vnd.ms-excel.revisionLog': 'TODO',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml': 'TODO',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml': 'TODO',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml': 'TODO',
    'application/vnd.ms-excel.tableSingleCells': 'TODO',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml': 'TODO',
    'application/vnd.ms-excel.slicer': 'TODO',
    'application/vnd.ms-excel.slicerCache': 'TODO',
    'application/vnd.ms-excel.slicer+xml': 'TODO',
    'application/vnd.ms-excel.slicerCache+xml': 'TODO',
    'application/vnd.ms-excel.wsSortMap': 'TODO',
    'application/vnd.ms-excel.table': 'TODO',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml': 'TODO',
    'application/vnd.openxmlformats-officedocument.theme+xml': 'themes',
    'application/vnd.openxmlformats-officedocument.themeOverride+xml': 'TODO',
    'application/vnd.ms-excel.Timeline+xml': 'TODO',
    'application/vnd.ms-excel.TimelineCache+xml': 'TODO',
    'application/vnd.ms-office.vbaProject': 'vba',
    'application/vnd.ms-office.vbaProjectSignature': 'TODO',
    'application/vnd.ms-office.volatileDependencies': 'TODO',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml': 'TODO',
    'application/vnd.ms-excel.controlproperties+xml': 'TODO',
    'application/vnd.openxmlformats-officedocument.model+data': 'TODO',
    'application/vnd.ms-excel.Survey+xml': 'TODO',
    'application/vnd.openxmlformats-officedocument.drawing+xml': 'drawings',
    'application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml': 'TODO',
    'application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml': 'TODO',
    'application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml': 'TODO',
    'application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml': 'TODO',
    'application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml': 'TODO',
    'application/vnd.openxmlformats-officedocument.vmlDrawing': 'TODO',
    'application/vnd.openxmlformats-package.relationships+xml': 'rels',
    'application/vnd.openxmlformats-officedocument.oleObject': 'TODO',
    'image/png': 'TODO',
    sheet: 'js'
  },
  yl = {
    workbooks: {
      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml',
      xlsm: 'application/vnd.ms-excel.sheet.macroEnabled.main+xml',
      xlsb: 'application/vnd.ms-excel.sheet.binary.macroEnabled.main',
      xlam: 'application/vnd.ms-excel.addin.macroEnabled.main+xml',
      xltx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml'
    },
    strs: {
      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml',
      xlsb: 'application/vnd.ms-excel.sharedStrings'
    },
    comments: {
      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml',
      xlsb: 'application/vnd.ms-excel.comments'
    },
    sheets: {
      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml',
      xlsb: 'application/vnd.ms-excel.worksheet'
    },
    charts: {
      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml',
      xlsb: 'application/vnd.ms-excel.chartsheet'
    },
    dialogs: {
      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml',
      xlsb: 'application/vnd.ms-excel.dialogsheet'
    },
    macros: { xlsx: 'application/vnd.ms-excel.macrosheet+xml', xlsb: 'application/vnd.ms-excel.macrosheet' },
    metadata: {
      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml',
      xlsb: 'application/vnd.ms-excel.sheetMetadata'
    },
    styles: {
      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml',
      xlsb: 'application/vnd.ms-excel.styles'
    }
  }
function OL() {
  return {
    workbooks: [],
    sheets: [],
    charts: [],
    dialogs: [],
    macros: [],
    rels: [],
    strs: [],
    comments: [],
    threadedcomments: [],
    links: [],
    coreprops: [],
    extprops: [],
    custprops: [],
    themes: [],
    styles: [],
    calcchains: [],
    vba: [],
    drawings: [],
    metadata: [],
    people: [],
    TODO: [],
    xmlns: ''
  }
}
function IL(e, t) {
  var n = sL(LL),
    i = [],
    a
  ;(i[i.length] = Pn),
    (i[i.length] = Ne('Types', null, { xmlns: qt.CT, 'xmlns:xsd': qt.xsd, 'xmlns:xsi': qt.xsi })),
    (i = i.concat(
      [
        ['xml', 'application/xml'],
        ['bin', 'application/vnd.ms-excel.sheet.binary.macroEnabled.main'],
        ['vml', 'application/vnd.openxmlformats-officedocument.vmlDrawing'],
        ['data', 'application/vnd.openxmlformats-officedocument.model+data'],
        ['bmp', 'image/bmp'],
        ['png', 'image/png'],
        ['gif', 'image/gif'],
        ['emf', 'image/x-emf'],
        ['wmf', 'image/x-wmf'],
        ['jpg', 'image/jpeg'],
        ['jpeg', 'image/jpeg'],
        ['tif', 'image/tiff'],
        ['tiff', 'image/tiff'],
        ['pdf', 'application/pdf'],
        ['rels', 'application/vnd.openxmlformats-package.relationships+xml']
      ].map(function (l) {
        return Ne('Default', null, { Extension: l[0], ContentType: l[1] })
      })
    ))
  var s = function (l) {
      e[l] &&
        e[l].length > 0 &&
        ((a = e[l][0]),
        (i[i.length] = Ne('Override', null, {
          PartName: (a[0] == '/' ? '' : '/') + a,
          ContentType: yl[l][t.bookType] || yl[l].xlsx
        })))
    },
    o = function (l) {
      ;(e[l] || []).forEach(function (c) {
        i[i.length] = Ne('Override', null, {
          PartName: (c[0] == '/' ? '' : '/') + c,
          ContentType: yl[l][t.bookType] || yl[l].xlsx
        })
      })
    },
    r = function (l) {
      ;(e[l] || []).forEach(function (c) {
        i[i.length] = Ne('Override', null, { PartName: (c[0] == '/' ? '' : '/') + c, ContentType: n[l][0] })
      })
    }
  return (
    s('workbooks'),
    o('sheets'),
    o('charts'),
    r('themes'),
    ['strs', 'styles'].forEach(s),
    ['coreprops', 'extprops', 'custprops'].forEach(r),
    r('vba'),
    r('comments'),
    r('threadedcomments'),
    r('drawings'),
    o('metadata'),
    r('people'),
    i.length > 2 && ((i[i.length] = '</Types>'), (i[1] = i[1].replace('/>', '>'))),
    i.join('')
  )
}
var Ht = {
  WB: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument',
  SHEET: 'http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument',
  HLINK: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink',
  VML: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing',
  XPATH: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath',
  XMISS: 'http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing',
  XLINK: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink',
  CXML: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml',
  CXMLP: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps',
  CMNT: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments',
  CORE_PROPS: 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties',
  EXT_PROPS: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties',
  CUST_PROPS: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties',
  SST: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',
  STY: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
  THEME: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',
  CHART: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart',
  CHARTEX: 'http://schemas.microsoft.com/office/2014/relationships/chartEx',
  CS: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet',
  WS: [
    'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
    'http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet'
  ],
  DS: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet',
  MS: 'http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet',
  IMG: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
  DRAW: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
  XLMETA: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata',
  TCMNT: 'http://schemas.microsoft.com/office/2017/10/relationships/threadedComment',
  PEOPLE: 'http://schemas.microsoft.com/office/2017/10/relationships/person',
  VBA: 'http://schemas.microsoft.com/office/2006/relationships/vbaProject'
}
function DL(e) {
  var t = e.lastIndexOf('/')
  return e.slice(0, t + 1) + '_rels/' + e.slice(t + 1) + '.rels'
}
function Lu(e) {
  var t = [Pn, Ne('Relationships', null, { xmlns: qt.RELS })]
  return (
    Ra(e['!id']).forEach(function (n) {
      t[t.length] = Ne('Relationship', null, e['!id'][n])
    }),
    t.length > 2 && ((t[t.length] = '</Relationships>'), (t[1] = t[1].replace('/>', '>'))),
    t.join('')
  )
}
function on(e, t, n, i, a, s) {
  if ((a || (a = {}), e['!id'] || (e['!id'] = {}), e['!idx'] || (e['!idx'] = 1), t < 0))
    for (t = e['!idx']; e['!id']['rId' + t]; ++t);
  if (
    ((e['!idx'] = t + 1),
    (a.Id = 'rId' + t),
    (a.Type = i),
    (a.Target = n),
    s
      ? (a.TargetMode = s)
      : [Ht.HLINK, Ht.XPATH, Ht.XMISS].indexOf(a.Type) > -1 && (a.TargetMode = 'External'),
    e['!id'][a.Id])
  )
    throw new Error('Cannot rewrite rId ' + t)
  return (e['!id'][a.Id] = a), (e[('/' + a.Target).replace('//', '/')] = a), t
}
var cm = [
  ['cp:category', 'Category'],
  ['cp:contentStatus', 'ContentStatus'],
  ['cp:keywords', 'Keywords'],
  ['cp:lastModifiedBy', 'LastAuthor'],
  ['cp:lastPrinted', 'LastPrinted'],
  ['cp:revision', 'RevNumber'],
  ['cp:version', 'Version'],
  ['dc:creator', 'Author'],
  ['dc:description', 'Comments'],
  ['dc:identifier', 'Identifier'],
  ['dc:language', 'Language'],
  ['dc:subject', 'Subject'],
  ['dc:title', 'Title'],
  ['dcterms:created', 'CreatedDate', 'date'],
  ['dcterms:modified', 'ModifiedDate', 'date']
]
function Ou(e, t, n, i, a) {
  a[e] != null ||
    t == null ||
    t === '' ||
    ((a[e] = t), (t = $t(t)), (i[i.length] = n ? Ne(e, t, n) : si(e, t)))
}
function FL(e, t) {
  var n = t || {},
    i = [
      Pn,
      Ne('cp:coreProperties', null, {
        'xmlns:cp': qt.CORE_PROPS,
        'xmlns:dc': qt.dc,
        'xmlns:dcterms': qt.dcterms,
        'xmlns:dcmitype': qt.dcmitype,
        'xmlns:xsi': qt.xsi
      })
    ],
    a = {}
  if (!e && !n.Props) return i.join('')
  e &&
    (e.CreatedDate != null &&
      Ou(
        'dcterms:created',
        typeof e.CreatedDate == 'string' ? e.CreatedDate : jd(e.CreatedDate, n.WTF),
        { 'xsi:type': 'dcterms:W3CDTF' },
        i,
        a
      ),
    e.ModifiedDate != null &&
      Ou(
        'dcterms:modified',
        typeof e.ModifiedDate == 'string' ? e.ModifiedDate : jd(e.ModifiedDate, n.WTF),
        { 'xsi:type': 'dcterms:W3CDTF' },
        i,
        a
      ))
  for (var s = 0; s != cm.length; ++s) {
    var o = cm[s],
      r = n.Props && n.Props[o[1]] != null ? n.Props[o[1]] : e ? e[o[1]] : null
    r === !0 ? (r = '1') : r === !1 ? (r = '0') : typeof r == 'number' && (r = String(r)),
      r != null && Ou(o[0], r, null, i, a)
  }
  return (
    i.length > 2 && ((i[i.length] = '</cp:coreProperties>'), (i[1] = i[1].replace('/>', '>'))), i.join('')
  )
}
var RL = [
  ['Application', 'Application', 'string'],
  ['AppVersion', 'AppVersion', 'string'],
  ['Company', 'Company', 'string'],
  ['DocSecurity', 'DocSecurity', 'string'],
  ['Manager', 'Manager', 'string'],
  ['HyperlinksChanged', 'HyperlinksChanged', 'bool'],
  ['SharedDoc', 'SharedDoc', 'bool'],
  ['LinksUpToDate', 'LinksUpToDate', 'bool'],
  ['ScaleCrop', 'ScaleCrop', 'bool'],
  ['HeadingPairs', 'HeadingPairs', 'raw'],
  ['TitlesOfParts', 'TitlesOfParts', 'raw']
]
function BL(e) {
  var t = [],
    n = Ne
  return (
    e || (e = {}),
    (e.Application = 'SheetJS'),
    (t[t.length] = Pn),
    (t[t.length] = Ne('Properties', null, { xmlns: qt.EXT_PROPS, 'xmlns:vt': qt.vt })),
    RL.forEach(function (i) {
      if (e[i[1]] !== void 0) {
        var a
        switch (i[2]) {
          case 'string':
            a = $t(String(e[i[1]]))
            break
          case 'bool':
            a = e[i[1]] ? 'true' : 'false'
            break
        }
        a !== void 0 && (t[t.length] = n(i[0], a))
      }
    }),
    (t[t.length] = n(
      'HeadingPairs',
      n(
        'vt:vector',
        n('vt:variant', '<vt:lpstr>Worksheets</vt:lpstr>') +
          n('vt:variant', n('vt:i4', String(e.Worksheets))),
        { size: 2, baseType: 'variant' }
      )
    )),
    (t[t.length] = n(
      'TitlesOfParts',
      n(
        'vt:vector',
        e.SheetNames.map(function (i) {
          return '<vt:lpstr>' + $t(i) + '</vt:lpstr>'
        }).join(''),
        { size: e.Worksheets, baseType: 'lpstr' }
      )
    )),
    t.length > 2 && ((t[t.length] = '</Properties>'), (t[1] = t[1].replace('/>', '>'))),
    t.join('')
  )
}
function NL(e) {
  var t = [Pn, Ne('Properties', null, { xmlns: qt.CUST_PROPS, 'xmlns:vt': qt.vt })]
  if (!e) return t.join('')
  var n = 1
  return (
    Ra(e).forEach(function (a) {
      ++n,
        (t[t.length] = Ne('property', mL(e[a], !0), {
          fmtid: '{D5CDD505-2E9C-101B-9397-08002B2CF9AE}',
          pid: n,
          name: $t(a)
        }))
    }),
    t.length > 2 && ((t[t.length] = '</Properties>'), (t[1] = t[1].replace('/>', '>'))),
    t.join('')
  )
}
var $L = /^\s|\s$|[\t\n\r]/
function zL(e, t) {
  if (!t.bookSST) return ''
  var n = [Pn]
  n[n.length] = Ne('sst', null, { xmlns: So[0], count: e.Count, uniqueCount: e.Unique })
  for (var i = 0; i != e.length; ++i)
    if (e[i] != null) {
      var a = e[i],
        s = '<si>'
      a.r
        ? (s += a.r)
        : ((s += '<t'),
          a.t || (a.t = ''),
          a.t.match($L) && (s += ' xml:space="preserve"'),
          (s += '>' + $t(a.t) + '</t>')),
        (s += '</si>'),
        (n[n.length] = s)
    }
  return n.length > 2 && ((n[n.length] = '</sst>'), (n[1] = n[1].replace('/>', '>'))), n.join('')
}
function HL(e) {
  for (var t = [], n = e.split(''), i = 0; i < n.length; ++i) t[i] = n[i].charCodeAt(0)
  return t
}
function WL(e) {
  var t = 0,
    n,
    i = HL(e),
    a = i.length + 1,
    s,
    o,
    r,
    l,
    c
  for (n = no(a), n[0] = i.length, s = 1; s != a; ++s) n[s] = i[s - 1]
  for (s = a - 1; s >= 0; --s)
    (o = n[s]), (r = t & 16384 ? 1 : 0), (l = (t << 1) & 32767), (c = r | l), (t = c ^ o)
  return t ^ 52811
}
var jL = 6,
  gc = jL
function UL(e) {
  return Math.floor(((e - 5) / gc) * 100 + 0.5) / 100
}
function YL(e) {
  return Math.round(((e * gc + 5) / gc) * 256) / 256
}
var GL = 96,
  XL = GL
function um(e) {
  return (e * 96) / XL
}
function KL(e) {
  var t = ['<numFmts>']
  return (
    [
      [5, 8],
      [23, 26],
      [41, 44],
      [50, 392]
    ].forEach(function (n) {
      for (var i = n[0]; i <= n[1]; ++i)
        e[i] != null && (t[t.length] = Ne('numFmt', null, { numFmtId: i, formatCode: $t(e[i]) }))
    }),
    t.length === 1
      ? ''
      : ((t[t.length] = '</numFmts>'),
        (t[0] = Ne('numFmts', null, { count: t.length - 2 }).replace('/>', '>')),
        t.join(''))
  )
}
function qL(e) {
  var t = []
  return (
    (t[t.length] = Ne('cellXfs', null)),
    e.forEach(function (n) {
      t[t.length] = Ne('xf', null, n)
    }),
    (t[t.length] = '</cellXfs>'),
    t.length === 2
      ? ''
      : ((t[0] = Ne('cellXfs', null, { count: t.length - 2 }).replace('/>', '>')), t.join(''))
  )
}
function ZL(e, t) {
  var n = [Pn, Ne('styleSheet', null, { xmlns: So[0], 'xmlns:vt': qt.vt })],
    i
  return (
    e.SSF && (i = KL(e.SSF)) != null && (n[n.length] = i),
    (n[n.length] =
      '<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>'),
    (n[n.length] =
      '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>'),
    (n[n.length] = '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>'),
    (n[n.length] =
      '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>'),
    (i = qL(t.cellXfs)) && (n[n.length] = i),
    (n[n.length] = '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>'),
    (n[n.length] = '<dxfs count="0"/>'),
    (n[n.length] =
      '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>'),
    n.length > 2 && ((n[n.length] = '</styleSheet>'), (n[1] = n[1].replace('/>', '>'))),
    n.join('')
  )
}
function JL(e, t) {
  if (t && t.themeXLSX) return t.themeXLSX
  if (e && typeof e.raw == 'string') return e.raw
  var n = [Pn]
  return (
    (n[n.length] =
      '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">'),
    (n[n.length] = '<a:themeElements>'),
    (n[n.length] = '<a:clrScheme name="Office">'),
    (n[n.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>'),
    (n[n.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>'),
    (n[n.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>'),
    (n[n.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>'),
    (n[n.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>'),
    (n[n.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>'),
    (n[n.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>'),
    (n[n.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>'),
    (n[n.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>'),
    (n[n.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>'),
    (n[n.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>'),
    (n[n.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>'),
    (n[n.length] = '</a:clrScheme>'),
    (n[n.length] = '<a:fontScheme name="Office">'),
    (n[n.length] = '<a:majorFont>'),
    (n[n.length] = '<a:latin typeface="Cambria"/>'),
    (n[n.length] = '<a:ea typeface=""/>'),
    (n[n.length] = '<a:cs typeface=""/>'),
    (n[n.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>'),
    (n[n.length] = '<a:font script="Hang" typeface="맑은 고딕"/>'),
    (n[n.length] = '<a:font script="Hans" typeface="宋体"/>'),
    (n[n.length] = '<a:font script="Hant" typeface="新細明體"/>'),
    (n[n.length] = '<a:font script="Arab" typeface="Times New Roman"/>'),
    (n[n.length] = '<a:font script="Hebr" typeface="Times New Roman"/>'),
    (n[n.length] = '<a:font script="Thai" typeface="Tahoma"/>'),
    (n[n.length] = '<a:font script="Ethi" typeface="Nyala"/>'),
    (n[n.length] = '<a:font script="Beng" typeface="Vrinda"/>'),
    (n[n.length] = '<a:font script="Gujr" typeface="Shruti"/>'),
    (n[n.length] = '<a:font script="Khmr" typeface="MoolBoran"/>'),
    (n[n.length] = '<a:font script="Knda" typeface="Tunga"/>'),
    (n[n.length] = '<a:font script="Guru" typeface="Raavi"/>'),
    (n[n.length] = '<a:font script="Cans" typeface="Euphemia"/>'),
    (n[n.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>'),
    (n[n.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>'),
    (n[n.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>'),
    (n[n.length] = '<a:font script="Thaa" typeface="MV Boli"/>'),
    (n[n.length] = '<a:font script="Deva" typeface="Mangal"/>'),
    (n[n.length] = '<a:font script="Telu" typeface="Gautami"/>'),
    (n[n.length] = '<a:font script="Taml" typeface="Latha"/>'),
    (n[n.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>'),
    (n[n.length] = '<a:font script="Orya" typeface="Kalinga"/>'),
    (n[n.length] = '<a:font script="Mlym" typeface="Kartika"/>'),
    (n[n.length] = '<a:font script="Laoo" typeface="DokChampa"/>'),
    (n[n.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>'),
    (n[n.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>'),
    (n[n.length] = '<a:font script="Viet" typeface="Times New Roman"/>'),
    (n[n.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>'),
    (n[n.length] = '<a:font script="Geor" typeface="Sylfaen"/>'),
    (n[n.length] = '</a:majorFont>'),
    (n[n.length] = '<a:minorFont>'),
    (n[n.length] = '<a:latin typeface="Calibri"/>'),
    (n[n.length] = '<a:ea typeface=""/>'),
    (n[n.length] = '<a:cs typeface=""/>'),
    (n[n.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>'),
    (n[n.length] = '<a:font script="Hang" typeface="맑은 고딕"/>'),
    (n[n.length] = '<a:font script="Hans" typeface="宋体"/>'),
    (n[n.length] = '<a:font script="Hant" typeface="新細明體"/>'),
    (n[n.length] = '<a:font script="Arab" typeface="Arial"/>'),
    (n[n.length] = '<a:font script="Hebr" typeface="Arial"/>'),
    (n[n.length] = '<a:font script="Thai" typeface="Tahoma"/>'),
    (n[n.length] = '<a:font script="Ethi" typeface="Nyala"/>'),
    (n[n.length] = '<a:font script="Beng" typeface="Vrinda"/>'),
    (n[n.length] = '<a:font script="Gujr" typeface="Shruti"/>'),
    (n[n.length] = '<a:font script="Khmr" typeface="DaunPenh"/>'),
    (n[n.length] = '<a:font script="Knda" typeface="Tunga"/>'),
    (n[n.length] = '<a:font script="Guru" typeface="Raavi"/>'),
    (n[n.length] = '<a:font script="Cans" typeface="Euphemia"/>'),
    (n[n.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>'),
    (n[n.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>'),
    (n[n.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>'),
    (n[n.length] = '<a:font script="Thaa" typeface="MV Boli"/>'),
    (n[n.length] = '<a:font script="Deva" typeface="Mangal"/>'),
    (n[n.length] = '<a:font script="Telu" typeface="Gautami"/>'),
    (n[n.length] = '<a:font script="Taml" typeface="Latha"/>'),
    (n[n.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>'),
    (n[n.length] = '<a:font script="Orya" typeface="Kalinga"/>'),
    (n[n.length] = '<a:font script="Mlym" typeface="Kartika"/>'),
    (n[n.length] = '<a:font script="Laoo" typeface="DokChampa"/>'),
    (n[n.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>'),
    (n[n.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>'),
    (n[n.length] = '<a:font script="Viet" typeface="Arial"/>'),
    (n[n.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>'),
    (n[n.length] = '<a:font script="Geor" typeface="Sylfaen"/>'),
    (n[n.length] = '</a:minorFont>'),
    (n[n.length] = '</a:fontScheme>'),
    (n[n.length] = '<a:fmtScheme name="Office">'),
    (n[n.length] = '<a:fillStyleLst>'),
    (n[n.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>'),
    (n[n.length] = '<a:gradFill rotWithShape="1">'),
    (n[n.length] = '<a:gsLst>'),
    (n[n.length] =
      '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>'),
    (n[n.length] =
      '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>'),
    (n[n.length] =
      '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>'),
    (n[n.length] = '</a:gsLst>'),
    (n[n.length] = '<a:lin ang="16200000" scaled="1"/>'),
    (n[n.length] = '</a:gradFill>'),
    (n[n.length] = '<a:gradFill rotWithShape="1">'),
    (n[n.length] = '<a:gsLst>'),
    (n[n.length] =
      '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>'),
    (n[n.length] =
      '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>'),
    (n[n.length] = '</a:gsLst>'),
    (n[n.length] = '<a:lin ang="16200000" scaled="0"/>'),
    (n[n.length] = '</a:gradFill>'),
    (n[n.length] = '</a:fillStyleLst>'),
    (n[n.length] = '<a:lnStyleLst>'),
    (n[n.length] =
      '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>'),
    (n[n.length] =
      '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>'),
    (n[n.length] =
      '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>'),
    (n[n.length] = '</a:lnStyleLst>'),
    (n[n.length] = '<a:effectStyleLst>'),
    (n[n.length] = '<a:effectStyle>'),
    (n[n.length] = '<a:effectLst>'),
    (n[n.length] =
      '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>'),
    (n[n.length] = '</a:effectLst>'),
    (n[n.length] = '</a:effectStyle>'),
    (n[n.length] = '<a:effectStyle>'),
    (n[n.length] = '<a:effectLst>'),
    (n[n.length] =
      '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>'),
    (n[n.length] = '</a:effectLst>'),
    (n[n.length] = '</a:effectStyle>'),
    (n[n.length] = '<a:effectStyle>'),
    (n[n.length] = '<a:effectLst>'),
    (n[n.length] =
      '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>'),
    (n[n.length] = '</a:effectLst>'),
    (n[n.length] =
      '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>'),
    (n[n.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>'),
    (n[n.length] = '</a:effectStyle>'),
    (n[n.length] = '</a:effectStyleLst>'),
    (n[n.length] = '<a:bgFillStyleLst>'),
    (n[n.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>'),
    (n[n.length] = '<a:gradFill rotWithShape="1">'),
    (n[n.length] = '<a:gsLst>'),
    (n[n.length] =
      '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>'),
    (n[n.length] =
      '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>'),
    (n[n.length] =
      '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>'),
    (n[n.length] = '</a:gsLst>'),
    (n[n.length] =
      '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>'),
    (n[n.length] = '</a:gradFill>'),
    (n[n.length] = '<a:gradFill rotWithShape="1">'),
    (n[n.length] = '<a:gsLst>'),
    (n[n.length] =
      '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>'),
    (n[n.length] =
      '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>'),
    (n[n.length] = '</a:gsLst>'),
    (n[n.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>'),
    (n[n.length] = '</a:gradFill>'),
    (n[n.length] = '</a:bgFillStyleLst>'),
    (n[n.length] = '</a:fmtScheme>'),
    (n[n.length] = '</a:themeElements>'),
    (n[n.length] = '<a:objectDefaults>'),
    (n[n.length] = '<a:spDef>'),
    (n[n.length] =
      '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>'),
    (n[n.length] = '</a:spDef>'),
    (n[n.length] = '<a:lnDef>'),
    (n[n.length] =
      '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>'),
    (n[n.length] = '</a:lnDef>'),
    (n[n.length] = '</a:objectDefaults>'),
    (n[n.length] = '<a:extraClrSchemeLst/>'),
    (n[n.length] = '</a:theme>'),
    n.join('')
  )
}
function QL() {
  var e = [Pn]
  return (
    e.push(`<metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray">
  <metadataTypes count="1">
    <metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/>
  </metadataTypes>
  <futureMetadata name="XLDAPR" count="1">
    <bk>
      <extLst>
        <ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}">
          <xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/>
        </ext>
      </extLst>
    </bk>
  </futureMetadata>
  <cellMetadata count="1">
    <bk>
      <rc t="1" v="0"/>
    </bk>
  </cellMetadata>
</metadata>`),
    e.join('')
  )
}
var jo = 1024
function eO(e, t) {
  for (
    var n = [21600, 21600],
      i = ['m0,0l0', n[1], n[0], n[1], n[0], '0xe'].join(','),
      a = [
        Ne('xml', null, { 'xmlns:v': pl.v, 'xmlns:o': pl.o, 'xmlns:x': pl.x, 'xmlns:mv': pl.mv }).replace(
          /\/>/,
          '>'
        ),
        Ne('o:shapelayout', Ne('o:idmap', null, { 'v:ext': 'edit', data: e }), { 'v:ext': 'edit' }),
        Ne(
          'v:shapetype',
          [
            Ne('v:stroke', null, { joinstyle: 'miter' }),
            Ne('v:path', null, { gradientshapeok: 't', 'o:connecttype': 'rect' })
          ].join(''),
          { id: '_x0000_t202', 'o:spt': 202, coordsize: n.join(','), path: i }
        )
      ];
    jo < e * 1e3;

  )
    jo += 1e3
  return (
    t.forEach(function (s) {
      var o = Ci(s[0]),
        r = { color2: '#BEFF82', type: 'gradient' }
      r.type == 'gradient' && (r.angle = '-180')
      var l = r.type == 'gradient' ? Ne('o:fill', null, { type: 'gradientUnscaled', 'v:ext': 'view' }) : null,
        c = Ne('v:fill', l, r),
        u = { on: 't', obscured: 't' }
      ++jo,
        (a = a.concat([
          '<v:shape' +
            O1({
              id: '_x0000_s' + jo,
              type: '#_x0000_t202',
              style:
                'position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10' +
                (s[1].hidden ? ';visibility:hidden' : ''),
              fillcolor: '#ECFAD4',
              strokecolor: '#edeaa1'
            }) +
            '>',
          c,
          Ne('v:shadow', null, u),
          Ne('v:path', null, { 'o:connecttype': 'none' }),
          '<v:textbox><div style="text-align:left"></div></v:textbox>',
          '<x:ClientData ObjectType="Note">',
          '<x:MoveWithCells/>',
          '<x:SizeWithCells/>',
          si('x:Anchor', [o.c + 1, 0, o.r + 1, 0, o.c + 3, 20, o.r + 5, 20].join(',')),
          si('x:AutoFill', 'False'),
          si('x:Row', String(o.r)),
          si('x:Column', String(o.c)),
          s[1].hidden ? '' : '<x:Visible/>',
          '</x:ClientData>',
          '</v:shape>'
        ]))
    }),
    a.push('</xml>'),
    a.join('')
  )
}
function tO(e) {
  var t = [Pn, Ne('comments', null, { xmlns: So[0] })],
    n = []
  return (
    t.push('<authors>'),
    e.forEach(function (i) {
      i[1].forEach(function (a) {
        var s = $t(a.a)
        n.indexOf(s) == -1 && (n.push(s), t.push('<author>' + s + '</author>')),
          a.T &&
            a.ID &&
            n.indexOf('tc=' + a.ID) == -1 &&
            (n.push('tc=' + a.ID), t.push('<author>tc=' + a.ID + '</author>'))
      })
    }),
    n.length == 0 && (n.push('SheetJ5'), t.push('<author>SheetJ5</author>')),
    t.push('</authors>'),
    t.push('<commentList>'),
    e.forEach(function (i) {
      var a = 0,
        s = []
      if (
        (i[1][0] && i[1][0].T && i[1][0].ID
          ? (a = n.indexOf('tc=' + i[1][0].ID))
          : i[1].forEach(function (l) {
              l.a && (a = n.indexOf($t(l.a))), s.push(l.t || '')
            }),
        t.push('<comment ref="' + i[0] + '" authorId="' + a + '"><text>'),
        s.length <= 1)
      )
        t.push(si('t', $t(s[0] || '')))
      else {
        for (
          var o =
              `Comment:
    ` +
              s[0] +
              `
`,
            r = 1;
          r < s.length;
          ++r
        )
          o +=
            `Reply:
    ` +
            s[r] +
            `
`
        t.push(si('t', $t(o)))
      }
      t.push('</text></comment>')
    }),
    t.push('</commentList>'),
    t.length > 2 && ((t[t.length] = '</comments>'), (t[1] = t[1].replace('/>', '>'))),
    t.join('')
  )
}
function nO(e, t, n) {
  var i = [Pn, Ne('ThreadedComments', null, { xmlns: qt.TCMNT }).replace(/[\/]>/, '>')]
  return (
    e.forEach(function (a) {
      var s = ''
      ;(a[1] || []).forEach(function (o, r) {
        if (!o.T) {
          delete o.ID
          return
        }
        o.a && t.indexOf(o.a) == -1 && t.push(o.a)
        var l = { ref: a[0], id: '{54EE7951-7262-4200-6969-' + ('000000000000' + n.tcid++).slice(-12) + '}' }
        r == 0 ? (s = l.id) : (l.parentId = s),
          (o.ID = l.id),
          o.a &&
            (l.personId = '{54EE7950-7262-4200-6969-' + ('000000000000' + t.indexOf(o.a)).slice(-12) + '}'),
          i.push(Ne('threadedComment', si('text', o.t || ''), l))
      })
    }),
    i.push('</ThreadedComments>'),
    i.join('')
  )
}
function iO(e) {
  var t = [Pn, Ne('personList', null, { xmlns: qt.TCMNT, 'xmlns:x': So[0] }).replace(/[\/]>/, '>')]
  return (
    e.forEach(function (n, i) {
      t.push(
        Ne('person', null, {
          displayName: n,
          id: '{54EE7950-7262-4200-6969-' + ('000000000000' + i).slice(-12) + '}',
          userId: n,
          providerId: 'None'
        })
      )
    }),
    t.push('</personList>'),
    t.join('')
  )
}
var aO = ['xlsb', 'xlsm', 'xlam', 'biff8', 'xla'],
  zl = typeof Map < 'u'
function sO(e, t, n) {
  var i = 0,
    a = e.length
  if (n) {
    if (zl ? n.has(t) : Object.prototype.hasOwnProperty.call(n, t)) {
      for (var s = zl ? n.get(t) : n[t]; i < s.length; ++i) if (e[s[i]].t === t) return e.Count++, s[i]
    }
  } else for (; i < a; ++i) if (e[i].t === t) return e.Count++, i
  return (
    (e[a] = { t }),
    e.Count++,
    e.Unique++,
    n &&
      (zl
        ? (n.has(t) || n.set(t, []), n.get(t).push(a))
        : (Object.prototype.hasOwnProperty.call(n, t) || (n[t] = []), n[t].push(a))),
    a
  )
}
function oO(e, t) {
  var n = { min: e + 1, max: e + 1 },
    i = -1
  return (
    t.MDW && (gc = t.MDW),
    t.width != null ? (n.customWidth = 1) : t.wpx != null ? (i = UL(t.wpx)) : t.wch != null && (i = t.wch),
    i > -1 ? ((n.width = YL(i)), (n.customWidth = 1)) : t.width != null && (n.width = t.width),
    t.hidden && (n.hidden = !0),
    t.level != null && (n.outlineLevel = n.level = t.level),
    n
  )
}
function rO(e, t) {
  if (e) {
    var n = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3]
    t == 'xlml' && (n = [1, 1, 1, 1, 0.5, 0.5]),
      e.left == null && (e.left = n[0]),
      e.right == null && (e.right = n[1]),
      e.top == null && (e.top = n[2]),
      e.bottom == null && (e.bottom = n[3]),
      e.header == null && (e.header = n[4]),
      e.footer == null && (e.footer = n[5])
  }
}
function K1(e, t, n) {
  var i = n.revssf[t.z != null ? t.z : 'General'],
    a = 60,
    s = e.length
  if (i == null && n.ssf) {
    for (; a < 392; ++a)
      if (n.ssf[a] == null) {
        M1(t.z, a), (n.ssf[a] = t.z), (n.revssf[t.z] = i = a)
        break
      }
  }
  for (a = 0; a != s; ++a) if (e[a].numFmtId === i) return a
  return (e[s] = { numFmtId: i, fontId: 0, fillId: 0, borderId: 0, xfId: 0, applyNumberFormat: 1 }), s
}
function lO(e, t, n) {
  if (e && e['!ref']) {
    var i = Vi(e['!ref'])
    if (i.e.c < i.s.c || i.e.r < i.s.r) throw new Error('Bad range (' + n + '): ' + e['!ref'])
  }
}
function cO(e) {
  if (e.length === 0) return ''
  for (var t = '<mergeCells count="' + e.length + '">', n = 0; n != e.length; ++n)
    t += '<mergeCell ref="' + fi(e[n]) + '"/>'
  return t + '</mergeCells>'
}
function uO(e, t, n, i, a) {
  var s = !1,
    o = {},
    r = null
  if (i.bookType !== 'xlsx' && t.vbaraw) {
    var l = t.SheetNames[n]
    try {
      t.Workbook && (l = t.Workbook.Sheets[n].CodeName || l)
    } catch {}
    ;(s = !0), (o.codeName = E1($t(l)))
  }
  if (e && e['!outline']) {
    var c = { summaryBelow: 1, summaryRight: 1 }
    e['!outline'].above && (c.summaryBelow = 0),
      e['!outline'].left && (c.summaryRight = 0),
      (r = (r || '') + Ne('outlinePr', null, c))
  }
  ;(!s && !r) || (a[a.length] = Ne('sheetPr', r, o))
}
var dO = ['objects', 'scenarios', 'selectLockedCells', 'selectUnlockedCells'],
  fO = [
    'formatColumns',
    'formatRows',
    'formatCells',
    'insertColumns',
    'insertRows',
    'insertHyperlinks',
    'deleteColumns',
    'deleteRows',
    'sort',
    'autoFilter',
    'pivotTables'
  ]
function hO(e) {
  var t = { sheet: 1 }
  return (
    dO.forEach(function (n) {
      e[n] != null && e[n] && (t[n] = '1')
    }),
    fO.forEach(function (n) {
      e[n] != null && !e[n] && (t[n] = '0')
    }),
    e.password && (t.password = WL(e.password).toString(16).toUpperCase()),
    Ne('sheetProtection', null, t)
  )
}
function vO(e) {
  return rO(e), Ne('pageMargins', null, e)
}
function gO(e, t) {
  for (var n = ['<cols>'], i, a = 0; a != t.length; ++a)
    (i = t[a]) && (n[n.length] = Ne('col', null, oO(a, i)))
  return (n[n.length] = '</cols>'), n.join('')
}
function mO(e, t, n, i) {
  var a = typeof e.ref == 'string' ? e.ref : fi(e.ref)
  n.Workbook || (n.Workbook = { Sheets: [] }), n.Workbook.Names || (n.Workbook.Names = [])
  var s = n.Workbook.Names,
    o = Tr(a)
  o.s.r == o.e.r && ((o.e.r = Tr(t['!ref']).e.r), (a = fi(o)))
  for (var r = 0; r < s.length; ++r) {
    var l = s[r]
    if (l.Name == '_xlnm._FilterDatabase' && l.Sheet == i) {
      l.Ref = "'" + n.SheetNames[i] + "'!" + a
      break
    }
  }
  return (
    r == s.length &&
      s.push({ Name: '_xlnm._FilterDatabase', Sheet: i, Ref: "'" + n.SheetNames[i] + "'!" + a }),
    Ne('autoFilter', null, { ref: a })
  )
}
function pO(e, t, n, i) {
  var a = { workbookViewId: '0' }
  return (
    (((i || {}).Workbook || {}).Views || [])[0] && (a.rightToLeft = i.Workbook.Views[0].RTL ? '1' : '0'),
    Ne('sheetViews', Ne('sheetView', null, a), {})
  )
}
function yO(e, t, n, i) {
  if (
    (e.c && n['!comments'].push([t, e.c]),
    (e.v === void 0 && typeof e.f != 'string') || (e.t === 'z' && !e.f))
  )
    return ''
  var a = '',
    s = e.t,
    o = e.v
  if (e.t !== 'z')
    switch (e.t) {
      case 'b':
        a = e.v ? '1' : '0'
        break
      case 'n':
        a = '' + e.v
        break
      case 'e':
        a = X1[e.v]
        break
      case 'd':
        i && i.cellDates
          ? (a = Wd(e.v, -1).toISOString())
          : ((e = Xr(e)), (e.t = 'n'), (a = '' + (e.v = gs(Wd(e.v))))),
          typeof e.z > 'u' && (e.z = ci[14])
        break
      default:
        a = e.v
        break
    }
  var r = si('v', $t(a)),
    l = { r: t },
    c = K1(i.cellXfs, e, i)
  switch ((c !== 0 && (l.s = c), e.t)) {
    case 'n':
      break
    case 'd':
      l.t = 'd'
      break
    case 'b':
      l.t = 'b'
      break
    case 'e':
      l.t = 'e'
      break
    case 'z':
      break
    default:
      if (e.v == null) {
        delete e.t
        break
      }
      if (e.v.length > 32767) throw new Error('Text length must not exceed 32767 characters')
      if (i && i.bookSST) {
        ;(r = si('v', '' + sO(i.Strings, e.v, i.revStrings))), (l.t = 's')
        break
      }
      l.t = 'str'
      break
  }
  if ((e.t != s && ((e.t = s), (e.v = o)), typeof e.f == 'string' && e.f)) {
    var u = e.F && e.F.slice(0, t.length) == t ? { t: 'array', ref: e.F } : null
    r = Ne('f', $t(e.f), u) + (e.v != null ? r : '')
  }
  return e.l && n['!links'].push([t, e.l]), e.D && (l.cm = 1), Ne('c', r, l)
}
function bO(e, t, n, i) {
  var a = [],
    s = [],
    o = Vi(e['!ref']),
    r = '',
    l,
    c = '',
    u = [],
    d = 0,
    f = 0,
    h = e['!rows'],
    v = Array.isArray(e),
    g = { r: c },
    p,
    y = -1
  for (f = o.s.c; f <= o.e.c; ++f) u[f] = ko(f)
  for (d = o.s.r; d <= o.e.r; ++d) {
    for (s = [], c = Cs(d), f = o.s.c; f <= o.e.c; ++f) {
      l = u[f] + c
      var b = v ? (e[d] || [])[f] : e[l]
      b !== void 0 && (r = yO(b, l, e, t)) != null && s.push(r)
    }
    ;(s.length > 0 || (h && h[d])) &&
      ((g = { r: c }),
      h &&
        h[d] &&
        ((p = h[d]),
        p.hidden && (g.hidden = 1),
        (y = -1),
        p.hpx ? (y = um(p.hpx)) : p.hpt && (y = p.hpt),
        y > -1 && ((g.ht = y), (g.customHeight = 1)),
        p.level && (g.outlineLevel = p.level)),
      (a[a.length] = Ne('row', s.join(''), g)))
  }
  if (h)
    for (; d < h.length; ++d)
      h &&
        h[d] &&
        ((g = { r: d + 1 }),
        (p = h[d]),
        p.hidden && (g.hidden = 1),
        (y = -1),
        p.hpx ? (y = um(p.hpx)) : p.hpt && (y = p.hpt),
        y > -1 && ((g.ht = y), (g.customHeight = 1)),
        p.level && (g.outlineLevel = p.level),
        (a[a.length] = Ne('row', '', g)))
  return a.join('')
}
function _O(e, t, n, i) {
  var a = [Pn, Ne('worksheet', null, { xmlns: So[0], 'xmlns:r': qt.r })],
    s = n.SheetNames[e],
    o = 0,
    r = '',
    l = n.Sheets[s]
  l == null && (l = {})
  var c = l['!ref'] || 'A1',
    u = Vi(c)
  if (u.e.c > 16383 || u.e.r > 1048575) {
    if (t.WTF) throw new Error('Range ' + c + ' exceeds format limit A1:XFD1048576')
    ;(u.e.c = Math.min(u.e.c, 16383)), (u.e.r = Math.min(u.e.c, 1048575)), (c = fi(u))
  }
  i || (i = {}), (l['!comments'] = [])
  var d = []
  uO(l, n, e, t, a),
    (a[a.length] = Ne('dimension', null, { ref: c })),
    (a[a.length] = pO(l, t, e, n)),
    t.sheetFormat &&
      (a[a.length] = Ne('sheetFormatPr', null, {
        defaultRowHeight: t.sheetFormat.defaultRowHeight || '16',
        baseColWidth: t.sheetFormat.baseColWidth || '10',
        outlineLevelRow: t.sheetFormat.outlineLevelRow || '7'
      })),
    l['!cols'] != null && l['!cols'].length > 0 && (a[a.length] = gO(l, l['!cols'])),
    (a[(o = a.length)] = '<sheetData/>'),
    (l['!links'] = []),
    l['!ref'] != null && ((r = bO(l, t)), r.length > 0 && (a[a.length] = r)),
    a.length > o + 1 && ((a[a.length] = '</sheetData>'), (a[o] = a[o].replace('/>', '>'))),
    l['!protect'] && (a[a.length] = hO(l['!protect'])),
    l['!autofilter'] != null && (a[a.length] = mO(l['!autofilter'], l, n, e)),
    l['!merges'] != null && l['!merges'].length > 0 && (a[a.length] = cO(l['!merges']))
  var f = -1,
    h,
    v = -1
  return (
    l['!links'].length > 0 &&
      ((a[a.length] = '<hyperlinks>'),
      l['!links'].forEach(function (g) {
        g[1].Target &&
          ((h = { ref: g[0] }),
          g[1].Target.charAt(0) != '#' &&
            ((v = on(i, -1, $t(g[1].Target).replace(/#.*$/, ''), Ht.HLINK)), (h['r:id'] = 'rId' + v)),
          (f = g[1].Target.indexOf('#')) > -1 && (h.location = $t(g[1].Target.slice(f + 1))),
          g[1].Tooltip && (h.tooltip = $t(g[1].Tooltip)),
          (a[a.length] = Ne('hyperlink', null, h)))
      }),
      (a[a.length] = '</hyperlinks>')),
    delete l['!links'],
    l['!margins'] != null && (a[a.length] = vO(l['!margins'])),
    (!t || t.ignoreEC || t.ignoreEC == null) &&
      (a[a.length] = si('ignoredErrors', Ne('ignoredError', null, { numberStoredAsText: 1, sqref: c }))),
    d.length > 0 &&
      ((v = on(i, -1, '../drawings/drawing' + (e + 1) + '.xml', Ht.DRAW)),
      (a[a.length] = Ne('drawing', null, { 'r:id': 'rId' + v })),
      (l['!drawing'] = d)),
    l['!comments'].length > 0 &&
      ((v = on(i, -1, '../drawings/vmlDrawing' + (e + 1) + '.vml', Ht.VML)),
      (a[a.length] = Ne('legacyDrawing', null, { 'r:id': 'rId' + v })),
      (l['!legacy'] = v)),
    a.length > 1 && ((a[a.length] = '</worksheet>'), (a[1] = a[1].replace('/>', '>'))),
    a.join('')
  )
}
var xO = [
    ['allowRefreshQuery', !1, 'bool'],
    ['autoCompressPictures', !0, 'bool'],
    ['backupFile', !1, 'bool'],
    ['checkCompatibility', !1, 'bool'],
    ['CodeName', ''],
    ['date1904', !1, 'bool'],
    ['defaultThemeVersion', 0, 'int'],
    ['filterPrivacy', !1, 'bool'],
    ['hidePivotFieldList', !1, 'bool'],
    ['promptedSolutions', !1, 'bool'],
    ['publishItems', !1, 'bool'],
    ['refreshAllConnections', !1, 'bool'],
    ['saveExternalLinkValues', !0, 'bool'],
    ['showBorderUnselectedTables', !0, 'bool'],
    ['showInkAnnotation', !0, 'bool'],
    ['showObjects', 'all'],
    ['showPivotChartFilter', !1, 'bool'],
    ['updateLinks', 'userSet']
  ],
  wO = '][*?/\\'.split('')
function q1(e, t) {
  if (e.length > 31) {
    if (t) return !1
    throw new Error('Sheet names cannot exceed 31 chars')
  }
  var n = !0
  return (
    wO.forEach(function (i) {
      if (e.indexOf(i) != -1) {
        if (!t) throw new Error('Sheet name cannot contain : \\ / ? * [ ]')
        n = !1
      }
    }),
    n
  )
}
function SO(e, t, n) {
  e.forEach(function (i, a) {
    q1(i)
    for (var s = 0; s < a; ++s) if (i == e[s]) throw new Error('Duplicate Sheet Name: ' + i)
    if (n) {
      var o = (t && t[a] && t[a].CodeName) || i
      if (o.charCodeAt(0) == 95 && o.length > 22) throw new Error('Bad Code Name: Worksheet' + o)
    }
  })
}
function kO(e) {
  if (!e || !e.SheetNames || !e.Sheets) throw new Error('Invalid Workbook')
  if (!e.SheetNames.length) throw new Error('Workbook is empty')
  var t = (e.Workbook && e.Workbook.Sheets) || []
  SO(e.SheetNames, t, !!e.vbaraw)
  for (var n = 0; n < e.SheetNames.length; ++n) lO(e.Sheets[e.SheetNames[n]], e.SheetNames[n], n)
}
function CO(e) {
  var t = [Pn]
  t[t.length] = Ne('workbook', null, { xmlns: So[0], 'xmlns:r': qt.r })
  var n = e.Workbook && (e.Workbook.Names || []).length > 0,
    i = { codeName: 'ThisWorkbook' }
  e.Workbook &&
    e.Workbook.WBProps &&
    (xO.forEach(function (r) {
      e.Workbook.WBProps[r[0]] != null &&
        e.Workbook.WBProps[r[0]] != r[1] &&
        (i[r[0]] = e.Workbook.WBProps[r[0]])
    }),
    e.Workbook.WBProps.CodeName && ((i.codeName = e.Workbook.WBProps.CodeName), delete i.CodeName)),
    (t[t.length] = Ne('workbookPr', null, i))
  var a = (e.Workbook && e.Workbook.Sheets) || [],
    s = 0
  if (a && a[0] && a[0].Hidden) {
    for (t[t.length] = '<bookViews>', s = 0; s != e.SheetNames.length && !(!a[s] || !a[s].Hidden); ++s);
    s == e.SheetNames.length && (s = 0),
      (t[t.length] = '<workbookView firstSheet="' + s + '" activeTab="' + s + '"/>'),
      (t[t.length] = '</bookViews>')
  }
  for (t[t.length] = '<sheets>', s = 0; s != e.SheetNames.length; ++s) {
    var o = { name: $t(e.SheetNames[s].slice(0, 31)) }
    if (((o.sheetId = '' + (s + 1)), (o['r:id'] = 'rId' + (s + 1)), a[s]))
      switch (a[s].Hidden) {
        case 1:
          o.state = 'hidden'
          break
        case 2:
          o.state = 'veryHidden'
          break
      }
    t[t.length] = Ne('sheet', null, o)
  }
  return (
    (t[t.length] = '</sheets>'),
    n &&
      ((t[t.length] = '<definedNames>'),
      e.Workbook &&
        e.Workbook.Names &&
        e.Workbook.Names.forEach(function (r) {
          var l = { name: r.Name }
          r.Comment && (l.comment = r.Comment),
            r.Sheet != null && (l.localSheetId = '' + r.Sheet),
            r.Hidden && (l.hidden = '1'),
            r.Ref && (t[t.length] = Ne('definedName', $t(r.Ref), l))
        }),
      (t[t.length] = '</definedNames>')),
    t.length > 2 && ((t[t.length] = '</workbook>'), (t[1] = t[1].replace('/>', '>'))),
    t.join('')
  )
}
function MO(e, t, n, i) {
  for (var a = e['!merges'] || [], s = [], o = t.s.c; o <= t.e.c; ++o) {
    for (var r = 0, l = 0, c = 0; c < a.length; ++c)
      if (!(a[c].s.r > n || a[c].s.c > o) && !(a[c].e.r < n || a[c].e.c < o)) {
        if (a[c].s.r < n || a[c].s.c < o) {
          r = -1
          break
        }
        ;(r = a[c].e.r - a[c].s.r + 1), (l = a[c].e.c - a[c].s.c + 1)
        break
      }
    if (!(r < 0)) {
      var u = ta({ r: n, c: o }),
        d = i.dense ? (e[n] || [])[o] : e[u],
        f = (d && d.v != null && (d.h || hL(d.w || (qr(d), d.w) || ''))) || '',
        h = {}
      r > 1 && (h.rowspan = r),
        l > 1 && (h.colspan = l),
        i.editable
          ? (f = '<span contenteditable="true">' + f + '</span>')
          : d &&
            ((h['data-t'] = (d && d.t) || 'z'),
            d.v != null && (h['data-v'] = d.v),
            d.z != null && (h['data-z'] = d.z),
            d.l &&
              (d.l.Target || '#').charAt(0) != '#' &&
              (f = '<a href="' + d.l.Target + '">' + f + '</a>')),
        (h.id = (i.id || 'sjs') + '-' + u),
        s.push(Ne('td', f, h))
    }
  }
  var v = '<tr>'
  return v + s.join('') + '</tr>'
}
var AO = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>',
  PO = '</body></html>'
function TO(e, t, n) {
  var i = []
  return i.join('') + '<table' + (n && n.id ? ' id="' + n.id + '"' : '') + '>'
}
function VO(e, t) {
  var n = t || {},
    i = n.header != null ? n.header : AO,
    a = n.footer != null ? n.footer : PO,
    s = [i],
    o = Tr(e['!ref'])
  ;(n.dense = Array.isArray(e)), s.push(TO(e, o, n))
  for (var r = o.s.r; r <= o.e.r; ++r) s.push(MO(e, o, r, n))
  return s.push('</table>' + a), s.join('')
}
function Z1(e, t, n) {
  var i = n || {},
    a = 0,
    s = 0
  if (i.origin != null)
    if (typeof i.origin == 'number') a = i.origin
    else {
      var o = typeof i.origin == 'string' ? Ci(i.origin) : i.origin
      ;(a = o.r), (s = o.c)
    }
  var r = t.getElementsByTagName('tr'),
    l = Math.min(i.sheetRows || 1e7, r.length),
    c = { s: { r: 0, c: 0 }, e: { r: a, c: s } }
  if (e['!ref']) {
    var u = Tr(e['!ref'])
    ;(c.s.r = Math.min(c.s.r, u.s.r)),
      (c.s.c = Math.min(c.s.c, u.s.c)),
      (c.e.r = Math.max(c.e.r, u.e.r)),
      (c.e.c = Math.max(c.e.c, u.e.c)),
      a == -1 && (c.e.r = a = u.e.r + 1)
  }
  var d = [],
    f = 0,
    h = e['!rows'] || (e['!rows'] = []),
    v = 0,
    g = 0,
    p = 0,
    y = 0,
    b = 0,
    x = 0
  for (e['!cols'] || (e['!cols'] = []); v < r.length && g < l; ++v) {
    var w = r[v]
    if (dm(w)) {
      if (i.display) continue
      h[g] = { hidden: !0 }
    }
    var C = w.children
    for (p = y = 0; p < C.length; ++p) {
      var P = C[p]
      if (!(i.display && dm(P))) {
        var k = P.hasAttribute('data-v')
            ? P.getAttribute('data-v')
            : P.hasAttribute('v')
            ? P.getAttribute('v')
            : gL(P.innerHTML),
          S = P.getAttribute('data-z') || P.getAttribute('z')
        for (f = 0; f < d.length; ++f) {
          var _ = d[f]
          _.s.c == y + s && _.s.r < g + a && g + a <= _.e.r && ((y = _.e.c + 1 - s), (f = -1))
        }
        ;(x = +P.getAttribute('colspan') || 1),
          ((b = +P.getAttribute('rowspan') || 1) > 1 || x > 1) &&
            d.push({ s: { r: g + a, c: y + s }, e: { r: g + a + (b || 1) - 1, c: y + s + (x || 1) - 1 } })
        var T = { t: 's', v: k },
          B = P.getAttribute('data-t') || P.getAttribute('t') || ''
        k != null &&
          (k.length == 0
            ? (T.t = B || 'z')
            : i.raw ||
              k.trim().length == 0 ||
              B == 's' ||
              (k === 'TRUE'
                ? (T = { t: 'b', v: !0 })
                : k === 'FALSE'
                ? (T = { t: 'b', v: !1 })
                : isNaN(em(k))
                ? isNaN(lL(k).getDate()) ||
                  ((T = { t: 'd', v: Wd(k) }),
                  i.cellDates || (T = { t: 'n', v: gs(T.v) }),
                  (T.z = i.dateNF || ci[14]))
                : (T = { t: 'n', v: em(k) }))),
          T.z === void 0 && S != null && (T.z = S)
        var O = '',
          N = P.getElementsByTagName('A')
        if (N && N.length)
          for (
            var Q = 0;
            Q < N.length &&
            !(N[Q].hasAttribute('href') && ((O = N[Q].getAttribute('href')), O.charAt(0) != '#'));
            ++Q
          );
        O && O.charAt(0) != '#' && (T.l = { Target: O }),
          i.dense
            ? (e[g + a] || (e[g + a] = []), (e[g + a][y + s] = T))
            : (e[ta({ c: y + s, r: g + a })] = T),
          c.e.c < y + s && (c.e.c = y + s),
          (y += x)
      }
    }
    ++g
  }
  return (
    d.length && (e['!merges'] = (e['!merges'] || []).concat(d)),
    (c.e.r = Math.max(c.e.r, g - 1 + a)),
    (e['!ref'] = fi(c)),
    g >= l && (e['!fullref'] = fi(((c.e.r = r.length - v + g - 1 + a), c))),
    e
  )
}
function J1(e, t) {
  var n = t || {},
    i = n.dense ? [] : {}
  return Z1(i, e, t)
}
function EO(e, t) {
  return VL(J1(e, t), t)
}
function dm(e) {
  var t = '',
    n = LO(e)
  return n && (t = n(e).getPropertyValue('display')), t || (t = e.style && e.style.display), t === 'none'
}
function LO(e) {
  return e.ownerDocument.defaultView && typeof e.ownerDocument.defaultView.getComputedStyle == 'function'
    ? e.ownerDocument.defaultView.getComputedStyle
    : typeof getComputedStyle == 'function'
    ? getComputedStyle
    : null
}
function OO(e) {
  return function (n) {
    for (var i = 0; i != e.length; ++i) {
      var a = e[i]
      n[a[0]] === void 0 && (n[a[0]] = a[1]), a[2] === 'n' && (n[a[0]] = Number(n[a[0]]))
    }
  }
}
function IO(e) {
  OO([
    ['cellDates', !1],
    ['bookSST', !1],
    ['bookType', 'xlsx'],
    ['compression', !1],
    ['WTF', !1]
  ])(e)
}
function DO(e, t) {
  ;(jo = 1024),
    e && !e.SSF && (e.SSF = Xr(ci)),
    e && e.SSF && (eL(), QE(e.SSF), (t.revssf = aL(e.SSF)), (t.revssf[e.SSF[65535]] = 0), (t.ssf = e.SSF)),
    (t.rels = {}),
    (t.wbrels = {}),
    (t.Strings = []),
    (t.Strings.Count = 0),
    (t.Strings.Unique = 0),
    zl ? (t.revStrings = new Map()) : ((t.revStrings = {}), (t.revStrings.foo = []), delete t.revStrings.foo)
  var n = 'xml',
    i = aO.indexOf(t.bookType) > -1,
    a = OL()
  IO((t = t || {}))
  var s = cL(),
    o = '',
    r = 0
  if (
    ((t.cellXfs = []),
    K1(t.cellXfs, {}, { revssf: { General: 0 } }),
    e.Props || (e.Props = {}),
    (o = 'docProps/core.xml'),
    Xt(s, o, FL(e.Props, t)),
    a.coreprops.push(o),
    on(t.rels, 2, o, Ht.CORE_PROPS),
    (o = 'docProps/app.xml'),
    !(e.Props && e.Props.SheetNames))
  )
    if (!e.Workbook || !e.Workbook.Sheets) e.Props.SheetNames = e.SheetNames
    else {
      for (var l = [], c = 0; c < e.SheetNames.length; ++c)
        (e.Workbook.Sheets[c] || {}).Hidden != 2 && l.push(e.SheetNames[c])
      e.Props.SheetNames = l
    }
  ;(e.Props.Worksheets = e.Props.SheetNames.length),
    Xt(s, o, BL(e.Props)),
    a.extprops.push(o),
    on(t.rels, 3, o, Ht.EXT_PROPS),
    e.Custprops !== e.Props &&
      Ra(e.Custprops || {}).length > 0 &&
      ((o = 'docProps/custom.xml'),
      Xt(s, o, NL(e.Custprops)),
      a.custprops.push(o),
      on(t.rels, 4, o, Ht.CUST_PROPS))
  var u = ['SheetJ5']
  for (t.tcid = 0, r = 1; r <= e.SheetNames.length; ++r) {
    var d = { '!id': {} },
      f = e.Sheets[e.SheetNames[r - 1]],
      h = (f || {})['!type'] || 'sheet'
    switch (h) {
      case 'chart':
      default:
        ;(o = 'xl/worksheets/sheet' + r + '.' + n),
          Xt(s, o, _O(r - 1, t, e, d)),
          a.sheets.push(o),
          on(t.wbrels, -1, 'worksheets/sheet' + r + '.' + n, Ht.WS[0])
    }
    if (f) {
      var v = f['!comments'],
        g = !1,
        p = ''
      if (v && v.length > 0) {
        var y = !1
        v.forEach(function (b) {
          b[1].forEach(function (x) {
            x.T == !0 && (y = !0)
          })
        }),
          y &&
            ((p = 'xl/threadedComments/threadedComment' + r + '.' + n),
            Xt(s, p, nO(v, u, t)),
            a.threadedcomments.push(p),
            on(d, -1, '../threadedComments/threadedComment' + r + '.' + n, Ht.TCMNT)),
          (p = 'xl/comments' + r + '.' + n),
          Xt(s, p, tO(v)),
          a.comments.push(p),
          on(d, -1, '../comments' + r + '.' + n, Ht.CMNT),
          (g = !0)
      }
      f['!legacy'] && g && Xt(s, 'xl/drawings/vmlDrawing' + r + '.vml', eO(r, f['!comments'])),
        delete f['!comments'],
        delete f['!legacy']
    }
    d['!id'].rId1 && Xt(s, DL(o), Lu(d))
  }
  return (
    t.Strings != null &&
      t.Strings.length > 0 &&
      ((o = 'xl/sharedStrings.' + n),
      Xt(s, o, zL(t.Strings, t)),
      a.strs.push(o),
      on(t.wbrels, -1, 'sharedStrings.' + n, Ht.SST)),
    (o = 'xl/workbook.' + n),
    Xt(s, o, CO(e)),
    a.workbooks.push(o),
    on(t.rels, 1, o, Ht.WB),
    (o = 'xl/theme/theme1.xml'),
    Xt(s, o, JL(e.Themes, t)),
    a.themes.push(o),
    on(t.wbrels, -1, 'theme/theme1.xml', Ht.THEME),
    (o = 'xl/styles.' + n),
    Xt(s, o, ZL(e, t)),
    a.styles.push(o),
    on(t.wbrels, -1, 'styles.' + n, Ht.STY),
    e.vbaraw &&
      i &&
      ((o = 'xl/vbaProject.bin'),
      Xt(s, o, e.vbaraw),
      a.vba.push(o),
      on(t.wbrels, -1, 'vbaProject.bin', Ht.VBA)),
    (o = 'xl/metadata.' + n),
    Xt(s, o, QL()),
    a.metadata.push(o),
    on(t.wbrels, -1, 'metadata.' + n, Ht.XLMETA),
    u.length > 1 &&
      ((o = 'xl/persons/person.xml'),
      Xt(s, o, iO(u)),
      a.people.push(o),
      on(t.wbrels, -1, 'persons/person.xml', Ht.PEOPLE)),
    Xt(s, '[Content_Types].xml', IL(a, t)),
    Xt(s, '_rels/.rels', Lu(t.rels)),
    Xt(s, 'xl/_rels/workbook.' + n + '.rels', Lu(t.wbrels)),
    delete t.revssf,
    delete t.ssf,
    s
  )
}
function FO(e, t) {
  switch (t.type) {
    case 'base64':
    case 'binary':
      break
    case 'buffer':
    case 'array':
      t.type = ''
      break
    case 'file':
      return A1(t.file, ti.write(e, { type: Pt ? 'buffer' : '' }))
    case 'string':
      throw new Error("'string' output type invalid for '" + t.bookType + "' files")
    default:
      throw new Error('Unrecognized type ' + t.type)
  }
  return ti.write(e, t)
}
function RO(e, t) {
  var n = Xr(t || {}),
    i = DO(e, n)
  return BO(i, n)
}
function BO(e, t) {
  var n = {},
    i = Pt ? 'nodebuffer' : typeof Uint8Array < 'u' ? 'array' : 'string'
  if ((t.compression && (n.compression = 'DEFLATE'), t.password)) n.type = i
  else
    switch (t.type) {
      case 'base64':
        n.type = 'base64'
        break
      case 'binary':
        n.type = 'string'
        break
      case 'string':
        throw new Error("'string' output type invalid for '" + t.bookType + "' files")
      case 'buffer':
      case 'file':
        n.type = i
        break
      default:
        throw new Error('Unrecognized type ' + t.type)
    }
  var a = e.FullPaths
    ? ti.write(e, {
        fileType: 'zip',
        type: { nodebuffer: 'buffer', string: 'binary' }[n.type] || n.type,
        compression: !!t.compression
      })
    : e.generate(n)
  if (typeof Deno < 'u' && typeof a == 'string') {
    if (t.type == 'binary' || t.type == 'base64') return a
    a = new Uint8Array(tu(a))
  }
  return t.password && typeof encrypt_agile < 'u'
    ? FO(encrypt_agile(a, t.password), t)
    : t.type === 'file'
    ? A1(t.file, a)
    : t.type == 'string'
    ? vL(a)
    : a
}
function Q1(e, t) {
  kO(e)
  var n = Xr(t || {})
  if ((n.cellStyles && ((n.cellNF = !0), (n.sheetStubs = !0)), n.type == 'array')) {
    n.type = 'binary'
    var i = Q1(e, n)
    return (n.type = 'array'), tu(i)
  }
  return RO(e, n)
}
function NO(e) {
  if (!e.bookType) {
    var t = { xls: 'biff8', htm: 'html', slk: 'sylk', socialcalc: 'eth', Sh33tJS: 'WTF' },
      n = e.file.slice(e.file.lastIndexOf('.')).toLowerCase()
    n.match(/^\.[a-z]+$/) && (e.bookType = n.slice(1)), (e.bookType = t[e.bookType] || e.bookType)
  }
}
function $O(e, t, n) {
  var i = n || {}
  return (i.type = 'file'), (i.file = t), NO(i), Q1(e, i)
}
function zO(e, t, n, i, a, s, o, r) {
  var l = Cs(n),
    c = r.defval,
    u = r.raw || !Object.prototype.hasOwnProperty.call(r, 'raw'),
    d = !0,
    f = a === 1 ? [] : {}
  if (a !== 1)
    if (Object.defineProperty)
      try {
        Object.defineProperty(f, '__rowNum__', { value: n, enumerable: !1 })
      } catch {
        f.__rowNum__ = n
      }
    else f.__rowNum__ = n
  if (!o || e[n])
    for (var h = t.s.c; h <= t.e.c; ++h) {
      var v = o ? e[n][h] : e[i[h] + l]
      if (v === void 0 || v.t === void 0) {
        if (c === void 0) continue
        s[h] != null && (f[s[h]] = c)
        continue
      }
      var g = v.v
      switch (v.t) {
        case 'z':
          if (g == null) break
          continue
        case 'e':
          g = g == 0 ? null : void 0
          break
        case 's':
        case 'd':
        case 'b':
        case 'n':
          break
        default:
          throw new Error('unrecognized type ' + v.t)
      }
      if (s[h] != null) {
        if (g == null)
          if (v.t == 'e' && g === null) f[s[h]] = null
          else if (c !== void 0) f[s[h]] = c
          else if (u && g === null) f[s[h]] = null
          else continue
        else f[s[h]] = u && (v.t !== 'n' || (v.t === 'n' && r.rawNumbers !== !1)) ? g : qr(v, g, r)
        g != null && (d = !1)
      }
    }
  return { row: f, isempty: d }
}
function fm(e, t) {
  if (e == null || e['!ref'] == null) return []
  var n = { t: 'n', v: 0 },
    i = 0,
    a = 1,
    s = [],
    o = 0,
    r = '',
    l = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } },
    c = t || {},
    u = c.range != null ? c.range : e['!ref']
  switch (
    (c.header === 1
      ? (i = 1)
      : c.header === 'A'
      ? (i = 2)
      : Array.isArray(c.header)
      ? (i = 3)
      : c.header == null && (i = 0),
    typeof u)
  ) {
    case 'string':
      l = Vi(u)
      break
    case 'number':
      ;(l = Vi(e['!ref'])), (l.s.r = u)
      break
    default:
      l = u
  }
  i > 0 && (a = 0)
  var d = Cs(l.s.r),
    f = [],
    h = [],
    v = 0,
    g = 0,
    p = Array.isArray(e),
    y = l.s.r,
    b = 0,
    x = {}
  p && !e[y] && (e[y] = [])
  var w = (c.skipHidden && e['!cols']) || [],
    C = (c.skipHidden && e['!rows']) || []
  for (b = l.s.c; b <= l.e.c; ++b)
    if (!(w[b] || {}).hidden)
      switch (((f[b] = ko(b)), (n = p ? e[y][b] : e[f[b] + d]), i)) {
        case 1:
          s[b] = b - l.s.c
          break
        case 2:
          s[b] = f[b]
          break
        case 3:
          s[b] = c.header[b - l.s.c]
          break
        default:
          if ((n == null && (n = { w: '__EMPTY', t: 's' }), (r = o = qr(n, null, c)), (g = x[o] || 0), !g))
            x[o] = 1
          else {
            do r = o + '_' + g++
            while (x[r])
            ;(x[o] = g), (x[r] = 1)
          }
          s[b] = r
      }
  for (y = l.s.r + a; y <= l.e.r; ++y)
    if (!(C[y] || {}).hidden) {
      var P = zO(e, l, y, f, i, s, p, c)
      ;(P.isempty === !1 || (i === 1 ? c.blankrows !== !1 : c.blankrows)) && (h[v++] = P.row)
    }
  return (h.length = v), h
}
var hm = /"/g
function HO(e, t, n, i, a, s, o, r) {
  for (var l = !0, c = [], u = '', d = Cs(n), f = t.s.c; f <= t.e.c; ++f)
    if (i[f]) {
      var h = r.dense ? (e[n] || [])[f] : e[i[f] + d]
      if (h == null) u = ''
      else if (h.v != null) {
        ;(l = !1), (u = '' + (r.rawNumbers && h.t == 'n' ? h.v : qr(h, null, r)))
        for (var v = 0, g = 0; v !== u.length; ++v)
          if ((g = u.charCodeAt(v)) === a || g === s || g === 34 || r.forceQuotes) {
            u = '"' + u.replace(hm, '""') + '"'
            break
          }
        u == 'ID' && (u = '"ID"')
      } else
        h.f != null && !h.F
          ? ((l = !1), (u = '=' + h.f), u.indexOf(',') >= 0 && (u = '"' + u.replace(hm, '""') + '"'))
          : (u = '')
      c.push(u)
    }
  return r.blankrows === !1 && l ? null : c.join(o)
}
function e_(e, t) {
  var n = [],
    i = t ?? {}
  if (e == null || e['!ref'] == null) return ''
  var a = Vi(e['!ref']),
    s = i.FS !== void 0 ? i.FS : ',',
    o = s.charCodeAt(0),
    r =
      i.RS !== void 0
        ? i.RS
        : `
`,
    l = r.charCodeAt(0),
    c = new RegExp((s == '|' ? '\\|' : s) + '+$'),
    u = '',
    d = []
  i.dense = Array.isArray(e)
  for (
    var f = (i.skipHidden && e['!cols']) || [], h = (i.skipHidden && e['!rows']) || [], v = a.s.c;
    v <= a.e.c;
    ++v
  )
    (f[v] || {}).hidden || (d[v] = ko(v))
  for (var g = 0, p = a.s.r; p <= a.e.r; ++p)
    (h[p] || {}).hidden ||
      ((u = HO(e, a, p, d, o, l, s, i)),
      u != null &&
        (i.strip && (u = u.replace(c, '')), (u || i.blankrows !== !1) && n.push((g++ ? r : '') + u)))
  return delete i.dense, n.join('')
}
function WO(e, t) {
  t || (t = {}),
    (t.FS = '	'),
    (t.RS = `
`)
  var n = e_(e, t)
  return n
}
function jO(e) {
  var t = '',
    n,
    i = ''
  if (e == null || e['!ref'] == null) return []
  var a = Vi(e['!ref']),
    s = '',
    o = [],
    r,
    l = [],
    c = Array.isArray(e)
  for (r = a.s.c; r <= a.e.c; ++r) o[r] = ko(r)
  for (var u = a.s.r; u <= a.e.r; ++u)
    for (s = Cs(u), r = a.s.c; r <= a.e.c; ++r)
      if (((t = o[r] + s), (n = c ? (e[u] || [])[r] : e[t]), (i = ''), n !== void 0)) {
        if (n.F != null) {
          if (((t = n.F), !n.f)) continue
          ;(i = n.f), t.indexOf(':') == -1 && (t = t + ':' + t)
        }
        if (n.f != null) i = n.f
        else {
          if (n.t == 'z') continue
          if (n.t == 'n' && n.v != null) i = '' + n.v
          else if (n.t == 'b') i = n.v ? 'TRUE' : 'FALSE'
          else if (n.w !== void 0) i = "'" + n.w
          else {
            if (n.v === void 0) continue
            n.t == 's' ? (i = "'" + n.v) : (i = '' + n.v)
          }
        }
        l[l.length] = t + '=' + i
      }
  return l
}
function t_(e, t, n) {
  var i = n || {},
    a = +!i.skipHeader,
    s = e || {},
    o = 0,
    r = 0
  if (s && i.origin != null)
    if (typeof i.origin == 'number') o = i.origin
    else {
      var l = typeof i.origin == 'string' ? Ci(i.origin) : i.origin
      ;(o = l.r), (r = l.c)
    }
  var c,
    u = { s: { c: 0, r: 0 }, e: { c: r, r: o + t.length - 1 + a } }
  if (s['!ref']) {
    var d = Vi(s['!ref'])
    ;(u.e.c = Math.max(u.e.c, d.e.c)),
      (u.e.r = Math.max(u.e.r, d.e.r)),
      o == -1 && ((o = d.e.r + 1), (u.e.r = o + t.length - 1 + a))
  } else o == -1 && ((o = 0), (u.e.r = t.length - 1 + a))
  var f = i.header || [],
    h = 0
  t.forEach(function (g, p) {
    Ra(g).forEach(function (y) {
      ;(h = f.indexOf(y)) == -1 && (f[(h = f.length)] = y)
      var b = g[y],
        x = 'z',
        w = '',
        C = ta({ c: r + h, r: o + p + a })
      ;(c = Vr(s, C)),
        b && typeof b == 'object' && !(b instanceof Date)
          ? (s[C] = b)
          : (typeof b == 'number'
              ? (x = 'n')
              : typeof b == 'boolean'
              ? (x = 'b')
              : typeof b == 'string'
              ? (x = 's')
              : b instanceof Date
              ? ((x = 'd'), i.cellDates || ((x = 'n'), (b = gs(b))), (w = i.dateNF || ci[14]))
              : b === null && i.nullError && ((x = 'e'), (b = 0)),
            c ? ((c.t = x), (c.v = b), delete c.w, delete c.R, w && (c.z = w)) : (s[C] = c = { t: x, v: b }),
            w && (c.z = w))
    })
  }),
    (u.e.c = Math.max(u.e.c, r + f.length - 1))
  var v = Cs(o)
  if (a) for (h = 0; h < f.length; ++h) s[ko(h + r) + v] = { t: 's', v: f[h] }
  return (s['!ref'] = fi(u)), s
}
function UO(e, t) {
  return t_(null, e, t)
}
function Vr(e, t, n) {
  if (typeof t == 'string') {
    if (Array.isArray(e)) {
      var i = Ci(t)
      return e[i.r] || (e[i.r] = []), e[i.r][i.c] || (e[i.r][i.c] = { t: 'z' })
    }
    return e[t] || (e[t] = { t: 'z' })
  }
  return typeof t != 'number' ? Vr(e, ta(t)) : Vr(e, ta({ r: t, c: n || 0 }))
}
function YO(e, t) {
  if (typeof t == 'number') {
    if (t >= 0 && e.SheetNames.length > t) return t
    throw new Error('Cannot find sheet # ' + t)
  } else if (typeof t == 'string') {
    var n = e.SheetNames.indexOf(t)
    if (n > -1) return n
    throw new Error('Cannot find sheet name |' + t + '|')
  } else throw new Error('Cannot find sheet |' + t + '|')
}
function GO() {
  return { SheetNames: [], Sheets: {} }
}
function XO(e, t, n, i) {
  var a = 1
  if (!n) for (; a <= 65535 && e.SheetNames.indexOf((n = 'Sheet' + a)) != -1; ++a, n = void 0);
  if (!n || e.SheetNames.length >= 65535) throw new Error('Too many worksheets')
  if (i && e.SheetNames.indexOf(n) >= 0) {
    var s = n.match(/(^.*?)(\d+)$/)
    a = (s && +s[2]) || 0
    var o = (s && s[1]) || n
    for (++a; a <= 65535 && e.SheetNames.indexOf((n = o + a)) != -1; ++a);
  }
  if ((q1(n), e.SheetNames.indexOf(n) >= 0))
    throw new Error('Worksheet with name |' + n + '| already exists!')
  return e.SheetNames.push(n), (e.Sheets[n] = t), n
}
function KO(e, t, n) {
  e.Workbook || (e.Workbook = {}), e.Workbook.Sheets || (e.Workbook.Sheets = [])
  var i = YO(e, t)
  switch ((e.Workbook.Sheets[i] || (e.Workbook.Sheets[i] = {}), n)) {
    case 0:
    case 1:
    case 2:
      break
    default:
      throw new Error('Bad sheet visibility setting ' + n)
  }
  e.Workbook.Sheets[i].Hidden = n
}
function qO(e, t) {
  return (e.z = t), e
}
function n_(e, t, n) {
  return t ? ((e.l = { Target: t }), n && (e.l.Tooltip = n)) : delete e.l, e
}
function ZO(e, t, n) {
  return n_(e, '#' + t, n)
}
function JO(e, t, n) {
  e.c || (e.c = []), e.c.push({ t, a: n || 'SheetJS' })
}
function QO(e, t, n, i) {
  for (
    var a = typeof t != 'string' ? t : Vi(t), s = typeof t == 'string' ? t : fi(t), o = a.s.r;
    o <= a.e.r;
    ++o
  )
    for (var r = a.s.c; r <= a.e.c; ++r) {
      var l = Vr(e, o, r)
      ;(l.t = 'n'), (l.F = s), delete l.v, o == a.s.r && r == a.s.c && ((l.f = n), i && (l.D = !0))
    }
  return e
}
var Iu = {
  encode_col: ko,
  encode_row: Cs,
  encode_cell: ta,
  encode_range: fi,
  decode_col: AL,
  decode_row: CL,
  split_cell: TL,
  decode_cell: Ci,
  decode_range: Tr,
  format_cell: qr,
  sheet_add_aoa: G1,
  sheet_add_json: t_,
  sheet_add_dom: Z1,
  aoa_to_sheet: EL,
  json_to_sheet: UO,
  table_to_sheet: J1,
  table_to_book: EO,
  sheet_to_csv: e_,
  sheet_to_txt: WO,
  sheet_to_json: fm,
  sheet_to_html: VO,
  sheet_to_formulae: jO,
  sheet_to_row_object_array: fm,
  sheet_get_cell: Vr,
  book_new: GO,
  book_append_sheet: XO,
  book_set_sheet_visibility: KO,
  cell_set_number_format: qO,
  cell_set_hyperlink: n_,
  cell_set_internal_link: ZO,
  cell_add_comment: JO,
  sheet_set_array_formula: QO,
  consts: { SHEET_VISIBLE: 0, SHEET_HIDDEN: 1, SHEET_VERY_HIDDEN: 2 }
}
const nu = (e, t = 'NuovoData') => {
    const n = Iu.json_to_sheet(e),
      i = Iu.book_new()
    Iu.book_append_sheet(i, n, t), $O(i, `${t}Report.xlsx`)
  },
  wh = (e) => (Ea('data-v-67c2a757'), (e = e()), La(), e),
  eI = wh(() => z('div', { class: 'title' }, [z('h3', null, 'CLIENTS')], -1)),
  tI = { class: 'actions' },
  nI = { class: 'download' },
  iI = { class: 'stats' },
  aI = { class: 'numbers' },
  sI = { class: 'btn' },
  oI = { key: 0, class: 'filter' },
  rI = wh(() => z('b', null, 'Click refresh to clear filters', -1)),
  lI = [rI],
  cI = { class: 'filter' },
  uI = wh(() =>
    z(
      'thead',
      null,
      [
        z('tr', null, [
          z('th', { class: 'text-left' }, 'Full Name'),
          z('th', { class: 'text-left' }, 'ID Number'),
          z('th', { class: 'text-left' }, 'Phone Number'),
          z('th', { class: 'text-left' }, 'Location'),
          z('th', { class: 'text-left' }, 'Status'),
          z('th', { class: 'text-left' }, 'Date Created'),
          z('th', { class: 'text-left' }, 'Date Updated')
        ])
      ],
      -1
    )
  ),
  dI = { key: 2, class: 'text-center pagination' },
  fI = { key: 3, class: 'text-center info' },
  hI = { key: 4, class: 'text-center info' },
  vI = hn({
    __name: 'Client',
    setup(e) {
      const n = te([]),
        i = te(!0),
        a = te(!1),
        s = te({}),
        o = te(!1),
        r = te(1),
        l = te(0),
        c = te(0),
        u = async (g = {}) => {
          a.value = !0
          const p = await zd(g)
          p.code === 401
            ? ((i.value = !1), (a.value = !1))
            : ((n.value = p.data),
              (a.value = !1),
              (l.value = Math.ceil(p.total / p.limit)),
              (c.value = p.total))
        },
        d = (g) => {
          o.value = !0
          for (let y in g) g[y] || delete g[y]
          const p = { ...g }
          ;(s.value = p), u(p)
        }
      Ut(async () => {
        u()
      })
      const f = () => {
          if (r.value >= 1) {
            const g = { ...s.value, $skip: r.value == 1 ? 0 : r.value * 15 - 15 }
            u(g)
          }
        },
        h = () => {
          if (r.value >= 1) {
            console.log(r.value)
            const g = { ...s.value, $skip: r.value == 1 ? 0 : r.value * 15 - 15 }
            u(g)
          }
        },
        v = async () => {
          const p = (await zd({ $limit: 1e3, ...s.value })).data.map((y, b) => ({
            No: b + 1,
            Name: y.fullName,
            'ID Number': y.idNumber,
            'Phone Number': y.phoneNumber,
            'Email Address': y.emailAddress,
            Status: y.status == 1 ? 'Active' : 'Inactive',
            'Date Created': Wt(y.createdAt)
          }))
          nu(p, 'clients')
        }
      return (g, p) => {
        var P, k, S
        const y = Se('v-progress-linear'),
          b = Se('v-divider'),
          x = Se('v-btn'),
          w = Se('v-table'),
          C = Se('v-pagination')
        return (
          Re(),
          et(
            Oe,
            null,
            [
              a.value
                ? (Re(), Ct(y, { key: 0, class: 'loader', indeterminate: '', color: 'cyan' }))
                : ct('', !0),
              eI,
              m(b, { color: 'success' }),
              z('div', tI, [
                z('div', nI, [
                  m(
                    x,
                    { color: 'grey', onClick: v, 'prepend-icon': 'mdi-cloud' },
                    { default: we(() => [nt('Dowload')]), _: 1 }
                  )
                ]),
                z('div', iI, [z('div', aI, [z('p', null, [nt('TOTAL: '), z('b', null, ze(c.value), 1)])])]),
                z('div', sI, [
                  o.value ? (Re(), et('small', oI, lI)) : ct('', !0),
                  z('div', cI, [m(CE, { onClicked: d })]),
                  m(
                    x,
                    {
                      color: 'green',
                      onClick: p[0] || (p[0] = (_) => (u(), (o.value = !1))),
                      'prepend-icon': 'mdi-bin'
                    },
                    { default: we(() => [nt('Refresh')]), _: 1 }
                  )
                ])
              ]),
              (P = n.value) != null && P.length
                ? (Re(),
                  Ct(
                    w,
                    { key: 1, theme: 'default', height: 700 },
                    {
                      default: we(() => [
                        uI,
                        z('tbody', null, [
                          (Re(!0),
                          et(
                            Oe,
                            null,
                            Xi(
                              n.value,
                              (_) => (
                                Re(),
                                et('tr', { key: _.id }, [
                                  z('td', null, ze(_.fullName), 1),
                                  z('td', null, ze(_.idNumber), 1),
                                  z('td', null, ze(_.phoneNumber), 1),
                                  z('td', null, ze(_.location), 1),
                                  z('td', null, [
                                    z(
                                      'span',
                                      { class: ki(_.status == 1 ? 'active status' : 'inactive status') },
                                      ze(_.status == 1 ? 'Active' : 'Inactive'),
                                      3
                                    )
                                  ]),
                                  z('td', null, ze(Xe(Wt)(_.createdAt)), 1),
                                  z('td', null, ze(Xe(Wt)(_.updatedAt)), 1)
                                ])
                              )
                            ),
                            128
                          ))
                        ])
                      ]),
                      _: 1
                    }
                  ))
                : ct('', !0),
              (k = n.value) != null && k.length
                ? (Re(),
                  et('div', dI, [
                    m(
                      C,
                      {
                        'total-visible': 1,
                        onPrev: f,
                        onNext: h,
                        modelValue: r.value,
                        'onUpdate:modelValue': p[1] || (p[1] = (_) => (r.value = _)),
                        length: l.value,
                        rounded: 'circle'
                      },
                      null,
                      8,
                      ['modelValue', 'length']
                    )
                  ]))
                : ct('', !0),
              i.value && !((S = n.value) != null && S.length)
                ? (Re(), et('div', fI, [m(wo, { message: 'Clients' })]))
                : ct('', !0),
              i.value ? ct('', !0) : (Re(), et('div', hI, [m(eu, { message: 'viewClients' })]))
            ],
            64
          )
        )
      }
    }
  })
const gI = Oi(vI, [['__scopeId', 'data-v-67c2a757']]),
  Sh = (e) => (Ea('data-v-b46734eb'), (e = e()), La(), e),
  mI = Sh(() =>
    z(
      'thead',
      null,
      [
        z('tr', null, [
          z('th', { class: 'text-left' }, 'Name'),
          z('th', { class: 'text-left' }, 'ID Number'),
          z('th', { class: 'text-left' }, 'Status')
        ])
      ],
      -1
    )
  ),
  pI = Sh(() =>
    z(
      'thead',
      null,
      [
        z('tr', null, [
          z('th', { class: 'text-left' }, 'Account ID'),
          z('th', { class: 'text-left' }, 'Loan Name'),
          z('th', { class: 'text-left' }, 'Loan IMEI'),
          z('th', { class: 'text-left' }, 'Data Synced')
        ])
      ],
      -1
    )
  ),
  yI = Sh(() =>
    z(
      'thead',
      null,
      [
        z('tr', null, [
          z('th', { class: 'text-left' }, 'IMEI'),
          z('th', { class: 'text-left' }, 'Status'),
          z('th', { class: 'text-left' }, 'Synced'),
          z('th', { class: 'text-left' }, 'Locked')
        ])
      ],
      -1
    )
  ),
  bI = hn({
    __name: 'Dialog',
    props: { data: {}, type: {}, title: {} },
    setup(e) {
      return (t, n) => {
        const i = Se('v-btn'),
          a = Se('v-table'),
          s = Se('v-spacer'),
          o = Se('v-card-actions'),
          r = Se('v-card'),
          l = Se('v-dialog')
        return (
          Re(),
          Ct(
            l,
            { width: '500' },
            {
              activator: we(({ props: c }) => [
                m(i, xe(c, { color: 'green', icon: 'mdi-eye', title: 'view', size: 'small' }), null, 16)
              ]),
              default: we(({ isActive: c }) => [
                m(
                  r,
                  { title: t.title },
                  {
                    default: we(() => [
                      z('div', null, [
                        t.type == 'client'
                          ? (Re(),
                            Ct(
                              a,
                              { key: 0, density: 'compact' },
                              {
                                default: we(() => [
                                  mI,
                                  z('tbody', null, [
                                    (Re(!0),
                                    et(
                                      Oe,
                                      null,
                                      Xi(
                                        t.data,
                                        (u) => (
                                          Re(),
                                          et('tr', { key: u.name }, [
                                            z('td', null, ze(u.fullName), 1),
                                            z('td', null, ze(u.idNumber), 1),
                                            z('td', null, [
                                              z(
                                                'span',
                                                {
                                                  class: ki(
                                                    u.status == 1 ? 'active status' : 'inactive status'
                                                  )
                                                },
                                                ze(u.status == 1 ? 'Active' : 'Inactive'),
                                                3
                                              )
                                            ])
                                          ])
                                        )
                                      ),
                                      128
                                    ))
                                  ])
                                ]),
                                _: 1
                              }
                            ))
                          : ct('', !0),
                        t.type == 'loan'
                          ? (Re(),
                            Ct(
                              a,
                              { key: 1, density: 'compact' },
                              {
                                default: we(() => [
                                  pI,
                                  z('tbody', null, [
                                    (Re(!0),
                                    et(
                                      Oe,
                                      null,
                                      Xi(
                                        t.data,
                                        (u) => (
                                          Re(),
                                          et('tr', { key: u.name }, [
                                            z('td', null, ze(u.accountId), 1),
                                            z('td', null, ze(u.loanName), 1),
                                            z('td', null, ze(u.mambuImei), 1),
                                            z('td', null, [
                                              z(
                                                'span',
                                                {
                                                  class: ki(
                                                    u.mambuSynced == 1 ? 'active status' : 'inactive status'
                                                  )
                                                },
                                                ze(u.mambuSynced == 1 ? 'Yes' : 'No'),
                                                3
                                              )
                                            ])
                                          ])
                                        )
                                      ),
                                      128
                                    ))
                                  ])
                                ]),
                                _: 1
                              }
                            ))
                          : ct('', !0),
                        t.type == 'device'
                          ? (Re(),
                            Ct(
                              a,
                              { key: 2, density: 'compact' },
                              {
                                default: we(() => [
                                  yI,
                                  z('tbody', null, [
                                    (Re(!0),
                                    et(
                                      Oe,
                                      null,
                                      Xi(
                                        t.data,
                                        (u) => (
                                          Re(),
                                          et('tr', { key: u.name }, [
                                            z('td', null, ze(u.imei), 1),
                                            z('td', null, ze(u.status), 1),
                                            z('td', null, [
                                              z(
                                                'span',
                                                {
                                                  class: ki(
                                                    u.mambuSynced == 1 ? 'active status' : 'inactive status'
                                                  )
                                                },
                                                ze(u.mambuSynced == 1 ? 'Yes' : 'No'),
                                                3
                                              )
                                            ]),
                                            z('td', null, [
                                              z(
                                                'span',
                                                {
                                                  class: ki(
                                                    u.locked == 1 ? 'active status' : 'inactive status'
                                                  )
                                                },
                                                ze(u.locked == 1 ? 'Yes' : 'No'),
                                                3
                                              )
                                            ])
                                          ])
                                        )
                                      ),
                                      128
                                    ))
                                  ])
                                ]),
                                _: 1
                              }
                            ))
                          : ct('', !0)
                      ]),
                      m(
                        o,
                        null,
                        {
                          default: we(() => [
                            m(s),
                            m(i, { color: 'red', text: 'Close', onClick: (u) => (c.value = !1) }, null, 8, [
                              'onClick'
                            ])
                          ]),
                          _: 2
                        },
                        1024
                      )
                    ]),
                    _: 2
                  },
                  1032,
                  ['title']
                )
              ]),
              _: 1
            }
          )
        )
      }
    }
  })
const Er = Oi(bI, [['__scopeId', 'data-v-b46734eb']]),
  _I = z('span', { class: 'text-h5' }, 'Filter Options', -1),
  xI = hn({
    __name: 'DeviceFilter',
    props: { options: {} },
    setup(e) {
      const t = te({ imei: '', serialNo: '', make: '', locked: '', clientId: '' }),
        n = te(!1)
      return (i, a) => {
        const s = Se('v-btn'),
          o = Se('v-card-title'),
          r = Se('v-text-field'),
          l = Se('v-col'),
          c = Se('v-autocomplete'),
          u = Se('v-row'),
          d = Se('v-container'),
          f = Se('v-card-text'),
          h = Se('v-spacer'),
          v = Se('v-card-actions'),
          g = Se('v-card'),
          p = Se('v-dialog')
        return (
          Re(),
          Ct(
            p,
            {
              modelValue: n.value,
              'onUpdate:modelValue': a[7] || (a[7] = (y) => (n.value = y)),
              theme: 'dark',
              width: '600'
            },
            {
              activator: we(({ props: y }) => [
                m(
                  s,
                  xe({ color: 'blue' }, y, { class: 'filter', 'prepend-icon': 'filter' }),
                  { default: we(() => [nt(' Filter ')]), _: 2 },
                  1040
                )
              ]),
              default: we(() => [
                m(g, null, {
                  default: we(() => [
                    m(o, null, { default: we(() => [_I]), _: 1 }),
                    m(f, null, {
                      default: we(() => [
                        m(d, null, {
                          default: we(() => [
                            m(u, null, {
                              default: we(() => [
                                m(
                                  l,
                                  { cols: '12', sm: '6', md: '6' },
                                  {
                                    default: we(() => [
                                      m(
                                        r,
                                        {
                                          modelValue: t.value.imei,
                                          'onUpdate:modelValue': a[0] || (a[0] = (y) => (t.value.imei = y)),
                                          label: 'IMEI'
                                        },
                                        null,
                                        8,
                                        ['modelValue']
                                      )
                                    ]),
                                    _: 1
                                  }
                                ),
                                m(
                                  l,
                                  { cols: '12', sm: '6', md: '6' },
                                  {
                                    default: we(() => [
                                      m(
                                        r,
                                        {
                                          label: 'Serial Number',
                                          hint: 'Example 238484',
                                          modelValue: t.value.serialNo,
                                          'onUpdate:modelValue':
                                            a[1] || (a[1] = (y) => (t.value.serialNo = y))
                                        },
                                        null,
                                        8,
                                        ['modelValue']
                                      )
                                    ]),
                                    _: 1
                                  }
                                ),
                                m(
                                  l,
                                  { cols: '12', sm: '6', md: '6' },
                                  {
                                    default: we(() => [
                                      m(
                                        r,
                                        {
                                          modelValue: t.value.make,
                                          'onUpdate:modelValue': a[2] || (a[2] = (y) => (t.value.make = y)),
                                          label: 'Make'
                                        },
                                        null,
                                        8,
                                        ['modelValue']
                                      )
                                    ]),
                                    _: 1
                                  }
                                ),
                                m(
                                  l,
                                  { cols: '12', sm: '6' },
                                  {
                                    default: we(() => [
                                      m(
                                        c,
                                        {
                                          items: [
                                            { label: 'Locked', value: 1 },
                                            { label: 'Unlocked', value: 0 }
                                          ],
                                          label: 'Lock Status',
                                          'item-title': 'label',
                                          'item-value': 'value',
                                          modelValue: t.value.locked,
                                          'onUpdate:modelValue': a[3] || (a[3] = (y) => (t.value.locked = y))
                                        },
                                        null,
                                        8,
                                        ['modelValue']
                                      )
                                    ]),
                                    _: 1
                                  }
                                ),
                                m(
                                  l,
                                  { cols: '12', sm: '6' },
                                  {
                                    default: we(() => [
                                      m(
                                        c,
                                        {
                                          items: i.options,
                                          'item-title': 'fullName',
                                          'item-value': 'id',
                                          label: 'Client',
                                          modelValue: t.value.clientId,
                                          'onUpdate:modelValue':
                                            a[4] || (a[4] = (y) => (t.value.clientId = y))
                                        },
                                        null,
                                        8,
                                        ['items', 'modelValue']
                                      )
                                    ]),
                                    _: 1
                                  }
                                )
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    m(v, null, {
                      default: we(() => [
                        m(h),
                        m(
                          s,
                          {
                            color: 'blue-darken-1',
                            variant: 'text',
                            onClick: a[5] || (a[5] = (y) => (n.value = !1))
                          },
                          { default: we(() => [nt(' Close ')]), _: 1 }
                        ),
                        m(
                          s,
                          {
                            color: 'blue-darken-1',
                            variant: 'text',
                            onClick: a[6] || (a[6] = (y) => (i.$emit('clicked', t.value), (n.value = !1)))
                          },
                          { default: we(() => [nt(' Filter ')]), _: 1 }
                        )
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            },
            8,
            ['modelValue']
          )
        )
      }
    }
  }),
  kh = (e) => (Ea('data-v-9335a25e'), (e = e()), La(), e),
  wI = kh(() => z('div', { class: 'title' }, [z('h3', null, 'DEVICES')], -1)),
  SI = { class: 'actions' },
  kI = { class: 'download' },
  CI = { class: 'stats' },
  MI = { class: 'numbers' },
  AI = { class: 'btn' },
  PI = { key: 0, class: 'filter' },
  TI = kh(() => z('b', null, 'Click refresh to clear filters', -1)),
  VI = [TI],
  EI = { class: 'filter' },
  LI = kh(() =>
    z(
      'thead',
      null,
      [
        z('tr', null, [
          z('th', { class: 'text-left' }, 'IMEI'),
          z('th', { class: 'text-left' }, 'Serial No'),
          z('th', { class: 'text-left' }, 'Make'),
          z('th', { class: 'text-left' }, 'Model'),
          z('th', { class: 'text-left' }, 'Status'),
          z('th', { class: 'text-left' }, 'Mambu Synced'),
          z('th', { class: 'text-left' }, 'Nuovo Synced'),
          z('th', { class: 'text-left' }, 'Locked'),
          z('th', { class: 'text-left' }, 'Next Lock Date'),
          z('th', { class: 'text-left' }, 'Last Connected At'),
          z('th', { class: 'text-left' }, 'Customer'),
          z('th', { class: 'text-left' }, 'Loan'),
          z('th', { class: 'text-left' }, 'Date Created'),
          z('th', { class: 'text-left' }, 'Date Updated')
        ])
      ],
      -1
    )
  ),
  OI = { key: 2, class: 'text-center pagination' },
  II = { key: 3, class: 'text-center info' },
  DI = { key: 4, class: 'text-center info' },
  FI = hn({
    __name: 'Devices',
    setup(e) {
      const n = te([]),
        a = te([]),
        s = te(!1),
        o = te(!0),
        r = te({}),
        l = te(1),
        c = te(0),
        u = te(0),
        d = te(!1),
        f = async (b = {}) => {
          s.value = !0
          const x = await ar(b)
          x.code === 401
            ? ((o.value = !1), (s.value = !1))
            : ((n.value = x.data),
              (s.value = !1),
              (c.value = Math.ceil(x.total / x.limit)),
              (u.value = x.total))
        },
        h = async () => {
          const b = await zd()
          a.value = b.data
        },
        v = (b) => {
          d.value = !0
          for (let w in b) b[w] || delete b[w]
          const x = { ...b }
          ;(r.value = x), f(x)
        }
      Ut(async () => {
        f(), h()
      })
      const g = () => {
          if (l.value >= 1) {
            const b = { ...r.value, $skip: l.value == 1 ? 0 : l.value * 15 - 15 }
            f(b)
          }
        },
        p = () => {
          if (l.value >= 1) {
            console.log(l.value)
            const b = { ...r.value, $skip: l.value == 1 ? 0 : l.value * 15 - 15 }
            f(b)
          }
        },
        y = async () => {
          const x = (await ar({ $limit: 1e3, ...r.value })).data.map((w, C) => ({
            No: C + 1,
            IMEI: w.imei,
            'S.N': w.serialNo,
            Make: w.make,
            Model: w.model,
            Status: w.locked == 1 ? 'LOCKED' : 'UNLOCKED',
            'Last Connected': Wt(w.lastConnectedAt),
            Client: w.client.fullName,
            'Loan ID': w.loan.accountId
          }))
          nu(x, 'devices')
        }
      return (b, x) => {
        var T, B, O
        const w = Se('v-progress-linear'),
          C = Se('v-divider'),
          P = Se('v-btn'),
          k = Se('v-icon'),
          S = Se('v-table'),
          _ = Se('v-pagination')
        return (
          Re(),
          et(
            Oe,
            null,
            [
              s.value
                ? (Re(), Ct(w, { key: 0, class: 'loader', indeterminate: '', color: 'cyan' }))
                : ct('', !0),
              wI,
              m(C, { color: 'success' }),
              z('div', SI, [
                z('div', kI, [
                  m(
                    P,
                    { color: 'grey', onClick: y, 'prepend-icon': 'mdi-cloud' },
                    { default: we(() => [nt('Dowload')]), _: 1 }
                  )
                ]),
                z('div', CI, [z('div', MI, [z('p', null, [nt('TOTAL: '), z('b', null, ze(u.value), 1)])])]),
                z('div', AI, [
                  d.value ? (Re(), et('small', PI, VI)) : ct('', !0),
                  z('div', EI, [m(xI, { onClicked: v, options: a.value }, null, 8, ['options'])]),
                  m(
                    P,
                    { color: 'green', onClick: x[0] || (x[0] = (N) => f()), 'prepend-icon': 'bin' },
                    { default: we(() => [nt('Refresh')]), _: 1 }
                  )
                ])
              ]),
              (T = n.value) != null && T.length
                ? (Re(),
                  Ct(
                    S,
                    { key: 1, theme: 'light', height: 700 },
                    {
                      default: we(() => [
                        LI,
                        z('tbody', null, [
                          (Re(!0),
                          et(
                            Oe,
                            null,
                            Xi(
                              n.value,
                              (N) => (
                                Re(),
                                et('tr', { key: N.id }, [
                                  z('td', null, ze(N.imei), 1),
                                  z('td', null, ze(N.serialNo || '--'), 1),
                                  z('td', null, ze(N.make || 'Not recorded'), 1),
                                  z('td', null, ze(N.model || 'Not recorded'), 1),
                                  z('td', null, ze(N.status), 1),
                                  z('td', null, ze(N.mambuSynced == 1 ? 'Yes' : 'No'), 1),
                                  z('td', null, ze(N.nuovoSynced == 1 ? 'Yes' : 'No'), 1),
                                  z('td', null, [
                                    m(
                                      k,
                                      { color: N.locked == 1 ? 'red' : 'green', icon: 'mdi-cellphone-lock' },
                                      null,
                                      8,
                                      ['color']
                                    )
                                  ]),
                                  z('td', null, ze(Xe(Wt)(N.nextLockDate)), 1),
                                  z('td', null, ze(Xe(Wt)(N.lastConnectedAt)), 1),
                                  z('td', null, [
                                    m(Er, { data: [N.client], type: 'client' }, null, 8, ['data'])
                                  ]),
                                  z('td', null, [m(Er, { data: [N.loan], type: 'loan' }, null, 8, ['data'])]),
                                  z('td', null, ze(Xe(Wt)(N.createdAt)), 1),
                                  z('td', null, ze(Xe(Wt)(N.updatedAt)), 1)
                                ])
                              )
                            ),
                            128
                          ))
                        ])
                      ]),
                      _: 1
                    }
                  ))
                : ct('', !0),
              (B = n.value) != null && B.length
                ? (Re(),
                  et('div', OI, [
                    m(
                      _,
                      {
                        onPrev: g,
                        onNext: p,
                        modelValue: l.value,
                        'onUpdate:modelValue': x[1] || (x[1] = (N) => (l.value = N)),
                        'total-visible': 1,
                        length: c.value,
                        rounded: 'circle'
                      },
                      null,
                      8,
                      ['modelValue', 'length']
                    )
                  ]))
                : ct('', !0),
              !o.value && (O = n.value) != null && O.length
                ? (Re(), et('div', II, [m(wo, { message: 'Device' })]))
                : ct('', !0),
              o.value ? ct('', !0) : (Re(), et('div', DI, [m(eu, { message: 'viewDevices' })]))
            ],
            64
          )
        )
      }
    }
  })
const RI = Oi(FI, [['__scopeId', 'data-v-9335a25e']]),
  Ch = (e) => (Ea('data-v-47423775'), (e = e()), La(), e),
  BI = Ch(() => z('div', { class: 'title' }, [z('h3', null, 'LOCK HISTORY')], -1)),
  NI = { class: 'actions' },
  $I = { class: 'btn' },
  zI = { key: 0, class: 'filter' },
  HI = Ch(() => z('b', null, 'Click refresh to clear filters', -1)),
  WI = [HI],
  jI = Ch(() =>
    z(
      'thead',
      null,
      [
        z('tr', null, [
          z('th', { class: 'text-left' }, 'Type'),
          z('th', { class: 'text-left' }, 'Reason'),
          z('th', { class: 'text-left' }, 'Date Locked'),
          z('th', { class: 'text-left' }, 'Date Unlocked'),
          z('th', { class: 'text-left' }, 'Loan'),
          z('th', { class: 'text-left' }, 'Device'),
          z('th', { class: 'text-left' }, 'Created At'),
          z('th', { class: 'text-left' }, 'Updated At')
        ])
      ],
      -1
    )
  ),
  UI = { key: 2, class: 'text-center info' },
  YI = { key: 3, class: 'text-center info' },
  GI = hn({
    __name: 'LockHistory',
    setup(e) {
      const n = te([]),
        i = te(!0),
        a = te(!1),
        s = te(!1),
        o = async (r = {}) => {
          a.value = !0
          const l = await dE()
          l.code === 401 ? ((i.value = !1), (a.value = !1)) : ((n.value = l.data), (a.value = !1))
        }
      return (
        Ut(async () => {
          o()
        }),
        (r, l) => {
          var h, v
          const c = Se('v-progress-linear'),
            u = Se('v-divider'),
            d = Se('v-btn'),
            f = Se('v-table')
          return (
            Re(),
            et(
              Oe,
              null,
              [
                a.value
                  ? (Re(), Ct(c, { key: 0, class: 'loader', indeterminate: '', color: 'cyan' }))
                  : ct('', !0),
                BI,
                m(u, { color: 'success' }),
                z('div', NI, [
                  z('div', $I, [
                    s.value ? (Re(), et('small', zI, WI)) : ct('', !0),
                    m(
                      d,
                      { color: 'green', onClick: l[0] || (l[0] = (g) => o()), 'prepend-icon': 'bin' },
                      { default: we(() => [nt('Refresh')]), _: 1 }
                    )
                  ])
                ]),
                (h = n.value) != null && h.length
                  ? (Re(),
                    Ct(
                      f,
                      { key: 1, theme: 'light', height: 700 },
                      {
                        default: we(() => [
                          jI,
                          z('tbody', null, [
                            (Re(!0),
                            et(
                              Oe,
                              null,
                              Xi(
                                n.value,
                                (g) => (
                                  Re(),
                                  et('tr', { key: g.id }, [
                                    z('td', null, ze(g.type == 1 ? 'Lock' : 'Unlock'), 1),
                                    z('td', null, ze(g.reason), 1),
                                    z('td', null, ze(Xe(Wt)(g.lockedAt)), 1),
                                    z('td', null, ze(Xe(Wt)(g.unlockedAt)), 1),
                                    z('td', null, [
                                      m(Er, { data: [g.loan], type: 'loan' }, null, 8, ['data'])
                                    ]),
                                    z('td', null, [
                                      m(Er, { data: [g.device], type: 'device' }, null, 8, ['data'])
                                    ]),
                                    z('td', null, ze(Xe(Wt)(g.createdAt)), 1),
                                    z('td', null, ze(Xe(Wt)(g.updatedAt)), 1)
                                  ])
                                )
                              ),
                              128
                            ))
                          ])
                        ]),
                        _: 1
                      }
                    ))
                  : ct('', !0),
                i.value && !((v = n.value) != null && v.length)
                  ? (Re(), et('div', UI, [m(wo, { message: 'Lock History' })]))
                  : ct('', !0),
                i.value ? ct('', !0) : (Re(), et('div', YI, [m(eu, { message: 'viewLockHistory' })]))
              ],
              64
            )
          )
        }
      )
    }
  })
const XI = Oi(GI, [['__scopeId', 'data-v-47423775']]),
  i_ = (e) => (Ea('data-v-21dbf3d7'), (e = e()), La(), e),
  KI = i_(() => z('div', { class: 'title' }, [z('h3', null, 'Queued SMS')], -1)),
  qI = { class: 'actions' },
  ZI = { class: 'btn' },
  JI = i_(() =>
    z(
      'thead',
      null,
      [
        z('tr', null, [
          z('th', { class: 'text-left' }, 'Phone Number'),
          z('th', { class: 'text-left' }, 'Message'),
          z('th', { class: 'text-left' }, 'Sent'),
          z('th', { class: 'text-left' }, 'Date Created'),
          z('th', { class: 'text-left' }, 'Date Updated')
        ])
      ],
      -1
    )
  ),
  QI = { key: 2, class: 'text-center info' },
  eD = hn({
    __name: 'Queued',
    setup(e) {
      const n = te([]),
        i = te(!1),
        a = async () => {
          i.value = !0
          const s = await fE()
          ;(n.value = s.data), (i.value = !1)
        }
      return (
        Ut(async () => {
          a()
        }),
        (s, o) => {
          const r = Se('v-progress-linear'),
            l = Se('v-divider'),
            c = Se('v-btn'),
            u = Se('v-table')
          return (
            Re(),
            et(
              Oe,
              null,
              [
                i.value
                  ? (Re(), Ct(r, { key: 0, class: 'loader', indeterminate: '', color: 'cyan' }))
                  : ct('', !0),
                KI,
                m(l, { color: 'success' }),
                z('div', qI, [
                  z('div', ZI, [
                    m(
                      c,
                      { color: 'blue', class: 'filter', 'prepend-icon': 'filter' },
                      { default: we(() => [nt('Filter')]), _: 1 }
                    ),
                    m(
                      c,
                      { color: 'green', onClick: o[0] || (o[0] = (d) => a()), 'prepend-icon': 'bin' },
                      { default: we(() => [nt('Refresh')]), _: 1 }
                    )
                  ])
                ]),
                n.value.length
                  ? (Re(),
                    Ct(
                      u,
                      { key: 1, theme: 'light' },
                      {
                        default: we(() => [
                          JI,
                          z('tbody', null, [
                            (Re(!0),
                            et(
                              Oe,
                              null,
                              Xi(
                                n.value,
                                (d) => (
                                  Re(),
                                  et('tr', { key: d.id }, [
                                    z('td', null, ze(d.destination), 1),
                                    z('td', null, ze(d.message || '--'), 1),
                                    z('td', null, [
                                      z(
                                        'span',
                                        { class: ki(d.sent == 1 ? 'active status' : 'inactive status') },
                                        ze(d.sent == 1 ? 'Yes' : 'No'),
                                        3
                                      )
                                    ]),
                                    z('td', null, ze(Xe(Wt)(d.createdAt)), 1),
                                    z('td', null, ze(Xe(Wt)(d.updatedAt)), 1)
                                  ])
                                )
                              ),
                              128
                            ))
                          ])
                        ]),
                        _: 1
                      }
                    ))
                  : ct('', !0),
                n.value.length ? ct('', !0) : (Re(), et('div', QI, [m(wo, { message: 'Sent SMS' })]))
              ],
              64
            )
          )
        }
      )
    }
  })
const tD = Oi(eD, [['__scopeId', 'data-v-21dbf3d7']]),
  a_ = (e) => (Ea('data-v-9bb06463'), (e = e()), La(), e),
  nD = a_(() => z('div', { class: 'title' }, [z('h3', null, 'Sent SMS')], -1)),
  iD = { class: 'actions' },
  aD = { class: 'download' },
  sD = { class: 'stats' },
  oD = { class: 'numbers' },
  rD = { class: 'btn' },
  lD = a_(() =>
    z(
      'thead',
      null,
      [
        z('tr', null, [
          z('th', { class: 'text-left' }, 'Phone Number'),
          z('th', { class: 'text-left' }, 'Message'),
          z('th', { class: 'text-left' }, 'Sent'),
          z('th', { class: 'text-left' }, 'Date Created'),
          z('th', { class: 'text-left' }, 'Date Updated')
        ])
      ],
      -1
    )
  ),
  cD = { key: 2, class: 'text-center pagination' },
  uD = { key: 3, class: 'text-center info' },
  dD = hn({
    __name: 'SentSMS',
    setup(e) {
      const n = te([]),
        i = te(!1),
        a = te({}),
        s = te(1),
        o = te(0),
        r = te(0)
      te(!1)
      const l = async (f = {}) => {
        i.value = !0
        const h = await hE(f)
        h.code === 401
          ? (i.value = !1)
          : ((n.value = h.data),
            (i.value = !1),
            (o.value = Math.ceil(h.total / h.limit)),
            (r.value = h.total))
      }
      Ut(async () => {
        l()
      })
      const c = () => {
          if (s.value >= 1) {
            const f = { ...a.value, $skip: s.value == 1 ? 0 : s.value * 20 - 20 }
            l(f)
          }
        },
        u = () => {
          if (s.value >= 1) {
            console.log(s.value)
            const f = { ...a.value, $skip: s.value == 1 ? 0 : s.value * 20 - 20 }
            l(f)
          }
        },
        d = () => {
          const f = n.value.map((h, v) => ({
            No: v + 1,
            Destination: h.destination,
            Message: h.message,
            'Date Sent': Wt(h.createdAt)
          }))
          nu(f, 'sentsms')
        }
      return (f, h) => {
        var x, w
        const v = Se('v-progress-linear'),
          g = Se('v-divider'),
          p = Se('v-btn'),
          y = Se('v-table'),
          b = Se('v-pagination')
        return (
          Re(),
          et(
            Oe,
            null,
            [
              i.value
                ? (Re(), Ct(v, { key: 0, class: 'loader', indeterminate: '', color: 'cyan' }))
                : ct('', !0),
              nD,
              m(g, { color: 'success' }),
              z('div', iD, [
                z('div', aD, [
                  m(
                    p,
                    { color: 'grey', onClick: d, 'prepend-icon': 'mdi-cloud' },
                    { default: we(() => [nt('Dowload')]), _: 1 }
                  )
                ]),
                z('div', sD, [z('div', oD, [z('p', null, [nt('TOTAL: '), z('b', null, ze(r.value), 1)])])]),
                z('div', rD, [
                  m(
                    p,
                    { color: 'blue', class: 'filter', 'prepend-icon': 'filter' },
                    { default: we(() => [nt('Filter')]), _: 1 }
                  ),
                  m(
                    p,
                    { color: 'green', onClick: h[0] || (h[0] = (C) => l()), 'prepend-icon': 'bin' },
                    { default: we(() => [nt('Refresh')]), _: 1 }
                  )
                ])
              ]),
              (x = n.value) != null && x.length
                ? (Re(),
                  Ct(
                    y,
                    { key: 1, theme: 'light', height: 700 },
                    {
                      default: we(() => [
                        lD,
                        z('tbody', null, [
                          (Re(!0),
                          et(
                            Oe,
                            null,
                            Xi(
                              n.value,
                              (C) => (
                                Re(),
                                et('tr', { key: C.id }, [
                                  z('td', null, ze(C.destination), 1),
                                  z('td', null, ze(C.message || '--'), 1),
                                  z('td', null, [
                                    z(
                                      'span',
                                      { class: ki(C.sent == 1 ? 'active status' : 'inactive status') },
                                      ze(C.sent == 1 ? 'Yes' : 'No'),
                                      3
                                    )
                                  ]),
                                  z('td', null, ze(Xe(Wt)(C.createdAt)), 1),
                                  z('td', null, ze(Xe(Wt)(C.updatedAt)), 1)
                                ])
                              )
                            ),
                            128
                          ))
                        ])
                      ]),
                      _: 1
                    }
                  ))
                : ct('', !0),
              (w = n.value) != null && w.length
                ? (Re(),
                  et('div', cD, [
                    m(
                      b,
                      {
                        onPrev: c,
                        onNext: u,
                        modelValue: s.value,
                        'onUpdate:modelValue': h[1] || (h[1] = (C) => (s.value = C)),
                        'total-visible': 1,
                        length: o.value,
                        rounded: 'circle'
                      },
                      null,
                      8,
                      ['modelValue', 'length']
                    )
                  ]))
                : ct('', !0),
              n.value.length ? ct('', !0) : (Re(), et('div', uD, [m(wo, { message: 'Sent SMS' })]))
            ],
            64
          )
        )
      }
    }
  })
const fD = Oi(dD, [['__scopeId', 'data-v-9bb06463']]),
  s_ = (e) => (Ea('data-v-2b81bbe8'), (e = e()), La(), e),
  hD = s_(() => z('div', { class: 'title' }, [z('h3', null, 'Reminders')], -1)),
  vD = { class: 'actions' },
  gD = { class: 'btn' },
  mD = s_(() =>
    z(
      'thead',
      null,
      [
        z('tr', null, [
          z('th', { class: 'text-left' }, 'Type'),
          z('th', { class: 'text-left' }, 'Device'),
          z('th', { class: 'text-left' }, 'Message'),
          z('th', { class: 'text-left' }, 'Date Created'),
          z('th', { class: 'text-left' }, 'Date Updated')
        ])
      ],
      -1
    )
  ),
  pD = { key: 2, class: 'text-center info' },
  yD = { key: 3, class: 'text-center info' },
  bD = hn({
    __name: 'Reminder',
    setup(e) {
      const n = te([]),
        i = te(!1),
        a = te(!0),
        s = async () => {
          i.value = !0
          const o = await vE()
          o.code === 401 ? ((a.value = !1), (i.value = !1)) : ((n.value = o.data), (i.value = !1))
        }
      return (
        Ut(async () => {
          s()
        }),
        (o, r) => {
          var f, h
          const l = Se('v-progress-linear'),
            c = Se('v-divider'),
            u = Se('v-btn'),
            d = Se('v-table')
          return (
            Re(),
            et(
              Oe,
              null,
              [
                i.value
                  ? (Re(), Ct(l, { key: 0, class: 'loader', indeterminate: '', color: 'cyan' }))
                  : ct('', !0),
                hD,
                m(c, { color: 'success' }),
                z('div', vD, [
                  z('div', gD, [
                    m(
                      u,
                      { color: 'blue', class: 'filter', 'prepend-icon': 'filter' },
                      { default: we(() => [nt('Filter')]), _: 1 }
                    ),
                    m(
                      u,
                      { color: 'green', onClick: r[0] || (r[0] = (v) => s()), 'prepend-icon': 'bin' },
                      { default: we(() => [nt('Refresh')]), _: 1 }
                    )
                  ])
                ]),
                (f = n.value) != null && f.length
                  ? (Re(),
                    Ct(
                      d,
                      { key: 1, height: 700, theme: 'light' },
                      {
                        default: we(() => [
                          mD,
                          z('tbody', null, [
                            (Re(!0),
                            et(
                              Oe,
                              null,
                              Xi(
                                n.value,
                                (v) => (
                                  Re(),
                                  et('tr', { key: v.id }, [
                                    z('td', null, ze(v.type == 1 ? 'Final Reminder' : 'Due reminder'), 1),
                                    z('td', null, [
                                      m(Er, { data: [v.device], type: 'device' }, null, 8, ['data'])
                                    ]),
                                    z('td', null, ze(v.message), 1),
                                    z('td', null, ze(Xe(Wt)(v.createdAt)), 1),
                                    z('td', null, ze(Xe(Wt)(v.updatedAt)), 1)
                                  ])
                                )
                              ),
                              128
                            ))
                          ])
                        ]),
                        _: 1
                      }
                    ))
                  : ct('', !0),
                a.value && !((h = n.value) != null && h.length)
                  ? (Re(), et('div', pD, [m(wo, { message: 'Reminders' })]))
                  : ct('', !0),
                a.value ? ct('', !0) : (Re(), et('div', yD, [m(eu, { message: 'viewReminders' })]))
              ],
              64
            )
          )
        }
      )
    }
  })
const _D = Oi(bD, [['__scopeId', 'data-v-2b81bbe8']])
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */ function Zr(e) {
  return (e + 0.5) | 0
}
const ba = (e, t, n) => Math.max(Math.min(e, n), t)
function Uo(e) {
  return ba(Zr(e * 2.55), 0, 255)
}
function Ca(e) {
  return ba(Zr(e * 255), 0, 255)
}
function Wi(e) {
  return ba(Zr(e / 2.55) / 100, 0, 1)
}
function vm(e) {
  return ba(Zr(e * 100), 0, 100)
}
const zn = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
  },
  Yd = [...'0123456789ABCDEF'],
  xD = (e) => Yd[e & 15],
  wD = (e) => Yd[(e & 240) >> 4] + Yd[e & 15],
  bl = (e) => (e & 240) >> 4 === (e & 15),
  SD = (e) => bl(e.r) && bl(e.g) && bl(e.b) && bl(e.a)
function kD(e) {
  var t = e.length,
    n
  return (
    e[0] === '#' &&
      (t === 4 || t === 5
        ? (n = {
            r: 255 & (zn[e[1]] * 17),
            g: 255 & (zn[e[2]] * 17),
            b: 255 & (zn[e[3]] * 17),
            a: t === 5 ? zn[e[4]] * 17 : 255
          })
        : (t === 7 || t === 9) &&
          (n = {
            r: (zn[e[1]] << 4) | zn[e[2]],
            g: (zn[e[3]] << 4) | zn[e[4]],
            b: (zn[e[5]] << 4) | zn[e[6]],
            a: t === 9 ? (zn[e[7]] << 4) | zn[e[8]] : 255
          })),
    n
  )
}
const CD = (e, t) => (e < 255 ? t(e) : '')
function MD(e) {
  var t = SD(e) ? xD : wD
  return e ? '#' + t(e.r) + t(e.g) + t(e.b) + CD(e.a, t) : void 0
}
const AD =
  /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/
function o_(e, t, n) {
  const i = t * Math.min(n, 1 - n),
    a = (s, o = (s + e / 30) % 12) => n - i * Math.max(Math.min(o - 3, 9 - o, 1), -1)
  return [a(0), a(8), a(4)]
}
function PD(e, t, n) {
  const i = (a, s = (a + e / 60) % 6) => n - n * t * Math.max(Math.min(s, 4 - s, 1), 0)
  return [i(5), i(3), i(1)]
}
function TD(e, t, n) {
  const i = o_(e, 1, 0.5)
  let a
  for (t + n > 1 && ((a = 1 / (t + n)), (t *= a), (n *= a)), a = 0; a < 3; a++)
    (i[a] *= 1 - t - n), (i[a] += t)
  return i
}
function VD(e, t, n, i, a) {
  return e === a ? (t - n) / i + (t < n ? 6 : 0) : t === a ? (n - e) / i + 2 : (e - t) / i + 4
}
function Mh(e) {
  const n = e.r / 255,
    i = e.g / 255,
    a = e.b / 255,
    s = Math.max(n, i, a),
    o = Math.min(n, i, a),
    r = (s + o) / 2
  let l, c, u
  return (
    s !== o &&
      ((u = s - o),
      (c = r > 0.5 ? u / (2 - s - o) : u / (s + o)),
      (l = VD(n, i, a, u, s)),
      (l = l * 60 + 0.5)),
    [l | 0, c || 0, r]
  )
}
function Ah(e, t, n, i) {
  return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, n, i)).map(Ca)
}
function Ph(e, t, n) {
  return Ah(o_, e, t, n)
}
function ED(e, t, n) {
  return Ah(TD, e, t, n)
}
function LD(e, t, n) {
  return Ah(PD, e, t, n)
}
function r_(e) {
  return ((e % 360) + 360) % 360
}
function OD(e) {
  const t = AD.exec(e)
  let n = 255,
    i
  if (!t) return
  t[5] !== i && (n = t[6] ? Uo(+t[5]) : Ca(+t[5]))
  const a = r_(+t[2]),
    s = +t[3] / 100,
    o = +t[4] / 100
  return (
    t[1] === 'hwb' ? (i = ED(a, s, o)) : t[1] === 'hsv' ? (i = LD(a, s, o)) : (i = Ph(a, s, o)),
    { r: i[0], g: i[1], b: i[2], a: n }
  )
}
function ID(e, t) {
  var n = Mh(e)
  ;(n[0] = r_(n[0] + t)), (n = Ph(n)), (e.r = n[0]), (e.g = n[1]), (e.b = n[2])
}
function DD(e) {
  if (!e) return
  const t = Mh(e),
    n = t[0],
    i = vm(t[1]),
    a = vm(t[2])
  return e.a < 255 ? `hsla(${n}, ${i}%, ${a}%, ${Wi(e.a)})` : `hsl(${n}, ${i}%, ${a}%)`
}
const gm = {
    x: 'dark',
    Z: 'light',
    Y: 're',
    X: 'blu',
    W: 'gr',
    V: 'medium',
    U: 'slate',
    A: 'ee',
    T: 'ol',
    S: 'or',
    B: 'ra',
    C: 'lateg',
    D: 'ights',
    R: 'in',
    Q: 'turquois',
    E: 'hi',
    P: 'ro',
    O: 'al',
    N: 'le',
    M: 'de',
    L: 'yello',
    F: 'en',
    K: 'ch',
    G: 'arks',
    H: 'ea',
    I: 'ightg',
    J: 'wh'
  },
  mm = {
    OiceXe: 'f0f8ff',
    antiquewEte: 'faebd7',
    aqua: 'ffff',
    aquamarRe: '7fffd4',
    azuY: 'f0ffff',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    black: '0',
    blanKedOmond: 'ffebcd',
    Xe: 'ff',
    XeviTet: '8a2be2',
    bPwn: 'a52a2a',
    burlywood: 'deb887',
    caMtXe: '5f9ea0',
    KartYuse: '7fff00',
    KocTate: 'd2691e',
    cSO: 'ff7f50',
    cSnflowerXe: '6495ed',
    cSnsilk: 'fff8dc',
    crimson: 'dc143c',
    cyan: 'ffff',
    xXe: '8b',
    xcyan: '8b8b',
    xgTMnPd: 'b8860b',
    xWay: 'a9a9a9',
    xgYF: '6400',
    xgYy: 'a9a9a9',
    xkhaki: 'bdb76b',
    xmagFta: '8b008b',
    xTivegYF: '556b2f',
    xSange: 'ff8c00',
    xScEd: '9932cc',
    xYd: '8b0000',
    xsOmon: 'e9967a',
    xsHgYF: '8fbc8f',
    xUXe: '483d8b',
    xUWay: '2f4f4f',
    xUgYy: '2f4f4f',
    xQe: 'ced1',
    xviTet: '9400d3',
    dAppRk: 'ff1493',
    dApskyXe: 'bfff',
    dimWay: '696969',
    dimgYy: '696969',
    dodgerXe: '1e90ff',
    fiYbrick: 'b22222',
    flSOwEte: 'fffaf0',
    foYstWAn: '228b22',
    fuKsia: 'ff00ff',
    gaRsbSo: 'dcdcdc',
    ghostwEte: 'f8f8ff',
    gTd: 'ffd700',
    gTMnPd: 'daa520',
    Way: '808080',
    gYF: '8000',
    gYFLw: 'adff2f',
    gYy: '808080',
    honeyMw: 'f0fff0',
    hotpRk: 'ff69b4',
    RdianYd: 'cd5c5c',
    Rdigo: '4b0082',
    ivSy: 'fffff0',
    khaki: 'f0e68c',
    lavFMr: 'e6e6fa',
    lavFMrXsh: 'fff0f5',
    lawngYF: '7cfc00',
    NmoncEffon: 'fffacd',
    ZXe: 'add8e6',
    ZcSO: 'f08080',
    Zcyan: 'e0ffff',
    ZgTMnPdLw: 'fafad2',
    ZWay: 'd3d3d3',
    ZgYF: '90ee90',
    ZgYy: 'd3d3d3',
    ZpRk: 'ffb6c1',
    ZsOmon: 'ffa07a',
    ZsHgYF: '20b2aa',
    ZskyXe: '87cefa',
    ZUWay: '778899',
    ZUgYy: '778899',
    ZstAlXe: 'b0c4de',
    ZLw: 'ffffe0',
    lime: 'ff00',
    limegYF: '32cd32',
    lRF: 'faf0e6',
    magFta: 'ff00ff',
    maPon: '800000',
    VaquamarRe: '66cdaa',
    VXe: 'cd',
    VScEd: 'ba55d3',
    VpurpN: '9370db',
    VsHgYF: '3cb371',
    VUXe: '7b68ee',
    VsprRggYF: 'fa9a',
    VQe: '48d1cc',
    VviTetYd: 'c71585',
    midnightXe: '191970',
    mRtcYam: 'f5fffa',
    mistyPse: 'ffe4e1',
    moccasR: 'ffe4b5',
    navajowEte: 'ffdead',
    navy: '80',
    Tdlace: 'fdf5e6',
    Tive: '808000',
    TivedBb: '6b8e23',
    Sange: 'ffa500',
    SangeYd: 'ff4500',
    ScEd: 'da70d6',
    pOegTMnPd: 'eee8aa',
    pOegYF: '98fb98',
    pOeQe: 'afeeee',
    pOeviTetYd: 'db7093',
    papayawEp: 'ffefd5',
    pHKpuff: 'ffdab9',
    peru: 'cd853f',
    pRk: 'ffc0cb',
    plum: 'dda0dd',
    powMrXe: 'b0e0e6',
    purpN: '800080',
    YbeccapurpN: '663399',
    Yd: 'ff0000',
    Psybrown: 'bc8f8f',
    PyOXe: '4169e1',
    saddNbPwn: '8b4513',
    sOmon: 'fa8072',
    sandybPwn: 'f4a460',
    sHgYF: '2e8b57',
    sHshell: 'fff5ee',
    siFna: 'a0522d',
    silver: 'c0c0c0',
    skyXe: '87ceeb',
    UXe: '6a5acd',
    UWay: '708090',
    UgYy: '708090',
    snow: 'fffafa',
    sprRggYF: 'ff7f',
    stAlXe: '4682b4',
    tan: 'd2b48c',
    teO: '8080',
    tEstN: 'd8bfd8',
    tomato: 'ff6347',
    Qe: '40e0d0',
    viTet: 'ee82ee',
    JHt: 'f5deb3',
    wEte: 'ffffff',
    wEtesmoke: 'f5f5f5',
    Lw: 'ffff00',
    LwgYF: '9acd32'
  }
function FD() {
  const e = {},
    t = Object.keys(mm),
    n = Object.keys(gm)
  let i, a, s, o, r
  for (i = 0; i < t.length; i++) {
    for (o = r = t[i], a = 0; a < n.length; a++) (s = n[a]), (r = r.replace(s, gm[s]))
    ;(s = parseInt(mm[o], 16)), (e[r] = [(s >> 16) & 255, (s >> 8) & 255, s & 255])
  }
  return e
}
let _l
function RD(e) {
  _l || ((_l = FD()), (_l.transparent = [0, 0, 0, 0]))
  const t = _l[e.toLowerCase()]
  return t && { r: t[0], g: t[1], b: t[2], a: t.length === 4 ? t[3] : 255 }
}
const BD =
  /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/
function ND(e) {
  const t = BD.exec(e)
  let n = 255,
    i,
    a,
    s
  if (t) {
    if (t[7] !== i) {
      const o = +t[7]
      n = t[8] ? Uo(o) : ba(o * 255, 0, 255)
    }
    return (
      (i = +t[1]),
      (a = +t[3]),
      (s = +t[5]),
      (i = 255 & (t[2] ? Uo(i) : ba(i, 0, 255))),
      (a = 255 & (t[4] ? Uo(a) : ba(a, 0, 255))),
      (s = 255 & (t[6] ? Uo(s) : ba(s, 0, 255))),
      { r: i, g: a, b: s, a: n }
    )
  }
}
function $D(e) {
  return e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${Wi(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`)
}
const Du = (e) => (e <= 0.0031308 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - 0.055),
  Os = (e) => (e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4))
function zD(e, t, n) {
  const i = Os(Wi(e.r)),
    a = Os(Wi(e.g)),
    s = Os(Wi(e.b))
  return {
    r: Ca(Du(i + n * (Os(Wi(t.r)) - i))),
    g: Ca(Du(a + n * (Os(Wi(t.g)) - a))),
    b: Ca(Du(s + n * (Os(Wi(t.b)) - s))),
    a: e.a + n * (t.a - e.a)
  }
}
function xl(e, t, n) {
  if (e) {
    let i = Mh(e)
    ;(i[t] = Math.max(0, Math.min(i[t] + i[t] * n, t === 0 ? 360 : 1))),
      (i = Ph(i)),
      (e.r = i[0]),
      (e.g = i[1]),
      (e.b = i[2])
  }
}
function l_(e, t) {
  return e && Object.assign(t || {}, e)
}
function pm(e) {
  var t = { r: 0, g: 0, b: 0, a: 255 }
  return (
    Array.isArray(e)
      ? e.length >= 3 && ((t = { r: e[0], g: e[1], b: e[2], a: 255 }), e.length > 3 && (t.a = Ca(e[3])))
      : ((t = l_(e, { r: 0, g: 0, b: 0, a: 1 })), (t.a = Ca(t.a))),
    t
  )
}
function HD(e) {
  return e.charAt(0) === 'r' ? ND(e) : OD(e)
}
class Lr {
  constructor(t) {
    if (t instanceof Lr) return t
    const n = typeof t
    let i
    n === 'object' ? (i = pm(t)) : n === 'string' && (i = kD(t) || RD(t) || HD(t)),
      (this._rgb = i),
      (this._valid = !!i)
  }
  get valid() {
    return this._valid
  }
  get rgb() {
    var t = l_(this._rgb)
    return t && (t.a = Wi(t.a)), t
  }
  set rgb(t) {
    this._rgb = pm(t)
  }
  rgbString() {
    return this._valid ? $D(this._rgb) : void 0
  }
  hexString() {
    return this._valid ? MD(this._rgb) : void 0
  }
  hslString() {
    return this._valid ? DD(this._rgb) : void 0
  }
  mix(t, n) {
    if (t) {
      const i = this.rgb,
        a = t.rgb
      let s
      const o = n === s ? 0.5 : n,
        r = 2 * o - 1,
        l = i.a - a.a,
        c = ((r * l === -1 ? r : (r + l) / (1 + r * l)) + 1) / 2
      ;(s = 1 - c),
        (i.r = 255 & (c * i.r + s * a.r + 0.5)),
        (i.g = 255 & (c * i.g + s * a.g + 0.5)),
        (i.b = 255 & (c * i.b + s * a.b + 0.5)),
        (i.a = o * i.a + (1 - o) * a.a),
        (this.rgb = i)
    }
    return this
  }
  interpolate(t, n) {
    return t && (this._rgb = zD(this._rgb, t._rgb, n)), this
  }
  clone() {
    return new Lr(this.rgb)
  }
  alpha(t) {
    return (this._rgb.a = Ca(t)), this
  }
  clearer(t) {
    const n = this._rgb
    return (n.a *= 1 - t), this
  }
  greyscale() {
    const t = this._rgb,
      n = Zr(t.r * 0.3 + t.g * 0.59 + t.b * 0.11)
    return (t.r = t.g = t.b = n), this
  }
  opaquer(t) {
    const n = this._rgb
    return (n.a *= 1 + t), this
  }
  negate() {
    const t = this._rgb
    return (t.r = 255 - t.r), (t.g = 255 - t.g), (t.b = 255 - t.b), this
  }
  lighten(t) {
    return xl(this._rgb, 2, t), this
  }
  darken(t) {
    return xl(this._rgb, 2, -t), this
  }
  saturate(t) {
    return xl(this._rgb, 1, t), this
  }
  desaturate(t) {
    return xl(this._rgb, 1, -t), this
  }
  rotate(t) {
    return ID(this._rgb, t), this
  }
}
/*!
 * Chart.js v4.4.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */ function Bi() {}
const WD = (() => {
  let e = 0
  return () => e++
})()
function lt(e) {
  return e === null || typeof e > 'u'
}
function xt(e) {
  if (Array.isArray && Array.isArray(e)) return !0
  const t = Object.prototype.toString.call(e)
  return t.slice(0, 7) === '[object' && t.slice(-6) === 'Array]'
}
function at(e) {
  return e !== null && Object.prototype.toString.call(e) === '[object Object]'
}
function It(e) {
  return (typeof e == 'number' || e instanceof Number) && isFinite(+e)
}
function Tn(e, t) {
  return It(e) ? e : t
}
function Ze(e, t) {
  return typeof e > 'u' ? t : e
}
const jD = (e, t) => (typeof e == 'string' && e.endsWith('%') ? parseFloat(e) / 100 : +e / t),
  c_ = (e, t) => (typeof e == 'string' && e.endsWith('%') ? (parseFloat(e) / 100) * t : +e)
function pt(e, t, n) {
  if (e && typeof e.call == 'function') return e.apply(n, t)
}
function ht(e, t, n, i) {
  let a, s, o
  if (xt(e))
    if (((s = e.length), i)) for (a = s - 1; a >= 0; a--) t.call(n, e[a], a)
    else for (a = 0; a < s; a++) t.call(n, e[a], a)
  else if (at(e)) for (o = Object.keys(e), s = o.length, a = 0; a < s; a++) t.call(n, e[o[a]], o[a])
}
function mc(e, t) {
  let n, i, a, s
  if (!e || !t || e.length !== t.length) return !1
  for (n = 0, i = e.length; n < i; ++n)
    if (((a = e[n]), (s = t[n]), a.datasetIndex !== s.datasetIndex || a.index !== s.index)) return !1
  return !0
}
function pc(e) {
  if (xt(e)) return e.map(pc)
  if (at(e)) {
    const t = Object.create(null),
      n = Object.keys(e),
      i = n.length
    let a = 0
    for (; a < i; ++a) t[n[a]] = pc(e[n[a]])
    return t
  }
  return e
}
function u_(e) {
  return ['__proto__', 'prototype', 'constructor'].indexOf(e) === -1
}
function UD(e, t, n, i) {
  if (!u_(e)) return
  const a = t[e],
    s = n[e]
  at(a) && at(s) ? Or(a, s, i) : (t[e] = pc(s))
}
function Or(e, t, n) {
  const i = xt(t) ? t : [t],
    a = i.length
  if (!at(e)) return e
  n = n || {}
  const s = n.merger || UD
  let o
  for (let r = 0; r < a; ++r) {
    if (((o = i[r]), !at(o))) continue
    const l = Object.keys(o)
    for (let c = 0, u = l.length; c < u; ++c) s(l[c], e, o, n)
  }
  return e
}
function rr(e, t) {
  return Or(e, t, { merger: YD })
}
function YD(e, t, n) {
  if (!u_(e)) return
  const i = t[e],
    a = n[e]
  at(i) && at(a) ? rr(i, a) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = pc(a))
}
const ym = { '': (e) => e, x: (e) => e.x, y: (e) => e.y }
function GD(e) {
  const t = e.split('.'),
    n = []
  let i = ''
  for (const a of t) (i += a), i.endsWith('\\') ? (i = i.slice(0, -1) + '.') : (n.push(i), (i = ''))
  return n
}
function XD(e) {
  const t = GD(e)
  return (n) => {
    for (const i of t) {
      if (i === '') break
      n = n && n[i]
    }
    return n
  }
}
function Ta(e, t) {
  return (ym[t] || (ym[t] = XD(t)))(e)
}
function Th(e) {
  return e.charAt(0).toUpperCase() + e.slice(1)
}
const Ir = (e) => typeof e < 'u',
  Va = (e) => typeof e == 'function',
  bm = (e, t) => {
    if (e.size !== t.size) return !1
    for (const n of e) if (!t.has(n)) return !1
    return !0
  }
function KD(e) {
  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu'
}
const St = Math.PI,
  wt = 2 * St,
  qD = wt + St,
  yc = Number.POSITIVE_INFINITY,
  ZD = St / 180,
  Bt = St / 2,
  Ua = St / 4,
  _m = (St * 2) / 3,
  _a = Math.log10,
  Ai = Math.sign
function lr(e, t, n) {
  return Math.abs(e - t) < n
}
function xm(e) {
  const t = Math.round(e)
  e = lr(e, t, e / 1e3) ? t : e
  const n = Math.pow(10, Math.floor(_a(e))),
    i = e / n
  return (i <= 1 ? 1 : i <= 2 ? 2 : i <= 5 ? 5 : 10) * n
}
function JD(e) {
  const t = [],
    n = Math.sqrt(e)
  let i
  for (i = 1; i < n; i++) e % i === 0 && (t.push(i), t.push(e / i))
  return n === (n | 0) && t.push(n), t.sort((a, s) => a - s).pop(), t
}
function io(e) {
  return !isNaN(parseFloat(e)) && isFinite(e)
}
function QD(e, t) {
  const n = Math.round(e)
  return n - t <= e && n + t >= e
}
function d_(e, t, n) {
  let i, a, s
  for (i = 0, a = e.length; i < a; i++)
    (s = e[i][n]), isNaN(s) || ((t.min = Math.min(t.min, s)), (t.max = Math.max(t.max, s)))
}
function oi(e) {
  return e * (St / 180)
}
function Vh(e) {
  return e * (180 / St)
}
function wm(e) {
  if (!It(e)) return
  let t = 1,
    n = 0
  for (; Math.round(e * t) / t !== e; ) (t *= 10), n++
  return n
}
function f_(e, t) {
  const n = t.x - e.x,
    i = t.y - e.y,
    a = Math.sqrt(n * n + i * i)
  let s = Math.atan2(i, n)
  return s < -0.5 * St && (s += wt), { angle: s, distance: a }
}
function Gd(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
}
function eF(e, t) {
  return ((e - t + qD) % wt) - St
}
function En(e) {
  return ((e % wt) + wt) % wt
}
function Dr(e, t, n, i) {
  const a = En(e),
    s = En(t),
    o = En(n),
    r = En(s - a),
    l = En(o - a),
    c = En(a - s),
    u = En(a - o)
  return a === s || a === o || (i && s === o) || (r > l && c < u)
}
function Zt(e, t, n) {
  return Math.max(t, Math.min(n, e))
}
function tF(e) {
  return Zt(e, -32768, 32767)
}
function Ui(e, t, n, i = 1e-6) {
  return e >= Math.min(t, n) - i && e <= Math.max(t, n) + i
}
function Eh(e, t, n) {
  n = n || ((o) => e[o] < t)
  let i = e.length - 1,
    a = 0,
    s
  for (; i - a > 1; ) (s = (a + i) >> 1), n(s) ? (a = s) : (i = s)
  return { lo: a, hi: i }
}
const Yi = (e, t, n, i) =>
    Eh(
      e,
      n,
      i
        ? (a) => {
            const s = e[a][t]
            return s < n || (s === n && e[a + 1][t] === n)
          }
        : (a) => e[a][t] < n
    ),
  nF = (e, t, n) => Eh(e, n, (i) => e[i][t] >= n)
function iF(e, t, n) {
  let i = 0,
    a = e.length
  for (; i < a && e[i] < t; ) i++
  for (; a > i && e[a - 1] > n; ) a--
  return i > 0 || a < e.length ? e.slice(i, a) : e
}
const h_ = ['push', 'pop', 'shift', 'splice', 'unshift']
function aF(e, t) {
  if (e._chartjs) {
    e._chartjs.listeners.push(t)
    return
  }
  Object.defineProperty(e, '_chartjs', { configurable: !0, enumerable: !1, value: { listeners: [t] } }),
    h_.forEach((n) => {
      const i = '_onData' + Th(n),
        a = e[n]
      Object.defineProperty(e, n, {
        configurable: !0,
        enumerable: !1,
        value(...s) {
          const o = a.apply(this, s)
          return (
            e._chartjs.listeners.forEach((r) => {
              typeof r[i] == 'function' && r[i](...s)
            }),
            o
          )
        }
      })
    })
}
function Sm(e, t) {
  const n = e._chartjs
  if (!n) return
  const i = n.listeners,
    a = i.indexOf(t)
  a !== -1 && i.splice(a, 1),
    !(i.length > 0) &&
      (h_.forEach((s) => {
        delete e[s]
      }),
      delete e._chartjs)
}
function v_(e) {
  const t = new Set(e)
  return t.size === e.length ? e : Array.from(t)
}
const g_ = (function () {
  return typeof window > 'u'
    ? function (e) {
        return e()
      }
    : window.requestAnimationFrame
})()
function m_(e, t) {
  let n = [],
    i = !1
  return function (...a) {
    ;(n = a),
      i ||
        ((i = !0),
        g_.call(window, () => {
          ;(i = !1), e.apply(t, n)
        }))
  }
}
function sF(e, t) {
  let n
  return function (...i) {
    return t ? (clearTimeout(n), (n = setTimeout(e, t, i))) : e.apply(this, i), t
  }
}
const Lh = (e) => (e === 'start' ? 'left' : e === 'end' ? 'right' : 'center'),
  rn = (e, t, n) => (e === 'start' ? t : e === 'end' ? n : (t + n) / 2),
  oF = (e, t, n, i) => (e === (i ? 'left' : 'right') ? n : e === 'center' ? (t + n) / 2 : t)
function p_(e, t, n) {
  const i = t.length
  let a = 0,
    s = i
  if (e._sorted) {
    const { iScale: o, _parsed: r } = e,
      l = o.axis,
      { min: c, max: u, minDefined: d, maxDefined: f } = o.getUserBounds()
    d && (a = Zt(Math.min(Yi(r, l, c).lo, n ? i : Yi(t, l, o.getPixelForValue(c)).lo), 0, i - 1)),
      f
        ? (s =
            Zt(
              Math.max(Yi(r, o.axis, u, !0).hi + 1, n ? 0 : Yi(t, l, o.getPixelForValue(u), !0).hi + 1),
              a,
              i
            ) - a)
        : (s = i - a)
  }
  return { start: a, count: s }
}
function y_(e) {
  const { xScale: t, yScale: n, _scaleRanges: i } = e,
    a = { xmin: t.min, xmax: t.max, ymin: n.min, ymax: n.max }
  if (!i) return (e._scaleRanges = a), !0
  const s = i.xmin !== t.min || i.xmax !== t.max || i.ymin !== n.min || i.ymax !== n.max
  return Object.assign(i, a), s
}
const wl = (e) => e === 0 || e === 1,
  km = (e, t, n) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin(((e - t) * wt) / n)),
  Cm = (e, t, n) => Math.pow(2, -10 * e) * Math.sin(((e - t) * wt) / n) + 1,
  cr = {
    linear: (e) => e,
    easeInQuad: (e) => e * e,
    easeOutQuad: (e) => -e * (e - 2),
    easeInOutQuad: (e) => ((e /= 0.5) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1)),
    easeInCubic: (e) => e * e * e,
    easeOutCubic: (e) => (e -= 1) * e * e + 1,
    easeInOutCubic: (e) => ((e /= 0.5) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2)),
    easeInQuart: (e) => e * e * e * e,
    easeOutQuart: (e) => -((e -= 1) * e * e * e - 1),
    easeInOutQuart: (e) => ((e /= 0.5) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2)),
    easeInQuint: (e) => e * e * e * e * e,
    easeOutQuint: (e) => (e -= 1) * e * e * e * e + 1,
    easeInOutQuint: (e) => ((e /= 0.5) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2)),
    easeInSine: (e) => -Math.cos(e * Bt) + 1,
    easeOutSine: (e) => Math.sin(e * Bt),
    easeInOutSine: (e) => -0.5 * (Math.cos(St * e) - 1),
    easeInExpo: (e) => (e === 0 ? 0 : Math.pow(2, 10 * (e - 1))),
    easeOutExpo: (e) => (e === 1 ? 1 : -Math.pow(2, -10 * e) + 1),
    easeInOutExpo: (e) =>
      wl(e) ? e : e < 0.5 ? 0.5 * Math.pow(2, 10 * (e * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
    easeInCirc: (e) => (e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1)),
    easeOutCirc: (e) => Math.sqrt(1 - (e -= 1) * e),
    easeInOutCirc: (e) =>
      (e /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
    easeInElastic: (e) => (wl(e) ? e : km(e, 0.075, 0.3)),
    easeOutElastic: (e) => (wl(e) ? e : Cm(e, 0.075, 0.3)),
    easeInOutElastic(e) {
      return wl(e) ? e : e < 0.5 ? 0.5 * km(e * 2, 0.1125, 0.45) : 0.5 + 0.5 * Cm(e * 2 - 1, 0.1125, 0.45)
    },
    easeInBack(e) {
      return e * e * ((1.70158 + 1) * e - 1.70158)
    },
    easeOutBack(e) {
      return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1
    },
    easeInOutBack(e) {
      let t = 1.70158
      return (e /= 0.5) < 1
        ? 0.5 * (e * e * (((t *= 1.525) + 1) * e - t))
        : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2)
    },
    easeInBounce: (e) => 1 - cr.easeOutBounce(1 - e),
    easeOutBounce(e) {
      return e < 1 / 2.75
        ? 7.5625 * e * e
        : e < 2 / 2.75
        ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75
        : e < 2.5 / 2.75
        ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375
        : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375
    },
    easeInOutBounce: (e) => (e < 0.5 ? cr.easeInBounce(e * 2) * 0.5 : cr.easeOutBounce(e * 2 - 1) * 0.5 + 0.5)
  }
function Oh(e) {
  if (e && typeof e == 'object') {
    const t = e.toString()
    return t === '[object CanvasPattern]' || t === '[object CanvasGradient]'
  }
  return !1
}
function Mm(e) {
  return Oh(e) ? e : new Lr(e)
}
function Fu(e) {
  return Oh(e) ? e : new Lr(e).saturate(0.5).darken(0.1).hexString()
}
const rF = ['x', 'y', 'borderWidth', 'radius', 'tension'],
  lF = ['color', 'borderColor', 'backgroundColor']
function cF(e) {
  e.set('animation', {
    delay: void 0,
    duration: 1e3,
    easing: 'easeOutQuart',
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }),
    e.describe('animation', {
      _fallback: !1,
      _indexable: !1,
      _scriptable: (t) => t !== 'onProgress' && t !== 'onComplete' && t !== 'fn'
    }),
    e.set('animations', {
      colors: { type: 'color', properties: lF },
      numbers: { type: 'number', properties: rF }
    }),
    e.describe('animations', { _fallback: 'animation' }),
    e.set('transitions', {
      active: { animation: { duration: 400 } },
      resize: { animation: { duration: 0 } },
      show: { animations: { colors: { from: 'transparent' }, visible: { type: 'boolean', duration: 0 } } },
      hide: {
        animations: {
          colors: { to: 'transparent' },
          visible: { type: 'boolean', easing: 'linear', fn: (t) => t | 0 }
        }
      }
    })
}
function uF(e) {
  e.set('layout', { autoPadding: !0, padding: { top: 0, right: 0, bottom: 0, left: 0 } })
}
const Am = new Map()
function dF(e, t) {
  t = t || {}
  const n = e + JSON.stringify(t)
  let i = Am.get(n)
  return i || ((i = new Intl.NumberFormat(e, t)), Am.set(n, i)), i
}
function Jr(e, t, n) {
  return dF(t, n).format(e)
}
const b_ = {
  values(e) {
    return xt(e) ? e : '' + e
  },
  numeric(e, t, n) {
    if (e === 0) return '0'
    const i = this.chart.options.locale
    let a,
      s = e
    if (n.length > 1) {
      const c = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value))
      ;(c < 1e-4 || c > 1e15) && (a = 'scientific'), (s = fF(e, n))
    }
    const o = _a(Math.abs(s)),
      r = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0),
      l = { notation: a, minimumFractionDigits: r, maximumFractionDigits: r }
    return Object.assign(l, this.options.ticks.format), Jr(e, i, l)
  },
  logarithmic(e, t, n) {
    if (e === 0) return '0'
    const i = n[t].significand || e / Math.pow(10, Math.floor(_a(e)))
    return [1, 2, 3, 5, 10, 15].includes(i) || t > 0.8 * n.length ? b_.numeric.call(this, e, t, n) : ''
  }
}
function fF(e, t) {
  let n = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value
  return Math.abs(n) >= 1 && e !== Math.floor(e) && (n = e - Math.floor(e)), n
}
var iu = { formatters: b_ }
function hF(e) {
  e.set('scale', {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: 'ticks',
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (t, n) => n.lineWidth,
      tickColor: (t, n) => n.color,
      offset: !1
    },
    border: { display: !0, dash: [], dashOffset: 0, width: 1 },
    title: { display: !1, text: '', padding: { top: 4, bottom: 4 } },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: '',
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: iu.formatters.values,
      minor: {},
      major: {},
      align: 'center',
      crossAlign: 'near',
      showLabelBackdrop: !1,
      backdropColor: 'rgba(255, 255, 255, 0.75)',
      backdropPadding: 2
    }
  }),
    e.route('scale.ticks', 'color', '', 'color'),
    e.route('scale.grid', 'color', '', 'borderColor'),
    e.route('scale.border', 'color', '', 'borderColor'),
    e.route('scale.title', 'color', '', 'color'),
    e.describe('scale', {
      _fallback: !1,
      _scriptable: (t) =>
        !t.startsWith('before') && !t.startsWith('after') && t !== 'callback' && t !== 'parser',
      _indexable: (t) => t !== 'borderDash' && t !== 'tickBorderDash' && t !== 'dash'
    }),
    e.describe('scales', { _fallback: 'scale' }),
    e.describe('scale.ticks', {
      _scriptable: (t) => t !== 'backdropPadding' && t !== 'callback',
      _indexable: (t) => t !== 'backdropPadding'
    })
}
const ms = Object.create(null),
  Xd = Object.create(null)
function ur(e, t) {
  if (!t) return e
  const n = t.split('.')
  for (let i = 0, a = n.length; i < a; ++i) {
    const s = n[i]
    e = e[s] || (e[s] = Object.create(null))
  }
  return e
}
function Ru(e, t, n) {
  return typeof t == 'string' ? Or(ur(e, t), n) : Or(ur(e, ''), t)
}
class vF {
  constructor(t, n) {
    ;(this.animation = void 0),
      (this.backgroundColor = 'rgba(0,0,0,0.1)'),
      (this.borderColor = 'rgba(0,0,0,0.1)'),
      (this.color = '#666'),
      (this.datasets = {}),
      (this.devicePixelRatio = (i) => i.chart.platform.getDevicePixelRatio()),
      (this.elements = {}),
      (this.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove']),
      (this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: 'normal',
        lineHeight: 1.2,
        weight: null
      }),
      (this.hover = {}),
      (this.hoverBackgroundColor = (i, a) => Fu(a.backgroundColor)),
      (this.hoverBorderColor = (i, a) => Fu(a.borderColor)),
      (this.hoverColor = (i, a) => Fu(a.color)),
      (this.indexAxis = 'x'),
      (this.interaction = { mode: 'nearest', intersect: !0, includeInvisible: !1 }),
      (this.maintainAspectRatio = !0),
      (this.onHover = null),
      (this.onClick = null),
      (this.parsing = !0),
      (this.plugins = {}),
      (this.responsive = !0),
      (this.scale = void 0),
      (this.scales = {}),
      (this.showLine = !0),
      (this.drawActiveElementsOnTop = !0),
      this.describe(t),
      this.apply(n)
  }
  set(t, n) {
    return Ru(this, t, n)
  }
  get(t) {
    return ur(this, t)
  }
  describe(t, n) {
    return Ru(Xd, t, n)
  }
  override(t, n) {
    return Ru(ms, t, n)
  }
  route(t, n, i, a) {
    const s = ur(this, t),
      o = ur(this, i),
      r = '_' + n
    Object.defineProperties(s, {
      [r]: { value: s[n], writable: !0 },
      [n]: {
        enumerable: !0,
        get() {
          const l = this[r],
            c = o[a]
          return at(l) ? Object.assign({}, c, l) : Ze(l, c)
        },
        set(l) {
          this[r] = l
        }
      }
    })
  }
  apply(t) {
    t.forEach((n) => n(this))
  }
}
var Dt = new vF(
  {
    _scriptable: (e) => !e.startsWith('on'),
    _indexable: (e) => e !== 'events',
    hover: { _fallback: 'interaction' },
    interaction: { _scriptable: !1, _indexable: !1 }
  },
  [cF, uF, hF]
)
function gF(e) {
  return !e || lt(e.size) || lt(e.family)
    ? null
    : (e.style ? e.style + ' ' : '') + (e.weight ? e.weight + ' ' : '') + e.size + 'px ' + e.family
}
function bc(e, t, n, i, a) {
  let s = t[a]
  return s || ((s = t[a] = e.measureText(a).width), n.push(a)), s > i && (i = s), i
}
function mF(e, t, n, i) {
  i = i || {}
  let a = (i.data = i.data || {}),
    s = (i.garbageCollect = i.garbageCollect || [])
  i.font !== t && ((a = i.data = {}), (s = i.garbageCollect = []), (i.font = t)), e.save(), (e.font = t)
  let o = 0
  const r = n.length
  let l, c, u, d, f
  for (l = 0; l < r; l++)
    if (((d = n[l]), d != null && !xt(d))) o = bc(e, a, s, o, d)
    else if (xt(d))
      for (c = 0, u = d.length; c < u; c++) (f = d[c]), f != null && !xt(f) && (o = bc(e, a, s, o, f))
  e.restore()
  const h = s.length / 2
  if (h > n.length) {
    for (l = 0; l < h; l++) delete a[s[l]]
    s.splice(0, h)
  }
  return o
}
function Ya(e, t, n) {
  const i = e.currentDevicePixelRatio,
    a = n !== 0 ? Math.max(n / 2, 0.5) : 0
  return Math.round((t - a) * i) / i + a
}
function Pm(e, t) {
  ;(t = t || e.getContext('2d')),
    t.save(),
    t.resetTransform(),
    t.clearRect(0, 0, e.width, e.height),
    t.restore()
}
function Kd(e, t, n, i) {
  __(e, t, n, i, null)
}
function __(e, t, n, i, a) {
  let s, o, r, l, c, u, d, f
  const h = t.pointStyle,
    v = t.rotation,
    g = t.radius
  let p = (v || 0) * ZD
  if (
    h &&
    typeof h == 'object' &&
    ((s = h.toString()), s === '[object HTMLImageElement]' || s === '[object HTMLCanvasElement]')
  ) {
    e.save(),
      e.translate(n, i),
      e.rotate(p),
      e.drawImage(h, -h.width / 2, -h.height / 2, h.width, h.height),
      e.restore()
    return
  }
  if (!(isNaN(g) || g <= 0)) {
    switch ((e.beginPath(), h)) {
      default:
        a ? e.ellipse(n, i, a / 2, g, 0, 0, wt) : e.arc(n, i, g, 0, wt), e.closePath()
        break
      case 'triangle':
        ;(u = a ? a / 2 : g),
          e.moveTo(n + Math.sin(p) * u, i - Math.cos(p) * g),
          (p += _m),
          e.lineTo(n + Math.sin(p) * u, i - Math.cos(p) * g),
          (p += _m),
          e.lineTo(n + Math.sin(p) * u, i - Math.cos(p) * g),
          e.closePath()
        break
      case 'rectRounded':
        ;(c = g * 0.516),
          (l = g - c),
          (o = Math.cos(p + Ua) * l),
          (d = Math.cos(p + Ua) * (a ? a / 2 - c : l)),
          (r = Math.sin(p + Ua) * l),
          (f = Math.sin(p + Ua) * (a ? a / 2 - c : l)),
          e.arc(n - d, i - r, c, p - St, p - Bt),
          e.arc(n + f, i - o, c, p - Bt, p),
          e.arc(n + d, i + r, c, p, p + Bt),
          e.arc(n - f, i + o, c, p + Bt, p + St),
          e.closePath()
        break
      case 'rect':
        if (!v) {
          ;(l = Math.SQRT1_2 * g), (u = a ? a / 2 : l), e.rect(n - u, i - l, 2 * u, 2 * l)
          break
        }
        p += Ua
      case 'rectRot':
        ;(d = Math.cos(p) * (a ? a / 2 : g)),
          (o = Math.cos(p) * g),
          (r = Math.sin(p) * g),
          (f = Math.sin(p) * (a ? a / 2 : g)),
          e.moveTo(n - d, i - r),
          e.lineTo(n + f, i - o),
          e.lineTo(n + d, i + r),
          e.lineTo(n - f, i + o),
          e.closePath()
        break
      case 'crossRot':
        p += Ua
      case 'cross':
        ;(d = Math.cos(p) * (a ? a / 2 : g)),
          (o = Math.cos(p) * g),
          (r = Math.sin(p) * g),
          (f = Math.sin(p) * (a ? a / 2 : g)),
          e.moveTo(n - d, i - r),
          e.lineTo(n + d, i + r),
          e.moveTo(n + f, i - o),
          e.lineTo(n - f, i + o)
        break
      case 'star':
        ;(d = Math.cos(p) * (a ? a / 2 : g)),
          (o = Math.cos(p) * g),
          (r = Math.sin(p) * g),
          (f = Math.sin(p) * (a ? a / 2 : g)),
          e.moveTo(n - d, i - r),
          e.lineTo(n + d, i + r),
          e.moveTo(n + f, i - o),
          e.lineTo(n - f, i + o),
          (p += Ua),
          (d = Math.cos(p) * (a ? a / 2 : g)),
          (o = Math.cos(p) * g),
          (r = Math.sin(p) * g),
          (f = Math.sin(p) * (a ? a / 2 : g)),
          e.moveTo(n - d, i - r),
          e.lineTo(n + d, i + r),
          e.moveTo(n + f, i - o),
          e.lineTo(n - f, i + o)
        break
      case 'line':
        ;(o = a ? a / 2 : Math.cos(p) * g),
          (r = Math.sin(p) * g),
          e.moveTo(n - o, i - r),
          e.lineTo(n + o, i + r)
        break
      case 'dash':
        e.moveTo(n, i), e.lineTo(n + Math.cos(p) * (a ? a / 2 : g), i + Math.sin(p) * g)
        break
      case !1:
        e.closePath()
        break
    }
    e.fill(), t.borderWidth > 0 && e.stroke()
  }
}
function Gi(e, t, n) {
  return (
    (n = n || 0.5),
    !t || (e && e.x > t.left - n && e.x < t.right + n && e.y > t.top - n && e.y < t.bottom + n)
  )
}
function au(e, t) {
  e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip()
}
function su(e) {
  e.restore()
}
function pF(e, t, n, i, a) {
  if (!t) return e.lineTo(n.x, n.y)
  if (a === 'middle') {
    const s = (t.x + n.x) / 2
    e.lineTo(s, t.y), e.lineTo(s, n.y)
  } else (a === 'after') != !!i ? e.lineTo(t.x, n.y) : e.lineTo(n.x, t.y)
  e.lineTo(n.x, n.y)
}
function yF(e, t, n, i) {
  if (!t) return e.lineTo(n.x, n.y)
  e.bezierCurveTo(
    i ? t.cp1x : t.cp2x,
    i ? t.cp1y : t.cp2y,
    i ? n.cp2x : n.cp1x,
    i ? n.cp2y : n.cp1y,
    n.x,
    n.y
  )
}
function bF(e, t) {
  t.translation && e.translate(t.translation[0], t.translation[1]),
    lt(t.rotation) || e.rotate(t.rotation),
    t.color && (e.fillStyle = t.color),
    t.textAlign && (e.textAlign = t.textAlign),
    t.textBaseline && (e.textBaseline = t.textBaseline)
}
function _F(e, t, n, i, a) {
  if (a.strikethrough || a.underline) {
    const s = e.measureText(i),
      o = t - s.actualBoundingBoxLeft,
      r = t + s.actualBoundingBoxRight,
      l = n - s.actualBoundingBoxAscent,
      c = n + s.actualBoundingBoxDescent,
      u = a.strikethrough ? (l + c) / 2 : c
    ;(e.strokeStyle = e.fillStyle),
      e.beginPath(),
      (e.lineWidth = a.decorationWidth || 2),
      e.moveTo(o, u),
      e.lineTo(r, u),
      e.stroke()
  }
}
function xF(e, t) {
  const n = e.fillStyle
  ;(e.fillStyle = t.color), e.fillRect(t.left, t.top, t.width, t.height), (e.fillStyle = n)
}
function ps(e, t, n, i, a, s = {}) {
  const o = xt(t) ? t : [t],
    r = s.strokeWidth > 0 && s.strokeColor !== ''
  let l, c
  for (e.save(), e.font = a.string, bF(e, s), l = 0; l < o.length; ++l)
    (c = o[l]),
      s.backdrop && xF(e, s.backdrop),
      r &&
        (s.strokeColor && (e.strokeStyle = s.strokeColor),
        lt(s.strokeWidth) || (e.lineWidth = s.strokeWidth),
        e.strokeText(c, n, i, s.maxWidth)),
      e.fillText(c, n, i, s.maxWidth),
      _F(e, n, i, c, s),
      (i += Number(a.lineHeight))
  e.restore()
}
function Fr(e, t) {
  const { x: n, y: i, w: a, h: s, radius: o } = t
  e.arc(n + o.topLeft, i + o.topLeft, o.topLeft, 1.5 * St, St, !0),
    e.lineTo(n, i + s - o.bottomLeft),
    e.arc(n + o.bottomLeft, i + s - o.bottomLeft, o.bottomLeft, St, Bt, !0),
    e.lineTo(n + a - o.bottomRight, i + s),
    e.arc(n + a - o.bottomRight, i + s - o.bottomRight, o.bottomRight, Bt, 0, !0),
    e.lineTo(n + a, i + o.topRight),
    e.arc(n + a - o.topRight, i + o.topRight, o.topRight, 0, -Bt, !0),
    e.lineTo(n + o.topLeft, i)
}
const wF = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,
  SF = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/
function kF(e, t) {
  const n = ('' + e).match(wF)
  if (!n || n[1] === 'normal') return t * 1.2
  switch (((e = +n[2]), n[3])) {
    case 'px':
      return e
    case '%':
      e /= 100
      break
  }
  return t * e
}
const CF = (e) => +e || 0
function Ih(e, t) {
  const n = {},
    i = at(t),
    a = i ? Object.keys(t) : t,
    s = at(e) ? (i ? (o) => Ze(e[o], e[t[o]]) : (o) => e[o]) : () => e
  for (const o of a) n[o] = CF(s(o))
  return n
}
function x_(e) {
  return Ih(e, { top: 'y', right: 'x', bottom: 'y', left: 'x' })
}
function cs(e) {
  return Ih(e, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight'])
}
function fn(e) {
  const t = x_(e)
  return (t.width = t.left + t.right), (t.height = t.top + t.bottom), t
}
function jt(e, t) {
  ;(e = e || {}), (t = t || Dt.font)
  let n = Ze(e.size, t.size)
  typeof n == 'string' && (n = parseInt(n, 10))
  let i = Ze(e.style, t.style)
  i && !('' + i).match(SF) && (console.warn('Invalid font style specified: "' + i + '"'), (i = void 0))
  const a = {
    family: Ze(e.family, t.family),
    lineHeight: kF(Ze(e.lineHeight, t.lineHeight), n),
    size: n,
    style: i,
    weight: Ze(e.weight, t.weight),
    string: ''
  }
  return (a.string = gF(a)), a
}
function Yo(e, t, n, i) {
  let a = !0,
    s,
    o,
    r
  for (s = 0, o = e.length; s < o; ++s)
    if (
      ((r = e[s]),
      r !== void 0 &&
        (t !== void 0 && typeof r == 'function' && ((r = r(t)), (a = !1)),
        n !== void 0 && xt(r) && ((r = r[n % r.length]), (a = !1)),
        r !== void 0))
    )
      return i && !a && (i.cacheable = !1), r
}
function MF(e, t, n) {
  const { min: i, max: a } = e,
    s = c_(t, (a - i) / 2),
    o = (r, l) => (n && r === 0 ? 0 : r + l)
  return { min: o(i, -Math.abs(s)), max: o(a, s) }
}
function Ba(e, t) {
  return Object.assign(Object.create(e), t)
}
function Dh(e, t = [''], n, i, a = () => e[0]) {
  const s = n || e
  typeof i > 'u' && (i = C_('_fallback', e))
  const o = {
    [Symbol.toStringTag]: 'Object',
    _cacheable: !0,
    _scopes: e,
    _rootScopes: s,
    _fallback: i,
    _getTarget: a,
    override: (r) => Dh([r, ...e], t, s, i)
  }
  return new Proxy(o, {
    deleteProperty(r, l) {
      return delete r[l], delete r._keys, delete e[0][l], !0
    },
    get(r, l) {
      return S_(r, l, () => IF(l, t, e, r))
    },
    getOwnPropertyDescriptor(r, l) {
      return Reflect.getOwnPropertyDescriptor(r._scopes[0], l)
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e[0])
    },
    has(r, l) {
      return Vm(r).includes(l)
    },
    ownKeys(r) {
      return Vm(r)
    },
    set(r, l, c) {
      const u = r._storage || (r._storage = a())
      return (r[l] = u[l] = c), delete r._keys, !0
    }
  })
}
function ao(e, t, n, i) {
  const a = {
    _cacheable: !1,
    _proxy: e,
    _context: t,
    _subProxy: n,
    _stack: new Set(),
    _descriptors: w_(e, i),
    setContext: (s) => ao(e, s, n, i),
    override: (s) => ao(e.override(s), t, n, i)
  }
  return new Proxy(a, {
    deleteProperty(s, o) {
      return delete s[o], delete e[o], !0
    },
    get(s, o, r) {
      return S_(s, o, () => PF(s, o, r))
    },
    getOwnPropertyDescriptor(s, o) {
      return s._descriptors.allKeys
        ? Reflect.has(e, o)
          ? { enumerable: !0, configurable: !0 }
          : void 0
        : Reflect.getOwnPropertyDescriptor(e, o)
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e)
    },
    has(s, o) {
      return Reflect.has(e, o)
    },
    ownKeys() {
      return Reflect.ownKeys(e)
    },
    set(s, o, r) {
      return (e[o] = r), delete s[o], !0
    }
  })
}
function w_(e, t = { scriptable: !0, indexable: !0 }) {
  const { _scriptable: n = t.scriptable, _indexable: i = t.indexable, _allKeys: a = t.allKeys } = e
  return {
    allKeys: a,
    scriptable: n,
    indexable: i,
    isScriptable: Va(n) ? n : () => n,
    isIndexable: Va(i) ? i : () => i
  }
}
const AF = (e, t) => (e ? e + Th(t) : t),
  Fh = (e, t) => at(t) && e !== 'adapters' && (Object.getPrototypeOf(t) === null || t.constructor === Object)
function S_(e, t, n) {
  if (Object.prototype.hasOwnProperty.call(e, t)) return e[t]
  const i = n()
  return (e[t] = i), i
}
function PF(e, t, n) {
  const { _proxy: i, _context: a, _subProxy: s, _descriptors: o } = e
  let r = i[t]
  return (
    Va(r) && o.isScriptable(t) && (r = TF(t, r, e, n)),
    xt(r) && r.length && (r = VF(t, r, e, o.isIndexable)),
    Fh(t, r) && (r = ao(r, a, s && s[t], o)),
    r
  )
}
function TF(e, t, n, i) {
  const { _proxy: a, _context: s, _subProxy: o, _stack: r } = n
  if (r.has(e)) throw new Error('Recursion detected: ' + Array.from(r).join('->') + '->' + e)
  r.add(e)
  let l = t(s, o || i)
  return r.delete(e), Fh(e, l) && (l = Rh(a._scopes, a, e, l)), l
}
function VF(e, t, n, i) {
  const { _proxy: a, _context: s, _subProxy: o, _descriptors: r } = n
  if (typeof s.index < 'u' && i(e)) return t[s.index % t.length]
  if (at(t[0])) {
    const l = t,
      c = a._scopes.filter((u) => u !== l)
    t = []
    for (const u of l) {
      const d = Rh(c, a, e, u)
      t.push(ao(d, s, o && o[e], r))
    }
  }
  return t
}
function k_(e, t, n) {
  return Va(e) ? e(t, n) : e
}
const EF = (e, t) => (e === !0 ? t : typeof e == 'string' ? Ta(t, e) : void 0)
function LF(e, t, n, i, a) {
  for (const s of t) {
    const o = EF(n, s)
    if (o) {
      e.add(o)
      const r = k_(o._fallback, n, a)
      if (typeof r < 'u' && r !== n && r !== i) return r
    } else if (o === !1 && typeof i < 'u' && n !== i) return null
  }
  return !1
}
function Rh(e, t, n, i) {
  const a = t._rootScopes,
    s = k_(t._fallback, n, i),
    o = [...e, ...a],
    r = new Set()
  r.add(i)
  let l = Tm(r, o, n, s || n, i)
  return l === null || (typeof s < 'u' && s !== n && ((l = Tm(r, o, s, l, i)), l === null))
    ? !1
    : Dh(Array.from(r), [''], a, s, () => OF(t, n, i))
}
function Tm(e, t, n, i, a) {
  for (; n; ) n = LF(e, t, n, i, a)
  return n
}
function OF(e, t, n) {
  const i = e._getTarget()
  t in i || (i[t] = {})
  const a = i[t]
  return xt(a) && at(n) ? n : a || {}
}
function IF(e, t, n, i) {
  let a
  for (const s of t) if (((a = C_(AF(s, e), n)), typeof a < 'u')) return Fh(e, a) ? Rh(n, i, e, a) : a
}
function C_(e, t) {
  for (const n of t) {
    if (!n) continue
    const i = n[e]
    if (typeof i < 'u') return i
  }
}
function Vm(e) {
  let t = e._keys
  return t || (t = e._keys = DF(e._scopes)), t
}
function DF(e) {
  const t = new Set()
  for (const n of e) for (const i of Object.keys(n).filter((a) => !a.startsWith('_'))) t.add(i)
  return Array.from(t)
}
function M_(e, t, n, i) {
  const { iScale: a } = e,
    { key: s = 'r' } = this._parsing,
    o = new Array(i)
  let r, l, c, u
  for (r = 0, l = i; r < l; ++r) (c = r + n), (u = t[c]), (o[r] = { r: a.parse(Ta(u, s), c) })
  return o
}
const FF = Number.EPSILON || 1e-14,
  so = (e, t) => t < e.length && !e[t].skip && e[t],
  A_ = (e) => (e === 'x' ? 'y' : 'x')
function RF(e, t, n, i) {
  const a = e.skip ? t : e,
    s = t,
    o = n.skip ? t : n,
    r = Gd(s, a),
    l = Gd(o, s)
  let c = r / (r + l),
    u = l / (r + l)
  ;(c = isNaN(c) ? 0 : c), (u = isNaN(u) ? 0 : u)
  const d = i * c,
    f = i * u
  return {
    previous: { x: s.x - d * (o.x - a.x), y: s.y - d * (o.y - a.y) },
    next: { x: s.x + f * (o.x - a.x), y: s.y + f * (o.y - a.y) }
  }
}
function BF(e, t, n) {
  const i = e.length
  let a,
    s,
    o,
    r,
    l,
    c = so(e, 0)
  for (let u = 0; u < i - 1; ++u)
    if (((l = c), (c = so(e, u + 1)), !(!l || !c))) {
      if (lr(t[u], 0, FF)) {
        n[u] = n[u + 1] = 0
        continue
      }
      ;(a = n[u] / t[u]),
        (s = n[u + 1] / t[u]),
        (r = Math.pow(a, 2) + Math.pow(s, 2)),
        !(r <= 9) && ((o = 3 / Math.sqrt(r)), (n[u] = a * o * t[u]), (n[u + 1] = s * o * t[u]))
    }
}
function NF(e, t, n = 'x') {
  const i = A_(n),
    a = e.length
  let s,
    o,
    r,
    l = so(e, 0)
  for (let c = 0; c < a; ++c) {
    if (((o = r), (r = l), (l = so(e, c + 1)), !r)) continue
    const u = r[n],
      d = r[i]
    o && ((s = (u - o[n]) / 3), (r[`cp1${n}`] = u - s), (r[`cp1${i}`] = d - s * t[c])),
      l && ((s = (l[n] - u) / 3), (r[`cp2${n}`] = u + s), (r[`cp2${i}`] = d + s * t[c]))
  }
}
function $F(e, t = 'x') {
  const n = A_(t),
    i = e.length,
    a = Array(i).fill(0),
    s = Array(i)
  let o,
    r,
    l,
    c = so(e, 0)
  for (o = 0; o < i; ++o)
    if (((r = l), (l = c), (c = so(e, o + 1)), !!l)) {
      if (c) {
        const u = c[t] - l[t]
        a[o] = u !== 0 ? (c[n] - l[n]) / u : 0
      }
      s[o] = r ? (c ? (Ai(a[o - 1]) !== Ai(a[o]) ? 0 : (a[o - 1] + a[o]) / 2) : a[o - 1]) : a[o]
    }
  BF(e, a, s), NF(e, s, t)
}
function Sl(e, t, n) {
  return Math.max(Math.min(e, n), t)
}
function zF(e, t) {
  let n,
    i,
    a,
    s,
    o,
    r = Gi(e[0], t)
  for (n = 0, i = e.length; n < i; ++n)
    (o = s),
      (s = r),
      (r = n < i - 1 && Gi(e[n + 1], t)),
      s &&
        ((a = e[n]),
        o && ((a.cp1x = Sl(a.cp1x, t.left, t.right)), (a.cp1y = Sl(a.cp1y, t.top, t.bottom))),
        r && ((a.cp2x = Sl(a.cp2x, t.left, t.right)), (a.cp2y = Sl(a.cp2y, t.top, t.bottom))))
}
function HF(e, t, n, i, a) {
  let s, o, r, l
  if ((t.spanGaps && (e = e.filter((c) => !c.skip)), t.cubicInterpolationMode === 'monotone')) $F(e, a)
  else {
    let c = i ? e[e.length - 1] : e[0]
    for (s = 0, o = e.length; s < o; ++s)
      (r = e[s]),
        (l = RF(c, r, e[Math.min(s + 1, o - (i ? 0 : 1)) % o], t.tension)),
        (r.cp1x = l.previous.x),
        (r.cp1y = l.previous.y),
        (r.cp2x = l.next.x),
        (r.cp2y = l.next.y),
        (c = r)
  }
  t.capBezierPoints && zF(e, n)
}
function P_() {
  return typeof window < 'u' && typeof document < 'u'
}
function Bh(e) {
  let t = e.parentNode
  return t && t.toString() === '[object ShadowRoot]' && (t = t.host), t
}
function _c(e, t, n) {
  let i
  return (
    typeof e == 'string'
      ? ((i = parseInt(e, 10)), e.indexOf('%') !== -1 && (i = (i / 100) * t.parentNode[n]))
      : (i = e),
    i
  )
}
const ou = (e) => e.ownerDocument.defaultView.getComputedStyle(e, null)
function WF(e, t) {
  return ou(e).getPropertyValue(t)
}
const jF = ['top', 'right', 'bottom', 'left']
function us(e, t, n) {
  const i = {}
  n = n ? '-' + n : ''
  for (let a = 0; a < 4; a++) {
    const s = jF[a]
    i[s] = parseFloat(e[t + '-' + s + n]) || 0
  }
  return (i.width = i.left + i.right), (i.height = i.top + i.bottom), i
}
const UF = (e, t, n) => (e > 0 || t > 0) && (!n || !n.shadowRoot)
function YF(e, t) {
  const n = e.touches,
    i = n && n.length ? n[0] : e,
    { offsetX: a, offsetY: s } = i
  let o = !1,
    r,
    l
  if (UF(a, s, e.target)) (r = a), (l = s)
  else {
    const c = t.getBoundingClientRect()
    ;(r = i.clientX - c.left), (l = i.clientY - c.top), (o = !0)
  }
  return { x: r, y: l, box: o }
}
function Ka(e, t) {
  if ('native' in e) return e
  const { canvas: n, currentDevicePixelRatio: i } = t,
    a = ou(n),
    s = a.boxSizing === 'border-box',
    o = us(a, 'padding'),
    r = us(a, 'border', 'width'),
    { x: l, y: c, box: u } = YF(e, n),
    d = o.left + (u && r.left),
    f = o.top + (u && r.top)
  let { width: h, height: v } = t
  return (
    s && ((h -= o.width + r.width), (v -= o.height + r.height)),
    { x: Math.round((((l - d) / h) * n.width) / i), y: Math.round((((c - f) / v) * n.height) / i) }
  )
}
function GF(e, t, n) {
  let i, a
  if (t === void 0 || n === void 0) {
    const s = Bh(e)
    if (!s) (t = e.clientWidth), (n = e.clientHeight)
    else {
      const o = s.getBoundingClientRect(),
        r = ou(s),
        l = us(r, 'border', 'width'),
        c = us(r, 'padding')
      ;(t = o.width - c.width - l.width),
        (n = o.height - c.height - l.height),
        (i = _c(r.maxWidth, s, 'clientWidth')),
        (a = _c(r.maxHeight, s, 'clientHeight'))
    }
  }
  return { width: t, height: n, maxWidth: i || yc, maxHeight: a || yc }
}
const kl = (e) => Math.round(e * 10) / 10
function XF(e, t, n, i) {
  const a = ou(e),
    s = us(a, 'margin'),
    o = _c(a.maxWidth, e, 'clientWidth') || yc,
    r = _c(a.maxHeight, e, 'clientHeight') || yc,
    l = GF(e, t, n)
  let { width: c, height: u } = l
  if (a.boxSizing === 'content-box') {
    const f = us(a, 'border', 'width'),
      h = us(a, 'padding')
    ;(c -= h.width + f.width), (u -= h.height + f.height)
  }
  return (
    (c = Math.max(0, c - s.width)),
    (u = Math.max(0, i ? c / i : u - s.height)),
    (c = kl(Math.min(c, o, l.maxWidth))),
    (u = kl(Math.min(u, r, l.maxHeight))),
    c && !u && (u = kl(c / 2)),
    (t !== void 0 || n !== void 0) &&
      i &&
      l.height &&
      u > l.height &&
      ((u = l.height), (c = kl(Math.floor(u * i)))),
    { width: c, height: u }
  )
}
function Em(e, t, n) {
  const i = t || 1,
    a = Math.floor(e.height * i),
    s = Math.floor(e.width * i)
  ;(e.height = Math.floor(e.height)), (e.width = Math.floor(e.width))
  const o = e.canvas
  return (
    o.style &&
      (n || (!o.style.height && !o.style.width)) &&
      ((o.style.height = `${e.height}px`), (o.style.width = `${e.width}px`)),
    e.currentDevicePixelRatio !== i || o.height !== a || o.width !== s
      ? ((e.currentDevicePixelRatio = i),
        (o.height = a),
        (o.width = s),
        e.ctx.setTransform(i, 0, 0, i, 0, 0),
        !0)
      : !1
  )
}
const KF = (function () {
  let e = !1
  try {
    const t = {
      get passive() {
        return (e = !0), !1
      }
    }
    window.addEventListener('test', null, t), window.removeEventListener('test', null, t)
  } catch {}
  return e
})()
function Lm(e, t) {
  const n = WF(e, t),
    i = n && n.match(/^(\d+)(\.\d+)?px$/)
  return i ? +i[1] : void 0
}
function qa(e, t, n, i) {
  return { x: e.x + n * (t.x - e.x), y: e.y + n * (t.y - e.y) }
}
function qF(e, t, n, i) {
  return {
    x: e.x + n * (t.x - e.x),
    y: i === 'middle' ? (n < 0.5 ? e.y : t.y) : i === 'after' ? (n < 1 ? e.y : t.y) : n > 0 ? t.y : e.y
  }
}
function ZF(e, t, n, i) {
  const a = { x: e.cp2x, y: e.cp2y },
    s = { x: t.cp1x, y: t.cp1y },
    o = qa(e, a, n),
    r = qa(a, s, n),
    l = qa(s, t, n),
    c = qa(o, r, n),
    u = qa(r, l, n)
  return qa(c, u, n)
}
const JF = function (e, t) {
    return {
      x(n) {
        return e + e + t - n
      },
      setWidth(n) {
        t = n
      },
      textAlign(n) {
        return n === 'center' ? n : n === 'right' ? 'left' : 'right'
      },
      xPlus(n, i) {
        return n - i
      },
      leftForLtr(n, i) {
        return n - i
      }
    }
  },
  QF = function () {
    return {
      x(e) {
        return e
      },
      setWidth(e) {},
      textAlign(e) {
        return e
      },
      xPlus(e, t) {
        return e + t
      },
      leftForLtr(e, t) {
        return e
      }
    }
  }
function Gs(e, t, n) {
  return e ? JF(t, n) : QF()
}
function T_(e, t) {
  let n, i
  ;(t === 'ltr' || t === 'rtl') &&
    ((n = e.canvas.style),
    (i = [n.getPropertyValue('direction'), n.getPropertyPriority('direction')]),
    n.setProperty('direction', t, 'important'),
    (e.prevTextDirection = i))
}
function V_(e, t) {
  t !== void 0 && (delete e.prevTextDirection, e.canvas.style.setProperty('direction', t[0], t[1]))
}
function E_(e) {
  return e === 'angle'
    ? { between: Dr, compare: eF, normalize: En }
    : { between: Ui, compare: (t, n) => t - n, normalize: (t) => t }
}
function Om({ start: e, end: t, count: n, loop: i, style: a }) {
  return { start: e % n, end: t % n, loop: i && (t - e + 1) % n === 0, style: a }
}
function e5(e, t, n) {
  const { property: i, start: a, end: s } = n,
    { between: o, normalize: r } = E_(i),
    l = t.length
  let { start: c, end: u, loop: d } = e,
    f,
    h
  if (d) {
    for (c += l, u += l, f = 0, h = l; f < h && o(r(t[c % l][i]), a, s); ++f) c--, u--
    ;(c %= l), (u %= l)
  }
  return u < c && (u += l), { start: c, end: u, loop: d, style: e.style }
}
function L_(e, t, n) {
  if (!n) return [e]
  const { property: i, start: a, end: s } = n,
    o = t.length,
    { compare: r, between: l, normalize: c } = E_(i),
    { start: u, end: d, loop: f, style: h } = e5(e, t, n),
    v = []
  let g = !1,
    p = null,
    y,
    b,
    x
  const w = () => l(a, x, y) && r(a, x) !== 0,
    C = () => r(s, y) === 0 || l(s, x, y),
    P = () => g || w(),
    k = () => !g || C()
  for (let S = u, _ = u; S <= d; ++S)
    (b = t[S % o]),
      !b.skip &&
        ((y = c(b[i])),
        y !== x &&
          ((g = l(y, a, s)),
          p === null && P() && (p = r(y, a) === 0 ? S : _),
          p !== null && k() && (v.push(Om({ start: p, end: S, loop: f, count: o, style: h })), (p = null)),
          (_ = S),
          (x = y)))
  return p !== null && v.push(Om({ start: p, end: d, loop: f, count: o, style: h })), v
}
function O_(e, t) {
  const n = [],
    i = e.segments
  for (let a = 0; a < i.length; a++) {
    const s = L_(i[a], e.points, t)
    s.length && n.push(...s)
  }
  return n
}
function t5(e, t, n, i) {
  let a = 0,
    s = t - 1
  if (n && !i) for (; a < t && !e[a].skip; ) a++
  for (; a < t && e[a].skip; ) a++
  for (a %= t, n && (s += a); s > a && e[s % t].skip; ) s--
  return (s %= t), { start: a, end: s }
}
function n5(e, t, n, i) {
  const a = e.length,
    s = []
  let o = t,
    r = e[t],
    l
  for (l = t + 1; l <= n; ++l) {
    const c = e[l % a]
    c.skip || c.stop
      ? r.skip || ((i = !1), s.push({ start: t % a, end: (l - 1) % a, loop: i }), (t = o = c.stop ? l : null))
      : ((o = l), r.skip && (t = l)),
      (r = c)
  }
  return o !== null && s.push({ start: t % a, end: o % a, loop: i }), s
}
function i5(e, t) {
  const n = e.points,
    i = e.options.spanGaps,
    a = n.length
  if (!a) return []
  const s = !!e._loop,
    { start: o, end: r } = t5(n, a, s, i)
  if (i === !0) return Im(e, [{ start: o, end: r, loop: s }], n, t)
  const l = r < o ? r + a : r,
    c = !!e._fullLoop && o === 0 && r === a - 1
  return Im(e, n5(n, o, l, c), n, t)
}
function Im(e, t, n, i) {
  return !i || !i.setContext || !n ? t : a5(e, t, n, i)
}
function a5(e, t, n, i) {
  const a = e._chart.getContext(),
    s = Dm(e.options),
    {
      _datasetIndex: o,
      options: { spanGaps: r }
    } = e,
    l = n.length,
    c = []
  let u = s,
    d = t[0].start,
    f = d
  function h(v, g, p, y) {
    const b = r ? -1 : 1
    if (v !== g) {
      for (v += l; n[v % l].skip; ) v -= b
      for (; n[g % l].skip; ) g += b
      v % l !== g % l && (c.push({ start: v % l, end: g % l, loop: p, style: y }), (u = y), (d = g % l))
    }
  }
  for (const v of t) {
    d = r ? d : v.start
    let g = n[d % l],
      p
    for (f = d + 1; f <= v.end; f++) {
      const y = n[f % l]
      ;(p = Dm(
        i.setContext(
          Ba(a, {
            type: 'segment',
            p0: g,
            p1: y,
            p0DataIndex: (f - 1) % l,
            p1DataIndex: f % l,
            datasetIndex: o
          })
        )
      )),
        s5(p, u) && h(d, f - 1, v.loop, u),
        (g = y),
        (u = p)
    }
    d < f - 1 && h(d, f - 1, v.loop, u)
  }
  return c
}
function Dm(e) {
  return {
    backgroundColor: e.backgroundColor,
    borderCapStyle: e.borderCapStyle,
    borderDash: e.borderDash,
    borderDashOffset: e.borderDashOffset,
    borderJoinStyle: e.borderJoinStyle,
    borderWidth: e.borderWidth,
    borderColor: e.borderColor
  }
}
function s5(e, t) {
  if (!t) return !1
  const n = [],
    i = function (a, s) {
      return Oh(s) ? (n.includes(s) || n.push(s), n.indexOf(s)) : s
    }
  return JSON.stringify(e, i) !== JSON.stringify(t, i)
}
/*!
 * Chart.js v4.4.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */ class o5 {
  constructor() {
    ;(this._request = null), (this._charts = new Map()), (this._running = !1), (this._lastDate = void 0)
  }
  _notify(t, n, i, a) {
    const s = n.listeners[a],
      o = n.duration
    s.forEach((r) => r({ chart: t, initial: n.initial, numSteps: o, currentStep: Math.min(i - n.start, o) }))
  }
  _refresh() {
    this._request ||
      ((this._running = !0),
      (this._request = g_.call(window, () => {
        this._update(), (this._request = null), this._running && this._refresh()
      })))
  }
  _update(t = Date.now()) {
    let n = 0
    this._charts.forEach((i, a) => {
      if (!i.running || !i.items.length) return
      const s = i.items
      let o = s.length - 1,
        r = !1,
        l
      for (; o >= 0; --o)
        (l = s[o]),
          l._active
            ? (l._total > i.duration && (i.duration = l._total), l.tick(t), (r = !0))
            : ((s[o] = s[s.length - 1]), s.pop())
      r && (a.draw(), this._notify(a, i, t, 'progress')),
        s.length || ((i.running = !1), this._notify(a, i, t, 'complete'), (i.initial = !1)),
        (n += s.length)
    }),
      (this._lastDate = t),
      n === 0 && (this._running = !1)
  }
  _getAnims(t) {
    const n = this._charts
    let i = n.get(t)
    return (
      i ||
        ((i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }),
        n.set(t, i)),
      i
    )
  }
  listen(t, n, i) {
    this._getAnims(t).listeners[n].push(i)
  }
  add(t, n) {
    !n || !n.length || this._getAnims(t).items.push(...n)
  }
  has(t) {
    return this._getAnims(t).items.length > 0
  }
  start(t) {
    const n = this._charts.get(t)
    n &&
      ((n.running = !0),
      (n.start = Date.now()),
      (n.duration = n.items.reduce((i, a) => Math.max(i, a._duration), 0)),
      this._refresh())
  }
  running(t) {
    if (!this._running) return !1
    const n = this._charts.get(t)
    return !(!n || !n.running || !n.items.length)
  }
  stop(t) {
    const n = this._charts.get(t)
    if (!n || !n.items.length) return
    const i = n.items
    let a = i.length - 1
    for (; a >= 0; --a) i[a].cancel()
    ;(n.items = []), this._notify(t, n, Date.now(), 'complete')
  }
  remove(t) {
    return this._charts.delete(t)
  }
}
var $i = new o5()
const Fm = 'transparent',
  r5 = {
    boolean(e, t, n) {
      return n > 0.5 ? t : e
    },
    color(e, t, n) {
      const i = Mm(e || Fm),
        a = i.valid && Mm(t || Fm)
      return a && a.valid ? a.mix(i, n).hexString() : t
    },
    number(e, t, n) {
      return e + (t - e) * n
    }
  }
class l5 {
  constructor(t, n, i, a) {
    const s = n[i]
    a = Yo([t.to, a, s, t.from])
    const o = Yo([t.from, s, a])
    ;(this._active = !0),
      (this._fn = t.fn || r5[t.type || typeof o]),
      (this._easing = cr[t.easing] || cr.linear),
      (this._start = Math.floor(Date.now() + (t.delay || 0))),
      (this._duration = this._total = Math.floor(t.duration)),
      (this._loop = !!t.loop),
      (this._target = n),
      (this._prop = i),
      (this._from = o),
      (this._to = a),
      (this._promises = void 0)
  }
  active() {
    return this._active
  }
  update(t, n, i) {
    if (this._active) {
      this._notify(!1)
      const a = this._target[this._prop],
        s = i - this._start,
        o = this._duration - s
      ;(this._start = i),
        (this._duration = Math.floor(Math.max(o, t.duration))),
        (this._total += s),
        (this._loop = !!t.loop),
        (this._to = Yo([t.to, n, a, t.from])),
        (this._from = Yo([t.from, a, n]))
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), (this._active = !1), this._notify(!1))
  }
  tick(t) {
    const n = t - this._start,
      i = this._duration,
      a = this._prop,
      s = this._from,
      o = this._loop,
      r = this._to
    let l
    if (((this._active = s !== r && (o || n < i)), !this._active)) {
      ;(this._target[a] = r), this._notify(!0)
      return
    }
    if (n < 0) {
      this._target[a] = s
      return
    }
    ;(l = (n / i) % 2),
      (l = o && l > 1 ? 2 - l : l),
      (l = this._easing(Math.min(1, Math.max(0, l)))),
      (this._target[a] = this._fn(s, r, l))
  }
  wait() {
    const t = this._promises || (this._promises = [])
    return new Promise((n, i) => {
      t.push({ res: n, rej: i })
    })
  }
  _notify(t) {
    const n = t ? 'res' : 'rej',
      i = this._promises || []
    for (let a = 0; a < i.length; a++) i[a][n]()
  }
}
class I_ {
  constructor(t, n) {
    ;(this._chart = t), (this._properties = new Map()), this.configure(n)
  }
  configure(t) {
    if (!at(t)) return
    const n = Object.keys(Dt.animation),
      i = this._properties
    Object.getOwnPropertyNames(t).forEach((a) => {
      const s = t[a]
      if (!at(s)) return
      const o = {}
      for (const r of n) o[r] = s[r]
      ;((xt(s.properties) && s.properties) || [a]).forEach((r) => {
        ;(r === a || !i.has(r)) && i.set(r, o)
      })
    })
  }
  _animateOptions(t, n) {
    const i = n.options,
      a = u5(t, i)
    if (!a) return []
    const s = this._createAnimations(a, i)
    return (
      i.$shared &&
        c5(t.options.$animations, i).then(
          () => {
            t.options = i
          },
          () => {}
        ),
      s
    )
  }
  _createAnimations(t, n) {
    const i = this._properties,
      a = [],
      s = t.$animations || (t.$animations = {}),
      o = Object.keys(n),
      r = Date.now()
    let l
    for (l = o.length - 1; l >= 0; --l) {
      const c = o[l]
      if (c.charAt(0) === '$') continue
      if (c === 'options') {
        a.push(...this._animateOptions(t, n))
        continue
      }
      const u = n[c]
      let d = s[c]
      const f = i.get(c)
      if (d)
        if (f && d.active()) {
          d.update(f, u, r)
          continue
        } else d.cancel()
      if (!f || !f.duration) {
        t[c] = u
        continue
      }
      ;(s[c] = d = new l5(f, t, c, u)), a.push(d)
    }
    return a
  }
  update(t, n) {
    if (this._properties.size === 0) {
      Object.assign(t, n)
      return
    }
    const i = this._createAnimations(t, n)
    if (i.length) return $i.add(this._chart, i), !0
  }
}
function c5(e, t) {
  const n = [],
    i = Object.keys(t)
  for (let a = 0; a < i.length; a++) {
    const s = e[i[a]]
    s && s.active() && n.push(s.wait())
  }
  return Promise.all(n)
}
function u5(e, t) {
  if (!t) return
  let n = e.options
  if (!n) {
    e.options = t
    return
  }
  return n.$shared && (e.options = n = Object.assign({}, n, { $shared: !1, $animations: {} })), n
}
function Rm(e, t) {
  const n = (e && e.options) || {},
    i = n.reverse,
    a = n.min === void 0 ? t : 0,
    s = n.max === void 0 ? t : 0
  return { start: i ? s : a, end: i ? a : s }
}
function d5(e, t, n) {
  if (n === !1) return !1
  const i = Rm(e, n),
    a = Rm(t, n)
  return { top: a.end, right: i.end, bottom: a.start, left: i.start }
}
function f5(e) {
  let t, n, i, a
  return (
    at(e) ? ((t = e.top), (n = e.right), (i = e.bottom), (a = e.left)) : (t = n = i = a = e),
    { top: t, right: n, bottom: i, left: a, disabled: e === !1 }
  )
}
function D_(e, t) {
  const n = [],
    i = e._getSortedDatasetMetas(t)
  let a, s
  for (a = 0, s = i.length; a < s; ++a) n.push(i[a].index)
  return n
}
function Bm(e, t, n, i = {}) {
  const a = e.keys,
    s = i.mode === 'single'
  let o, r, l, c
  if (t !== null) {
    for (o = 0, r = a.length; o < r; ++o) {
      if (((l = +a[o]), l === n)) {
        if (i.all) continue
        break
      }
      ;(c = e.values[l]), It(c) && (s || t === 0 || Ai(t) === Ai(c)) && (t += c)
    }
    return t
  }
}
function h5(e) {
  const t = Object.keys(e),
    n = new Array(t.length)
  let i, a, s
  for (i = 0, a = t.length; i < a; ++i) (s = t[i]), (n[i] = { x: s, y: e[s] })
  return n
}
function Nm(e, t) {
  const n = e && e.options.stacked
  return n || (n === void 0 && t.stack !== void 0)
}
function v5(e, t, n) {
  return `${e.id}.${t.id}.${n.stack || n.type}`
}
function g5(e) {
  const { min: t, max: n, minDefined: i, maxDefined: a } = e.getUserBounds()
  return { min: i ? t : Number.NEGATIVE_INFINITY, max: a ? n : Number.POSITIVE_INFINITY }
}
function m5(e, t, n) {
  const i = e[t] || (e[t] = {})
  return i[n] || (i[n] = {})
}
function $m(e, t, n, i) {
  for (const a of t.getMatchingVisibleMetas(i).reverse()) {
    const s = e[a.index]
    if ((n && s > 0) || (!n && s < 0)) return a.index
  }
  return null
}
function zm(e, t) {
  const { chart: n, _cachedMeta: i } = e,
    a = n._stacks || (n._stacks = {}),
    { iScale: s, vScale: o, index: r } = i,
    l = s.axis,
    c = o.axis,
    u = v5(s, o, i),
    d = t.length
  let f
  for (let h = 0; h < d; ++h) {
    const v = t[h],
      { [l]: g, [c]: p } = v,
      y = v._stacks || (v._stacks = {})
    ;(f = y[c] = m5(a, u, g)), (f[r] = p), (f._top = $m(f, o, !0, i.type)), (f._bottom = $m(f, o, !1, i.type))
    const b = f._visualValues || (f._visualValues = {})
    b[r] = p
  }
}
function Bu(e, t) {
  const n = e.scales
  return Object.keys(n)
    .filter((i) => n[i].axis === t)
    .shift()
}
function p5(e, t) {
  return Ba(e, { active: !1, dataset: void 0, datasetIndex: t, index: t, mode: 'default', type: 'dataset' })
}
function y5(e, t, n) {
  return Ba(e, {
    active: !1,
    dataIndex: t,
    parsed: void 0,
    raw: void 0,
    element: n,
    index: t,
    mode: 'default',
    type: 'data'
  })
}
function Do(e, t) {
  const n = e.controller.index,
    i = e.vScale && e.vScale.axis
  if (i) {
    t = t || e._parsed
    for (const a of t) {
      const s = a._stacks
      if (!s || s[i] === void 0 || s[i][n] === void 0) return
      delete s[i][n],
        s[i]._visualValues !== void 0 && s[i]._visualValues[n] !== void 0 && delete s[i]._visualValues[n]
    }
  }
}
const Nu = (e) => e === 'reset' || e === 'none',
  Hm = (e, t) => (t ? e : Object.assign({}, e)),
  b5 = (e, t, n) => e && !t.hidden && t._stacked && { keys: D_(n, !0), values: null }
class ui {
  constructor(t, n) {
    ;(this.chart = t),
      (this._ctx = t.ctx),
      (this.index = n),
      (this._cachedDataOpts = {}),
      (this._cachedMeta = this.getMeta()),
      (this._type = this._cachedMeta.type),
      (this.options = void 0),
      (this._parsing = !1),
      (this._data = void 0),
      (this._objectData = void 0),
      (this._sharedOptions = void 0),
      (this._drawStart = void 0),
      (this._drawCount = void 0),
      (this.enableOptionSharing = !1),
      (this.supportsDecimation = !1),
      (this.$context = void 0),
      (this._syncList = []),
      (this.datasetElementType = new.target.datasetElementType),
      (this.dataElementType = new.target.dataElementType),
      this.initialize()
  }
  initialize() {
    const t = this._cachedMeta
    this.configure(),
      this.linkScales(),
      (t._stacked = Nm(t.vScale, t)),
      this.addElements(),
      this.options.fill &&
        !this.chart.isPluginEnabled('filler') &&
        console.warn(
          "Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options"
        )
  }
  updateIndex(t) {
    this.index !== t && Do(this._cachedMeta), (this.index = t)
  }
  linkScales() {
    const t = this.chart,
      n = this._cachedMeta,
      i = this.getDataset(),
      a = (d, f, h, v) => (d === 'x' ? f : d === 'r' ? v : h),
      s = (n.xAxisID = Ze(i.xAxisID, Bu(t, 'x'))),
      o = (n.yAxisID = Ze(i.yAxisID, Bu(t, 'y'))),
      r = (n.rAxisID = Ze(i.rAxisID, Bu(t, 'r'))),
      l = n.indexAxis,
      c = (n.iAxisID = a(l, s, o, r)),
      u = (n.vAxisID = a(l, o, s, r))
    ;(n.xScale = this.getScaleForId(s)),
      (n.yScale = this.getScaleForId(o)),
      (n.rScale = this.getScaleForId(r)),
      (n.iScale = this.getScaleForId(c)),
      (n.vScale = this.getScaleForId(u))
  }
  getDataset() {
    return this.chart.data.datasets[this.index]
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index)
  }
  getScaleForId(t) {
    return this.chart.scales[t]
  }
  _getOtherScale(t) {
    const n = this._cachedMeta
    return t === n.iScale ? n.vScale : n.iScale
  }
  reset() {
    this._update('reset')
  }
  _destroy() {
    const t = this._cachedMeta
    this._data && Sm(this._data, this), t._stacked && Do(t)
  }
  _dataCheck() {
    const t = this.getDataset(),
      n = t.data || (t.data = []),
      i = this._data
    if (at(n)) this._data = h5(n)
    else if (i !== n) {
      if (i) {
        Sm(i, this)
        const a = this._cachedMeta
        Do(a), (a._parsed = [])
      }
      n && Object.isExtensible(n) && aF(n, this), (this._syncList = []), (this._data = n)
    }
  }
  addElements() {
    const t = this._cachedMeta
    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType())
  }
  buildOrUpdateElements(t) {
    const n = this._cachedMeta,
      i = this.getDataset()
    let a = !1
    this._dataCheck()
    const s = n._stacked
    ;(n._stacked = Nm(n.vScale, n)),
      n.stack !== i.stack && ((a = !0), Do(n), (n.stack = i.stack)),
      this._resyncElements(t),
      (a || s !== n._stacked) && zm(this, n._parsed)
  }
  configure() {
    const t = this.chart.config,
      n = t.datasetScopeKeys(this._type),
      i = t.getOptionScopes(this.getDataset(), n, !0)
    ;(this.options = t.createResolver(i, this.getContext())),
      (this._parsing = this.options.parsing),
      (this._cachedDataOpts = {})
  }
  parse(t, n) {
    const { _cachedMeta: i, _data: a } = this,
      { iScale: s, _stacked: o } = i,
      r = s.axis
    let l = t === 0 && n === a.length ? !0 : i._sorted,
      c = t > 0 && i._parsed[t - 1],
      u,
      d,
      f
    if (this._parsing === !1) (i._parsed = a), (i._sorted = !0), (f = a)
    else {
      xt(a[t])
        ? (f = this.parseArrayData(i, a, t, n))
        : at(a[t])
        ? (f = this.parseObjectData(i, a, t, n))
        : (f = this.parsePrimitiveData(i, a, t, n))
      const h = () => d[r] === null || (c && d[r] < c[r])
      for (u = 0; u < n; ++u) (i._parsed[u + t] = d = f[u]), l && (h() && (l = !1), (c = d))
      i._sorted = l
    }
    o && zm(this, f)
  }
  parsePrimitiveData(t, n, i, a) {
    const { iScale: s, vScale: o } = t,
      r = s.axis,
      l = o.axis,
      c = s.getLabels(),
      u = s === o,
      d = new Array(a)
    let f, h, v
    for (f = 0, h = a; f < h; ++f) (v = f + i), (d[f] = { [r]: u || s.parse(c[v], v), [l]: o.parse(n[v], v) })
    return d
  }
  parseArrayData(t, n, i, a) {
    const { xScale: s, yScale: o } = t,
      r = new Array(a)
    let l, c, u, d
    for (l = 0, c = a; l < c; ++l)
      (u = l + i), (d = n[u]), (r[l] = { x: s.parse(d[0], u), y: o.parse(d[1], u) })
    return r
  }
  parseObjectData(t, n, i, a) {
    const { xScale: s, yScale: o } = t,
      { xAxisKey: r = 'x', yAxisKey: l = 'y' } = this._parsing,
      c = new Array(a)
    let u, d, f, h
    for (u = 0, d = a; u < d; ++u)
      (f = u + i), (h = n[f]), (c[u] = { x: s.parse(Ta(h, r), f), y: o.parse(Ta(h, l), f) })
    return c
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t]
  }
  getDataElement(t) {
    return this._cachedMeta.data[t]
  }
  applyStack(t, n, i) {
    const a = this.chart,
      s = this._cachedMeta,
      o = n[t.axis],
      r = { keys: D_(a, !0), values: n._stacks[t.axis]._visualValues }
    return Bm(r, o, s.index, { mode: i })
  }
  updateRangeFromParsed(t, n, i, a) {
    const s = i[n.axis]
    let o = s === null ? NaN : s
    const r = a && i._stacks[n.axis]
    a && r && ((a.values = r), (o = Bm(a, s, this._cachedMeta.index))),
      (t.min = Math.min(t.min, o)),
      (t.max = Math.max(t.max, o))
  }
  getMinMax(t, n) {
    const i = this._cachedMeta,
      a = i._parsed,
      s = i._sorted && t === i.iScale,
      o = a.length,
      r = this._getOtherScale(t),
      l = b5(n, i, this.chart),
      c = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY },
      { min: u, max: d } = g5(r)
    let f, h
    function v() {
      h = a[f]
      const g = h[r.axis]
      return !It(h[t.axis]) || u > g || d < g
    }
    for (f = 0; f < o && !(!v() && (this.updateRangeFromParsed(c, t, h, l), s)); ++f);
    if (s) {
      for (f = o - 1; f >= 0; --f)
        if (!v()) {
          this.updateRangeFromParsed(c, t, h, l)
          break
        }
    }
    return c
  }
  getAllParsedValues(t) {
    const n = this._cachedMeta._parsed,
      i = []
    let a, s, o
    for (a = 0, s = n.length; a < s; ++a) (o = n[a][t.axis]), It(o) && i.push(o)
    return i
  }
  getMaxOverflow() {
    return !1
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta,
      i = n.iScale,
      a = n.vScale,
      s = this.getParsed(t)
    return {
      label: i ? '' + i.getLabelForValue(s[i.axis]) : '',
      value: a ? '' + a.getLabelForValue(s[a.axis]) : ''
    }
  }
  _update(t) {
    const n = this._cachedMeta
    this.update(t || 'default'),
      (n._clip = f5(Ze(this.options.clip, d5(n.xScale, n.yScale, this.getMaxOverflow()))))
  }
  update(t) {}
  draw() {
    const t = this._ctx,
      n = this.chart,
      i = this._cachedMeta,
      a = i.data || [],
      s = n.chartArea,
      o = [],
      r = this._drawStart || 0,
      l = this._drawCount || a.length - r,
      c = this.options.drawActiveElementsOnTop
    let u
    for (i.dataset && i.dataset.draw(t, s, r, l), u = r; u < r + l; ++u) {
      const d = a[u]
      d.hidden || (d.active && c ? o.push(d) : d.draw(t, s))
    }
    for (u = 0; u < o.length; ++u) o[u].draw(t, s)
  }
  getStyle(t, n) {
    const i = n ? 'active' : 'default'
    return t === void 0 && this._cachedMeta.dataset
      ? this.resolveDatasetElementOptions(i)
      : this.resolveDataElementOptions(t || 0, i)
  }
  getContext(t, n, i) {
    const a = this.getDataset()
    let s
    if (t >= 0 && t < this._cachedMeta.data.length) {
      const o = this._cachedMeta.data[t]
      ;(s = o.$context || (o.$context = y5(this.getContext(), t, o))),
        (s.parsed = this.getParsed(t)),
        (s.raw = a.data[t]),
        (s.index = s.dataIndex = t)
    } else
      (s = this.$context || (this.$context = p5(this.chart.getContext(), this.index))),
        (s.dataset = a),
        (s.index = s.datasetIndex = this.index)
    return (s.active = !!n), (s.mode = i), s
  }
  resolveDatasetElementOptions(t) {
    return this._resolveElementOptions(this.datasetElementType.id, t)
  }
  resolveDataElementOptions(t, n) {
    return this._resolveElementOptions(this.dataElementType.id, n, t)
  }
  _resolveElementOptions(t, n = 'default', i) {
    const a = n === 'active',
      s = this._cachedDataOpts,
      o = t + '-' + n,
      r = s[o],
      l = this.enableOptionSharing && Ir(i)
    if (r) return Hm(r, l)
    const c = this.chart.config,
      u = c.datasetElementScopeKeys(this._type, t),
      d = a ? [`${t}Hover`, 'hover', t, ''] : [t, ''],
      f = c.getOptionScopes(this.getDataset(), u),
      h = Object.keys(Dt.elements[t]),
      v = () => this.getContext(i, a, n),
      g = c.resolveNamedOptions(f, h, v, d)
    return g.$shared && ((g.$shared = l), (s[o] = Object.freeze(Hm(g, l)))), g
  }
  _resolveAnimations(t, n, i) {
    const a = this.chart,
      s = this._cachedDataOpts,
      o = `animation-${n}`,
      r = s[o]
    if (r) return r
    let l
    if (a.options.animation !== !1) {
      const u = this.chart.config,
        d = u.datasetAnimationScopeKeys(this._type, n),
        f = u.getOptionScopes(this.getDataset(), d)
      l = u.createResolver(f, this.getContext(t, i, n))
    }
    const c = new I_(a, l && l.animations)
    return l && l._cacheable && (s[o] = Object.freeze(c)), c
  }
  getSharedOptions(t) {
    if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t))
  }
  includeOptions(t, n) {
    return !n || Nu(t) || this.chart._animationsDisabled
  }
  _getSharedOptions(t, n) {
    const i = this.resolveDataElementOptions(t, n),
      a = this._sharedOptions,
      s = this.getSharedOptions(i),
      o = this.includeOptions(n, s) || s !== a
    return this.updateSharedOptions(s, n, i), { sharedOptions: s, includeOptions: o }
  }
  updateElement(t, n, i, a) {
    Nu(a) ? Object.assign(t, i) : this._resolveAnimations(n, a).update(t, i)
  }
  updateSharedOptions(t, n, i) {
    t && !Nu(n) && this._resolveAnimations(void 0, n).update(t, i)
  }
  _setStyle(t, n, i, a) {
    t.active = a
    const s = this.getStyle(n, a)
    this._resolveAnimations(n, i, a).update(t, { options: (!a && this.getSharedOptions(s)) || s })
  }
  removeHoverStyle(t, n, i) {
    this._setStyle(t, i, 'active', !1)
  }
  setHoverStyle(t, n, i) {
    this._setStyle(t, i, 'active', !0)
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset
    t && this._setStyle(t, void 0, 'active', !1)
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset
    t && this._setStyle(t, void 0, 'active', !0)
  }
  _resyncElements(t) {
    const n = this._data,
      i = this._cachedMeta.data
    for (const [r, l, c] of this._syncList) this[r](l, c)
    this._syncList = []
    const a = i.length,
      s = n.length,
      o = Math.min(s, a)
    o && this.parse(0, o), s > a ? this._insertElements(a, s - a, t) : s < a && this._removeElements(s, a - s)
  }
  _insertElements(t, n, i = !0) {
    const a = this._cachedMeta,
      s = a.data,
      o = t + n
    let r
    const l = (c) => {
      for (c.length += n, r = c.length - 1; r >= o; r--) c[r] = c[r - n]
    }
    for (l(s), r = t; r < o; ++r) s[r] = new this.dataElementType()
    this._parsing && l(a._parsed), this.parse(t, n), i && this.updateElements(s, t, n, 'reset')
  }
  updateElements(t, n, i, a) {}
  _removeElements(t, n) {
    const i = this._cachedMeta
    if (this._parsing) {
      const a = i._parsed.splice(t, n)
      i._stacked && Do(i, a)
    }
    i.data.splice(t, n)
  }
  _sync(t) {
    if (this._parsing) this._syncList.push(t)
    else {
      const [n, i, a] = t
      this[n](i, a)
    }
    this.chart._dataChanges.push([this.index, ...t])
  }
  _onDataPush() {
    const t = arguments.length
    this._sync(['_insertElements', this.getDataset().data.length - t, t])
  }
  _onDataPop() {
    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1])
  }
  _onDataShift() {
    this._sync(['_removeElements', 0, 1])
  }
  _onDataSplice(t, n) {
    n && this._sync(['_removeElements', t, n])
    const i = arguments.length - 2
    i && this._sync(['_insertElements', t, i])
  }
  _onDataUnshift() {
    this._sync(['_insertElements', 0, arguments.length])
  }
}
ke(ui, 'defaults', {}), ke(ui, 'datasetElementType', null), ke(ui, 'dataElementType', null)
function _5(e, t) {
  if (!e._cache.$bar) {
    const n = e.getMatchingVisibleMetas(t)
    let i = []
    for (let a = 0, s = n.length; a < s; a++) i = i.concat(n[a].controller.getAllParsedValues(e))
    e._cache.$bar = v_(i.sort((a, s) => a - s))
  }
  return e._cache.$bar
}
function x5(e) {
  const t = e.iScale,
    n = _5(t, e.type)
  let i = t._length,
    a,
    s,
    o,
    r
  const l = () => {
    o === 32767 || o === -32768 || (Ir(r) && (i = Math.min(i, Math.abs(o - r) || i)), (r = o))
  }
  for (a = 0, s = n.length; a < s; ++a) (o = t.getPixelForValue(n[a])), l()
  for (r = void 0, a = 0, s = t.ticks.length; a < s; ++a) (o = t.getPixelForTick(a)), l()
  return i
}
function w5(e, t, n, i) {
  const a = n.barThickness
  let s, o
  return (
    lt(a) ? ((s = t.min * n.categoryPercentage), (o = n.barPercentage)) : ((s = a * i), (o = 1)),
    { chunk: s / i, ratio: o, start: t.pixels[e] - s / 2 }
  )
}
function S5(e, t, n, i) {
  const a = t.pixels,
    s = a[e]
  let o = e > 0 ? a[e - 1] : null,
    r = e < a.length - 1 ? a[e + 1] : null
  const l = n.categoryPercentage
  o === null && (o = s - (r === null ? t.end - t.start : r - s)), r === null && (r = s + s - o)
  const c = s - ((s - Math.min(o, r)) / 2) * l
  return { chunk: ((Math.abs(r - o) / 2) * l) / i, ratio: n.barPercentage, start: c }
}
function k5(e, t, n, i) {
  const a = n.parse(e[0], i),
    s = n.parse(e[1], i),
    o = Math.min(a, s),
    r = Math.max(a, s)
  let l = o,
    c = r
  Math.abs(o) > Math.abs(r) && ((l = r), (c = o)),
    (t[n.axis] = c),
    (t._custom = { barStart: l, barEnd: c, start: a, end: s, min: o, max: r })
}
function F_(e, t, n, i) {
  return xt(e) ? k5(e, t, n, i) : (t[n.axis] = n.parse(e, i)), t
}
function Wm(e, t, n, i) {
  const a = e.iScale,
    s = e.vScale,
    o = a.getLabels(),
    r = a === s,
    l = []
  let c, u, d, f
  for (c = n, u = n + i; c < u; ++c)
    (f = t[c]), (d = {}), (d[a.axis] = r || a.parse(o[c], c)), l.push(F_(f, d, s, c))
  return l
}
function $u(e) {
  return e && e.barStart !== void 0 && e.barEnd !== void 0
}
function C5(e, t, n) {
  return e !== 0 ? Ai(e) : (t.isHorizontal() ? 1 : -1) * (t.min >= n ? 1 : -1)
}
function M5(e) {
  let t, n, i, a, s
  return (
    e.horizontal
      ? ((t = e.base > e.x), (n = 'left'), (i = 'right'))
      : ((t = e.base < e.y), (n = 'bottom'), (i = 'top')),
    t ? ((a = 'end'), (s = 'start')) : ((a = 'start'), (s = 'end')),
    { start: n, end: i, reverse: t, top: a, bottom: s }
  )
}
function A5(e, t, n, i) {
  let a = t.borderSkipped
  const s = {}
  if (!a) {
    e.borderSkipped = s
    return
  }
  if (a === !0) {
    e.borderSkipped = { top: !0, right: !0, bottom: !0, left: !0 }
    return
  }
  const { start: o, end: r, reverse: l, top: c, bottom: u } = M5(e)
  a === 'middle' &&
    n &&
    ((e.enableBorderRadius = !0),
    (n._top || 0) === i ? (a = c) : (n._bottom || 0) === i ? (a = u) : ((s[jm(u, o, r, l)] = !0), (a = c))),
    (s[jm(a, o, r, l)] = !0),
    (e.borderSkipped = s)
}
function jm(e, t, n, i) {
  return i ? ((e = P5(e, t, n)), (e = Um(e, n, t))) : (e = Um(e, t, n)), e
}
function P5(e, t, n) {
  return e === t ? n : e === n ? t : e
}
function Um(e, t, n) {
  return e === 'start' ? t : e === 'end' ? n : e
}
function T5(e, { inflateAmount: t }, n) {
  e.inflateAmount = t === 'auto' ? (n === 1 ? 0.33 : 0) : t
}
class Hl extends ui {
  parsePrimitiveData(t, n, i, a) {
    return Wm(t, n, i, a)
  }
  parseArrayData(t, n, i, a) {
    return Wm(t, n, i, a)
  }
  parseObjectData(t, n, i, a) {
    const { iScale: s, vScale: o } = t,
      { xAxisKey: r = 'x', yAxisKey: l = 'y' } = this._parsing,
      c = s.axis === 'x' ? r : l,
      u = o.axis === 'x' ? r : l,
      d = []
    let f, h, v, g
    for (f = i, h = i + a; f < h; ++f)
      (g = n[f]), (v = {}), (v[s.axis] = s.parse(Ta(g, c), f)), d.push(F_(Ta(g, u), v, o, f))
    return d
  }
  updateRangeFromParsed(t, n, i, a) {
    super.updateRangeFromParsed(t, n, i, a)
    const s = i._custom
    s && n === this._cachedMeta.vScale && ((t.min = Math.min(t.min, s.min)), (t.max = Math.max(t.max, s.max)))
  }
  getMaxOverflow() {
    return 0
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta,
      { iScale: i, vScale: a } = n,
      s = this.getParsed(t),
      o = s._custom,
      r = $u(o) ? '[' + o.start + ', ' + o.end + ']' : '' + a.getLabelForValue(s[a.axis])
    return { label: '' + i.getLabelForValue(s[i.axis]), value: r }
  }
  initialize() {
    ;(this.enableOptionSharing = !0), super.initialize()
    const t = this._cachedMeta
    t.stack = this.getDataset().stack
  }
  update(t) {
    const n = this._cachedMeta
    this.updateElements(n.data, 0, n.data.length, t)
  }
  updateElements(t, n, i, a) {
    const s = a === 'reset',
      {
        index: o,
        _cachedMeta: { vScale: r }
      } = this,
      l = r.getBasePixel(),
      c = r.isHorizontal(),
      u = this._getRuler(),
      { sharedOptions: d, includeOptions: f } = this._getSharedOptions(n, a)
    for (let h = n; h < n + i; h++) {
      const v = this.getParsed(h),
        g = s || lt(v[r.axis]) ? { base: l, head: l } : this._calculateBarValuePixels(h),
        p = this._calculateBarIndexPixels(h, u),
        y = (v._stacks || {})[r.axis],
        b = {
          horizontal: c,
          base: g.base,
          enableBorderRadius: !y || $u(v._custom) || o === y._top || o === y._bottom,
          x: c ? g.head : p.center,
          y: c ? p.center : g.head,
          height: c ? p.size : Math.abs(g.size),
          width: c ? Math.abs(g.size) : p.size
        }
      f && (b.options = d || this.resolveDataElementOptions(h, t[h].active ? 'active' : a))
      const x = b.options || t[h].options
      A5(b, x, y, o), T5(b, x, u.ratio), this.updateElement(t[h], h, b, a)
    }
  }
  _getStacks(t, n) {
    const { iScale: i } = this._cachedMeta,
      a = i.getMatchingVisibleMetas(this._type).filter((l) => l.controller.options.grouped),
      s = i.options.stacked,
      o = [],
      r = (l) => {
        const c = l.controller.getParsed(n),
          u = c && c[l.vScale.axis]
        if (lt(u) || isNaN(u)) return !0
      }
    for (const l of a)
      if (
        !(n !== void 0 && r(l)) &&
        ((s === !1 || o.indexOf(l.stack) === -1 || (s === void 0 && l.stack === void 0)) && o.push(l.stack),
        l.index === t)
      )
        break
    return o.length || o.push(void 0), o
  }
  _getStackCount(t) {
    return this._getStacks(void 0, t).length
  }
  _getStackIndex(t, n, i) {
    const a = this._getStacks(t, i),
      s = n !== void 0 ? a.indexOf(n) : -1
    return s === -1 ? a.length - 1 : s
  }
  _getRuler() {
    const t = this.options,
      n = this._cachedMeta,
      i = n.iScale,
      a = []
    let s, o
    for (s = 0, o = n.data.length; s < o; ++s) a.push(i.getPixelForValue(this.getParsed(s)[i.axis], s))
    const r = t.barThickness
    return {
      min: r || x5(n),
      pixels: a,
      start: i._startPixel,
      end: i._endPixel,
      stackCount: this._getStackCount(),
      scale: i,
      grouped: t.grouped,
      ratio: r ? 1 : t.categoryPercentage * t.barPercentage
    }
  }
  _calculateBarValuePixels(t) {
    const {
        _cachedMeta: { vScale: n, _stacked: i, index: a },
        options: { base: s, minBarLength: o }
      } = this,
      r = s || 0,
      l = this.getParsed(t),
      c = l._custom,
      u = $u(c)
    let d = l[n.axis],
      f = 0,
      h = i ? this.applyStack(n, l, i) : d,
      v,
      g
    h !== d && ((f = h - d), (h = d)),
      u &&
        ((d = c.barStart),
        (h = c.barEnd - c.barStart),
        d !== 0 && Ai(d) !== Ai(c.barEnd) && (f = 0),
        (f += d))
    const p = !lt(s) && !u ? s : f
    let y = n.getPixelForValue(p)
    if (
      (this.chart.getDataVisibility(t) ? (v = n.getPixelForValue(f + h)) : (v = y),
      (g = v - y),
      Math.abs(g) < o)
    ) {
      ;(g = C5(g, n, r) * o), d === r && (y -= g / 2)
      const b = n.getPixelForDecimal(0),
        x = n.getPixelForDecimal(1),
        w = Math.min(b, x),
        C = Math.max(b, x)
      ;(y = Math.max(Math.min(y, C), w)),
        (v = y + g),
        i && !u && (l._stacks[n.axis]._visualValues[a] = n.getValueForPixel(v) - n.getValueForPixel(y))
    }
    if (y === n.getPixelForValue(r)) {
      const b = (Ai(g) * n.getLineWidthForValue(r)) / 2
      ;(y += b), (g -= b)
    }
    return { size: g, base: y, head: v, center: v + g / 2 }
  }
  _calculateBarIndexPixels(t, n) {
    const i = n.scale,
      a = this.options,
      s = a.skipNull,
      o = Ze(a.maxBarThickness, 1 / 0)
    let r, l
    if (n.grouped) {
      const c = s ? this._getStackCount(t) : n.stackCount,
        u = a.barThickness === 'flex' ? S5(t, n, a, c) : w5(t, n, a, c),
        d = this._getStackIndex(this.index, this._cachedMeta.stack, s ? t : void 0)
      ;(r = u.start + u.chunk * d + u.chunk / 2), (l = Math.min(o, u.chunk * u.ratio))
    } else (r = i.getPixelForValue(this.getParsed(t)[i.axis], t)), (l = Math.min(o, n.min * n.ratio))
    return { base: r - l / 2, head: r + l / 2, center: r, size: l }
  }
  draw() {
    const t = this._cachedMeta,
      n = t.vScale,
      i = t.data,
      a = i.length
    let s = 0
    for (; s < a; ++s) this.getParsed(s)[n.axis] !== null && i[s].draw(this._ctx)
  }
}
ke(Hl, 'id', 'bar'),
  ke(Hl, 'defaults', {
    datasetElementType: !1,
    dataElementType: 'bar',
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: !0,
    animations: { numbers: { type: 'number', properties: ['x', 'y', 'base', 'width', 'height'] } }
  }),
  ke(Hl, 'overrides', {
    scales: {
      _index_: { type: 'category', offset: !0, grid: { offset: !0 } },
      _value_: { type: 'linear', beginAtZero: !0 }
    }
  })
class Wl extends ui {
  initialize() {
    ;(this.enableOptionSharing = !0), super.initialize()
  }
  parsePrimitiveData(t, n, i, a) {
    const s = super.parsePrimitiveData(t, n, i, a)
    for (let o = 0; o < s.length; o++) s[o]._custom = this.resolveDataElementOptions(o + i).radius
    return s
  }
  parseArrayData(t, n, i, a) {
    const s = super.parseArrayData(t, n, i, a)
    for (let o = 0; o < s.length; o++) {
      const r = n[i + o]
      s[o]._custom = Ze(r[2], this.resolveDataElementOptions(o + i).radius)
    }
    return s
  }
  parseObjectData(t, n, i, a) {
    const s = super.parseObjectData(t, n, i, a)
    for (let o = 0; o < s.length; o++) {
      const r = n[i + o]
      s[o]._custom = Ze(r && r.r && +r.r, this.resolveDataElementOptions(o + i).radius)
    }
    return s
  }
  getMaxOverflow() {
    const t = this._cachedMeta.data
    let n = 0
    for (let i = t.length - 1; i >= 0; --i) n = Math.max(n, t[i].size(this.resolveDataElementOptions(i)) / 2)
    return n > 0 && n
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta,
      i = this.chart.data.labels || [],
      { xScale: a, yScale: s } = n,
      o = this.getParsed(t),
      r = a.getLabelForValue(o.x),
      l = s.getLabelForValue(o.y),
      c = o._custom
    return { label: i[t] || '', value: '(' + r + ', ' + l + (c ? ', ' + c : '') + ')' }
  }
  update(t) {
    const n = this._cachedMeta.data
    this.updateElements(n, 0, n.length, t)
  }
  updateElements(t, n, i, a) {
    const s = a === 'reset',
      { iScale: o, vScale: r } = this._cachedMeta,
      { sharedOptions: l, includeOptions: c } = this._getSharedOptions(n, a),
      u = o.axis,
      d = r.axis
    for (let f = n; f < n + i; f++) {
      const h = t[f],
        v = !s && this.getParsed(f),
        g = {},
        p = (g[u] = s ? o.getPixelForDecimal(0.5) : o.getPixelForValue(v[u])),
        y = (g[d] = s ? r.getBasePixel() : r.getPixelForValue(v[d]))
      ;(g.skip = isNaN(p) || isNaN(y)),
        c &&
          ((g.options = l || this.resolveDataElementOptions(f, h.active ? 'active' : a)),
          s && (g.options.radius = 0)),
        this.updateElement(h, f, g, a)
    }
  }
  resolveDataElementOptions(t, n) {
    const i = this.getParsed(t)
    let a = super.resolveDataElementOptions(t, n)
    a.$shared && (a = Object.assign({}, a, { $shared: !1 }))
    const s = a.radius
    return n !== 'active' && (a.radius = 0), (a.radius += Ze(i && i._custom, s)), a
  }
}
ke(Wl, 'id', 'bubble'),
  ke(Wl, 'defaults', {
    datasetElementType: !1,
    dataElementType: 'point',
    animations: { numbers: { type: 'number', properties: ['x', 'y', 'borderWidth', 'radius'] } }
  }),
  ke(Wl, 'overrides', { scales: { x: { type: 'linear' }, y: { type: 'linear' } } })
function V5(e, t, n) {
  let i = 1,
    a = 1,
    s = 0,
    o = 0
  if (t < wt) {
    const r = e,
      l = r + t,
      c = Math.cos(r),
      u = Math.sin(r),
      d = Math.cos(l),
      f = Math.sin(l),
      h = (x, w, C) => (Dr(x, r, l, !0) ? 1 : Math.max(w, w * n, C, C * n)),
      v = (x, w, C) => (Dr(x, r, l, !0) ? -1 : Math.min(w, w * n, C, C * n)),
      g = h(0, c, d),
      p = h(Bt, u, f),
      y = v(St, c, d),
      b = v(St + Bt, u, f)
    ;(i = (g - y) / 2), (a = (p - b) / 2), (s = -(g + y) / 2), (o = -(p + b) / 2)
  }
  return { ratioX: i, ratioY: a, offsetX: s, offsetY: o }
}
class as extends ui {
  constructor(t, n) {
    super(t, n),
      (this.enableOptionSharing = !0),
      (this.innerRadius = void 0),
      (this.outerRadius = void 0),
      (this.offsetX = void 0),
      (this.offsetY = void 0)
  }
  linkScales() {}
  parse(t, n) {
    const i = this.getDataset().data,
      a = this._cachedMeta
    if (this._parsing === !1) a._parsed = i
    else {
      let s = (l) => +i[l]
      if (at(i[t])) {
        const { key: l = 'value' } = this._parsing
        s = (c) => +Ta(i[c], l)
      }
      let o, r
      for (o = t, r = t + n; o < r; ++o) a._parsed[o] = s(o)
    }
  }
  _getRotation() {
    return oi(this.options.rotation - 90)
  }
  _getCircumference() {
    return oi(this.options.circumference)
  }
  _getRotationExtents() {
    let t = wt,
      n = -wt
    for (let i = 0; i < this.chart.data.datasets.length; ++i)
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const a = this.chart.getDatasetMeta(i).controller,
          s = a._getRotation(),
          o = a._getCircumference()
        ;(t = Math.min(t, s)), (n = Math.max(n, s + o))
      }
    return { rotation: t, circumference: n - t }
  }
  update(t) {
    const n = this.chart,
      { chartArea: i } = n,
      a = this._cachedMeta,
      s = a.data,
      o = this.getMaxBorderWidth() + this.getMaxOffset(s) + this.options.spacing,
      r = Math.max((Math.min(i.width, i.height) - o) / 2, 0),
      l = Math.min(jD(this.options.cutout, r), 1),
      c = this._getRingWeight(this.index),
      { circumference: u, rotation: d } = this._getRotationExtents(),
      { ratioX: f, ratioY: h, offsetX: v, offsetY: g } = V5(d, u, l),
      p = (i.width - o) / f,
      y = (i.height - o) / h,
      b = Math.max(Math.min(p, y) / 2, 0),
      x = c_(this.options.radius, b),
      w = Math.max(x * l, 0),
      C = (x - w) / this._getVisibleDatasetWeightTotal()
    ;(this.offsetX = v * x),
      (this.offsetY = g * x),
      (a.total = this.calculateTotal()),
      (this.outerRadius = x - C * this._getRingWeightOffset(this.index)),
      (this.innerRadius = Math.max(this.outerRadius - C * c, 0)),
      this.updateElements(s, 0, s.length, t)
  }
  _circumference(t, n) {
    const i = this.options,
      a = this._cachedMeta,
      s = this._getCircumference()
    return (n && i.animation.animateRotate) ||
      !this.chart.getDataVisibility(t) ||
      a._parsed[t] === null ||
      a.data[t].hidden
      ? 0
      : this.calculateCircumference((a._parsed[t] * s) / wt)
  }
  updateElements(t, n, i, a) {
    const s = a === 'reset',
      o = this.chart,
      r = o.chartArea,
      c = o.options.animation,
      u = (r.left + r.right) / 2,
      d = (r.top + r.bottom) / 2,
      f = s && c.animateScale,
      h = f ? 0 : this.innerRadius,
      v = f ? 0 : this.outerRadius,
      { sharedOptions: g, includeOptions: p } = this._getSharedOptions(n, a)
    let y = this._getRotation(),
      b
    for (b = 0; b < n; ++b) y += this._circumference(b, s)
    for (b = n; b < n + i; ++b) {
      const x = this._circumference(b, s),
        w = t[b],
        C = {
          x: u + this.offsetX,
          y: d + this.offsetY,
          startAngle: y,
          endAngle: y + x,
          circumference: x,
          outerRadius: v,
          innerRadius: h
        }
      p && (C.options = g || this.resolveDataElementOptions(b, w.active ? 'active' : a)),
        (y += x),
        this.updateElement(w, b, C, a)
    }
  }
  calculateTotal() {
    const t = this._cachedMeta,
      n = t.data
    let i = 0,
      a
    for (a = 0; a < n.length; a++) {
      const s = t._parsed[a]
      s !== null && !isNaN(s) && this.chart.getDataVisibility(a) && !n[a].hidden && (i += Math.abs(s))
    }
    return i
  }
  calculateCircumference(t) {
    const n = this._cachedMeta.total
    return n > 0 && !isNaN(t) ? wt * (Math.abs(t) / n) : 0
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta,
      i = this.chart,
      a = i.data.labels || [],
      s = Jr(n._parsed[t], i.options.locale)
    return { label: a[t] || '', value: s }
  }
  getMaxBorderWidth(t) {
    let n = 0
    const i = this.chart
    let a, s, o, r, l
    if (!t) {
      for (a = 0, s = i.data.datasets.length; a < s; ++a)
        if (i.isDatasetVisible(a)) {
          ;(o = i.getDatasetMeta(a)), (t = o.data), (r = o.controller)
          break
        }
    }
    if (!t) return 0
    for (a = 0, s = t.length; a < s; ++a)
      (l = r.resolveDataElementOptions(a)),
        l.borderAlign !== 'inner' && (n = Math.max(n, l.borderWidth || 0, l.hoverBorderWidth || 0))
    return n
  }
  getMaxOffset(t) {
    let n = 0
    for (let i = 0, a = t.length; i < a; ++i) {
      const s = this.resolveDataElementOptions(i)
      n = Math.max(n, s.offset || 0, s.hoverOffset || 0)
    }
    return n
  }
  _getRingWeightOffset(t) {
    let n = 0
    for (let i = 0; i < t; ++i) this.chart.isDatasetVisible(i) && (n += this._getRingWeight(i))
    return n
  }
  _getRingWeight(t) {
    return Math.max(Ze(this.chart.data.datasets[t].weight, 1), 0)
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1
  }
}
ke(as, 'id', 'doughnut'),
  ke(as, 'defaults', {
    datasetElementType: !1,
    dataElementType: 'arc',
    animation: { animateRotate: !0, animateScale: !1 },
    animations: {
      numbers: {
        type: 'number',
        properties: [
          'circumference',
          'endAngle',
          'innerRadius',
          'outerRadius',
          'startAngle',
          'x',
          'y',
          'offset',
          'borderWidth',
          'spacing'
        ]
      }
    },
    cutout: '50%',
    rotation: 0,
    circumference: 360,
    radius: '100%',
    spacing: 0,
    indexAxis: 'r'
  }),
  ke(as, 'descriptors', {
    _scriptable: (t) => t !== 'spacing',
    _indexable: (t) => t !== 'spacing' && !t.startsWith('borderDash') && !t.startsWith('hoverBorderDash')
  }),
  ke(as, 'overrides', {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(t) {
            const n = t.data
            if (n.labels.length && n.datasets.length) {
              const {
                labels: { pointStyle: i, color: a }
              } = t.legend.options
              return n.labels.map((s, o) => {
                const l = t.getDatasetMeta(0).controller.getStyle(o)
                return {
                  text: s,
                  fillStyle: l.backgroundColor,
                  strokeStyle: l.borderColor,
                  fontColor: a,
                  lineWidth: l.borderWidth,
                  pointStyle: i,
                  hidden: !t.getDataVisibility(o),
                  index: o
                }
              })
            }
            return []
          }
        },
        onClick(t, n, i) {
          i.chart.toggleDataVisibility(n.index), i.chart.update()
        }
      }
    }
  })
class jl extends ui {
  initialize() {
    ;(this.enableOptionSharing = !0), (this.supportsDecimation = !0), super.initialize()
  }
  update(t) {
    const n = this._cachedMeta,
      { dataset: i, data: a = [], _dataset: s } = n,
      o = this.chart._animationsDisabled
    let { start: r, count: l } = p_(n, a, o)
    ;(this._drawStart = r),
      (this._drawCount = l),
      y_(n) && ((r = 0), (l = a.length)),
      (i._chart = this.chart),
      (i._datasetIndex = this.index),
      (i._decimated = !!s._decimated),
      (i.points = a)
    const c = this.resolveDatasetElementOptions(t)
    this.options.showLine || (c.borderWidth = 0),
      (c.segment = this.options.segment),
      this.updateElement(i, void 0, { animated: !o, options: c }, t),
      this.updateElements(a, r, l, t)
  }
  updateElements(t, n, i, a) {
    const s = a === 'reset',
      { iScale: o, vScale: r, _stacked: l, _dataset: c } = this._cachedMeta,
      { sharedOptions: u, includeOptions: d } = this._getSharedOptions(n, a),
      f = o.axis,
      h = r.axis,
      { spanGaps: v, segment: g } = this.options,
      p = io(v) ? v : Number.POSITIVE_INFINITY,
      y = this.chart._animationsDisabled || s || a === 'none',
      b = n + i,
      x = t.length
    let w = n > 0 && this.getParsed(n - 1)
    for (let C = 0; C < x; ++C) {
      const P = t[C],
        k = y ? P : {}
      if (C < n || C >= b) {
        k.skip = !0
        continue
      }
      const S = this.getParsed(C),
        _ = lt(S[h]),
        T = (k[f] = o.getPixelForValue(S[f], C)),
        B = (k[h] = s || _ ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, S, l) : S[h], C))
      ;(k.skip = isNaN(T) || isNaN(B) || _),
        (k.stop = C > 0 && Math.abs(S[f] - w[f]) > p),
        g && ((k.parsed = S), (k.raw = c.data[C])),
        d && (k.options = u || this.resolveDataElementOptions(C, P.active ? 'active' : a)),
        y || this.updateElement(P, C, k, a),
        (w = S)
    }
  }
  getMaxOverflow() {
    const t = this._cachedMeta,
      n = t.dataset,
      i = (n.options && n.options.borderWidth) || 0,
      a = t.data || []
    if (!a.length) return i
    const s = a[0].size(this.resolveDataElementOptions(0)),
      o = a[a.length - 1].size(this.resolveDataElementOptions(a.length - 1))
    return Math.max(i, s, o) / 2
  }
  draw() {
    const t = this._cachedMeta
    t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw()
  }
}
ke(jl, 'id', 'line'),
  ke(jl, 'defaults', { datasetElementType: 'line', dataElementType: 'point', showLine: !0, spanGaps: !1 }),
  ke(jl, 'overrides', { scales: { _index_: { type: 'category' }, _value_: { type: 'linear' } } })
class dr extends ui {
  constructor(t, n) {
    super(t, n), (this.innerRadius = void 0), (this.outerRadius = void 0)
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta,
      i = this.chart,
      a = i.data.labels || [],
      s = Jr(n._parsed[t].r, i.options.locale)
    return { label: a[t] || '', value: s }
  }
  parseObjectData(t, n, i, a) {
    return M_.bind(this)(t, n, i, a)
  }
  update(t) {
    const n = this._cachedMeta.data
    this._updateRadius(), this.updateElements(n, 0, n.length, t)
  }
  getMinMax() {
    const t = this._cachedMeta,
      n = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }
    return (
      t.data.forEach((i, a) => {
        const s = this.getParsed(a).r
        !isNaN(s) && this.chart.getDataVisibility(a) && (s < n.min && (n.min = s), s > n.max && (n.max = s))
      }),
      n
    )
  }
  _updateRadius() {
    const t = this.chart,
      n = t.chartArea,
      i = t.options,
      a = Math.min(n.right - n.left, n.bottom - n.top),
      s = Math.max(a / 2, 0),
      o = Math.max(i.cutoutPercentage ? (s / 100) * i.cutoutPercentage : 1, 0),
      r = (s - o) / t.getVisibleDatasetCount()
    ;(this.outerRadius = s - r * this.index), (this.innerRadius = this.outerRadius - r)
  }
  updateElements(t, n, i, a) {
    const s = a === 'reset',
      o = this.chart,
      l = o.options.animation,
      c = this._cachedMeta.rScale,
      u = c.xCenter,
      d = c.yCenter,
      f = c.getIndexAngle(0) - 0.5 * St
    let h = f,
      v
    const g = 360 / this.countVisibleElements()
    for (v = 0; v < n; ++v) h += this._computeAngle(v, a, g)
    for (v = n; v < n + i; v++) {
      const p = t[v]
      let y = h,
        b = h + this._computeAngle(v, a, g),
        x = o.getDataVisibility(v) ? c.getDistanceFromCenterForValue(this.getParsed(v).r) : 0
      ;(h = b), s && (l.animateScale && (x = 0), l.animateRotate && (y = b = f))
      const w = {
        x: u,
        y: d,
        innerRadius: 0,
        outerRadius: x,
        startAngle: y,
        endAngle: b,
        options: this.resolveDataElementOptions(v, p.active ? 'active' : a)
      }
      this.updateElement(p, v, w, a)
    }
  }
  countVisibleElements() {
    const t = this._cachedMeta
    let n = 0
    return (
      t.data.forEach((i, a) => {
        !isNaN(this.getParsed(a).r) && this.chart.getDataVisibility(a) && n++
      }),
      n
    )
  }
  _computeAngle(t, n, i) {
    return this.chart.getDataVisibility(t) ? oi(this.resolveDataElementOptions(t, n).angle || i) : 0
  }
}
ke(dr, 'id', 'polarArea'),
  ke(dr, 'defaults', {
    dataElementType: 'arc',
    animation: { animateRotate: !0, animateScale: !0 },
    animations: {
      numbers: {
        type: 'number',
        properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']
      }
    },
    indexAxis: 'r',
    startAngle: 0
  }),
  ke(dr, 'overrides', {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(t) {
            const n = t.data
            if (n.labels.length && n.datasets.length) {
              const {
                labels: { pointStyle: i, color: a }
              } = t.legend.options
              return n.labels.map((s, o) => {
                const l = t.getDatasetMeta(0).controller.getStyle(o)
                return {
                  text: s,
                  fillStyle: l.backgroundColor,
                  strokeStyle: l.borderColor,
                  fontColor: a,
                  lineWidth: l.borderWidth,
                  pointStyle: i,
                  hidden: !t.getDataVisibility(o),
                  index: o
                }
              })
            }
            return []
          }
        },
        onClick(t, n, i) {
          i.chart.toggleDataVisibility(n.index), i.chart.update()
        }
      }
    },
    scales: {
      r: {
        type: 'radialLinear',
        angleLines: { display: !1 },
        beginAtZero: !0,
        grid: { circular: !0 },
        pointLabels: { display: !1 },
        startAngle: 0
      }
    }
  })
class qd extends as {}
ke(qd, 'id', 'pie'), ke(qd, 'defaults', { cutout: 0, rotation: 0, circumference: 360, radius: '100%' })
class Ul extends ui {
  getLabelAndValue(t) {
    const n = this._cachedMeta.vScale,
      i = this.getParsed(t)
    return { label: n.getLabels()[t], value: '' + n.getLabelForValue(i[n.axis]) }
  }
  parseObjectData(t, n, i, a) {
    return M_.bind(this)(t, n, i, a)
  }
  update(t) {
    const n = this._cachedMeta,
      i = n.dataset,
      a = n.data || [],
      s = n.iScale.getLabels()
    if (((i.points = a), t !== 'resize')) {
      const o = this.resolveDatasetElementOptions(t)
      this.options.showLine || (o.borderWidth = 0)
      const r = { _loop: !0, _fullLoop: s.length === a.length, options: o }
      this.updateElement(i, void 0, r, t)
    }
    this.updateElements(a, 0, a.length, t)
  }
  updateElements(t, n, i, a) {
    const s = this._cachedMeta.rScale,
      o = a === 'reset'
    for (let r = n; r < n + i; r++) {
      const l = t[r],
        c = this.resolveDataElementOptions(r, l.active ? 'active' : a),
        u = s.getPointPositionForValue(r, this.getParsed(r).r),
        d = o ? s.xCenter : u.x,
        f = o ? s.yCenter : u.y,
        h = { x: d, y: f, angle: u.angle, skip: isNaN(d) || isNaN(f), options: c }
      this.updateElement(l, r, h, a)
    }
  }
}
ke(Ul, 'id', 'radar'),
  ke(Ul, 'defaults', {
    datasetElementType: 'line',
    dataElementType: 'point',
    indexAxis: 'r',
    showLine: !0,
    elements: { line: { fill: 'start' } }
  }),
  ke(Ul, 'overrides', { aspectRatio: 1, scales: { r: { type: 'radialLinear' } } })
class Yl extends ui {
  getLabelAndValue(t) {
    const n = this._cachedMeta,
      i = this.chart.data.labels || [],
      { xScale: a, yScale: s } = n,
      o = this.getParsed(t),
      r = a.getLabelForValue(o.x),
      l = s.getLabelForValue(o.y)
    return { label: i[t] || '', value: '(' + r + ', ' + l + ')' }
  }
  update(t) {
    const n = this._cachedMeta,
      { data: i = [] } = n,
      a = this.chart._animationsDisabled
    let { start: s, count: o } = p_(n, i, a)
    if (
      ((this._drawStart = s),
      (this._drawCount = o),
      y_(n) && ((s = 0), (o = i.length)),
      this.options.showLine)
    ) {
      this.datasetElementType || this.addElements()
      const { dataset: r, _dataset: l } = n
      ;(r._chart = this.chart),
        (r._datasetIndex = this.index),
        (r._decimated = !!l._decimated),
        (r.points = i)
      const c = this.resolveDatasetElementOptions(t)
      ;(c.segment = this.options.segment), this.updateElement(r, void 0, { animated: !a, options: c }, t)
    } else this.datasetElementType && (delete n.dataset, (this.datasetElementType = !1))
    this.updateElements(i, s, o, t)
  }
  addElements() {
    const { showLine: t } = this.options
    !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement('line')),
      super.addElements()
  }
  updateElements(t, n, i, a) {
    const s = a === 'reset',
      { iScale: o, vScale: r, _stacked: l, _dataset: c } = this._cachedMeta,
      u = this.resolveDataElementOptions(n, a),
      d = this.getSharedOptions(u),
      f = this.includeOptions(a, d),
      h = o.axis,
      v = r.axis,
      { spanGaps: g, segment: p } = this.options,
      y = io(g) ? g : Number.POSITIVE_INFINITY,
      b = this.chart._animationsDisabled || s || a === 'none'
    let x = n > 0 && this.getParsed(n - 1)
    for (let w = n; w < n + i; ++w) {
      const C = t[w],
        P = this.getParsed(w),
        k = b ? C : {},
        S = lt(P[v]),
        _ = (k[h] = o.getPixelForValue(P[h], w)),
        T = (k[v] = s || S ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, P, l) : P[v], w))
      ;(k.skip = isNaN(_) || isNaN(T) || S),
        (k.stop = w > 0 && Math.abs(P[h] - x[h]) > y),
        p && ((k.parsed = P), (k.raw = c.data[w])),
        f && (k.options = d || this.resolveDataElementOptions(w, C.active ? 'active' : a)),
        b || this.updateElement(C, w, k, a),
        (x = P)
    }
    this.updateSharedOptions(d, a, u)
  }
  getMaxOverflow() {
    const t = this._cachedMeta,
      n = t.data || []
    if (!this.options.showLine) {
      let r = 0
      for (let l = n.length - 1; l >= 0; --l)
        r = Math.max(r, n[l].size(this.resolveDataElementOptions(l)) / 2)
      return r > 0 && r
    }
    const i = t.dataset,
      a = (i.options && i.options.borderWidth) || 0
    if (!n.length) return a
    const s = n[0].size(this.resolveDataElementOptions(0)),
      o = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1))
    return Math.max(a, s, o) / 2
  }
}
ke(Yl, 'id', 'scatter'),
  ke(Yl, 'defaults', { datasetElementType: !1, dataElementType: 'point', showLine: !1, fill: !1 }),
  ke(Yl, 'overrides', {
    interaction: { mode: 'point' },
    scales: { x: { type: 'linear' }, y: { type: 'linear' } }
  })
var E5 = Object.freeze({
  __proto__: null,
  BarController: Hl,
  BubbleController: Wl,
  DoughnutController: as,
  LineController: jl,
  PieController: qd,
  PolarAreaController: dr,
  RadarController: Ul,
  ScatterController: Yl
})
function Ga() {
  throw new Error('This method is not implemented: Check that a complete date adapter is provided.')
}
class Nh {
  constructor(t) {
    ke(this, 'options')
    this.options = t || {}
  }
  static override(t) {
    Object.assign(Nh.prototype, t)
  }
  init() {}
  formats() {
    return Ga()
  }
  parse() {
    return Ga()
  }
  format() {
    return Ga()
  }
  add() {
    return Ga()
  }
  diff() {
    return Ga()
  }
  startOf() {
    return Ga()
  }
  endOf() {
    return Ga()
  }
}
var L5 = { _date: Nh }
function O5(e, t, n, i) {
  const { controller: a, data: s, _sorted: o } = e,
    r = a._cachedMeta.iScale
  if (r && t === r.axis && t !== 'r' && o && s.length) {
    const l = r._reversePixels ? nF : Yi
    if (i) {
      if (a._sharedOptions) {
        const c = s[0],
          u = typeof c.getRange == 'function' && c.getRange(t)
        if (u) {
          const d = l(s, t, n - u),
            f = l(s, t, n + u)
          return { lo: d.lo, hi: f.hi }
        }
      }
    } else return l(s, t, n)
  }
  return { lo: 0, hi: s.length - 1 }
}
function Qr(e, t, n, i, a) {
  const s = e.getSortedVisibleDatasetMetas(),
    o = n[t]
  for (let r = 0, l = s.length; r < l; ++r) {
    const { index: c, data: u } = s[r],
      { lo: d, hi: f } = O5(s[r], t, o, a)
    for (let h = d; h <= f; ++h) {
      const v = u[h]
      v.skip || i(v, c, h)
    }
  }
}
function I5(e) {
  const t = e.indexOf('x') !== -1,
    n = e.indexOf('y') !== -1
  return function (i, a) {
    const s = t ? Math.abs(i.x - a.x) : 0,
      o = n ? Math.abs(i.y - a.y) : 0
    return Math.sqrt(Math.pow(s, 2) + Math.pow(o, 2))
  }
}
function zu(e, t, n, i, a) {
  const s = []
  return (
    (!a && !e.isPointInArea(t)) ||
      Qr(
        e,
        n,
        t,
        function (r, l, c) {
          ;(!a && !Gi(r, e.chartArea, 0)) ||
            (r.inRange(t.x, t.y, i) && s.push({ element: r, datasetIndex: l, index: c }))
        },
        !0
      ),
    s
  )
}
function D5(e, t, n, i) {
  let a = []
  function s(o, r, l) {
    const { startAngle: c, endAngle: u } = o.getProps(['startAngle', 'endAngle'], i),
      { angle: d } = f_(o, { x: t.x, y: t.y })
    Dr(d, c, u) && a.push({ element: o, datasetIndex: r, index: l })
  }
  return Qr(e, n, t, s), a
}
function F5(e, t, n, i, a, s) {
  let o = []
  const r = I5(n)
  let l = Number.POSITIVE_INFINITY
  function c(u, d, f) {
    const h = u.inRange(t.x, t.y, a)
    if (i && !h) return
    const v = u.getCenterPoint(a)
    if (!(!!s || e.isPointInArea(v)) && !h) return
    const p = r(t, v)
    p < l
      ? ((o = [{ element: u, datasetIndex: d, index: f }]), (l = p))
      : p === l && o.push({ element: u, datasetIndex: d, index: f })
  }
  return Qr(e, n, t, c), o
}
function Hu(e, t, n, i, a, s) {
  return !s && !e.isPointInArea(t) ? [] : n === 'r' && !i ? D5(e, t, n, a) : F5(e, t, n, i, a, s)
}
function Ym(e, t, n, i, a) {
  const s = [],
    o = n === 'x' ? 'inXRange' : 'inYRange'
  let r = !1
  return (
    Qr(e, n, t, (l, c, u) => {
      l[o](t[n], a) && (s.push({ element: l, datasetIndex: c, index: u }), (r = r || l.inRange(t.x, t.y, a)))
    }),
    i && !r ? [] : s
  )
}
var R5 = {
  evaluateInteractionItems: Qr,
  modes: {
    index(e, t, n, i) {
      const a = Ka(t, e),
        s = n.axis || 'x',
        o = n.includeInvisible || !1,
        r = n.intersect ? zu(e, a, s, i, o) : Hu(e, a, s, !1, i, o),
        l = []
      return r.length
        ? (e.getSortedVisibleDatasetMetas().forEach((c) => {
            const u = r[0].index,
              d = c.data[u]
            d && !d.skip && l.push({ element: d, datasetIndex: c.index, index: u })
          }),
          l)
        : []
    },
    dataset(e, t, n, i) {
      const a = Ka(t, e),
        s = n.axis || 'xy',
        o = n.includeInvisible || !1
      let r = n.intersect ? zu(e, a, s, i, o) : Hu(e, a, s, !1, i, o)
      if (r.length > 0) {
        const l = r[0].datasetIndex,
          c = e.getDatasetMeta(l).data
        r = []
        for (let u = 0; u < c.length; ++u) r.push({ element: c[u], datasetIndex: l, index: u })
      }
      return r
    },
    point(e, t, n, i) {
      const a = Ka(t, e),
        s = n.axis || 'xy',
        o = n.includeInvisible || !1
      return zu(e, a, s, i, o)
    },
    nearest(e, t, n, i) {
      const a = Ka(t, e),
        s = n.axis || 'xy',
        o = n.includeInvisible || !1
      return Hu(e, a, s, n.intersect, i, o)
    },
    x(e, t, n, i) {
      const a = Ka(t, e)
      return Ym(e, a, 'x', n.intersect, i)
    },
    y(e, t, n, i) {
      const a = Ka(t, e)
      return Ym(e, a, 'y', n.intersect, i)
    }
  }
}
const R_ = ['left', 'top', 'right', 'bottom']
function Fo(e, t) {
  return e.filter((n) => n.pos === t)
}
function Gm(e, t) {
  return e.filter((n) => R_.indexOf(n.pos) === -1 && n.box.axis === t)
}
function Ro(e, t) {
  return e.sort((n, i) => {
    const a = t ? i : n,
      s = t ? n : i
    return a.weight === s.weight ? a.index - s.index : a.weight - s.weight
  })
}
function B5(e) {
  const t = []
  let n, i, a, s, o, r
  for (n = 0, i = (e || []).length; n < i; ++n)
    (a = e[n]),
      ({
        position: s,
        options: { stack: o, stackWeight: r = 1 }
      } = a),
      t.push({
        index: n,
        box: a,
        pos: s,
        horizontal: a.isHorizontal(),
        weight: a.weight,
        stack: o && s + o,
        stackWeight: r
      })
  return t
}
function N5(e) {
  const t = {}
  for (const n of e) {
    const { stack: i, pos: a, stackWeight: s } = n
    if (!i || !R_.includes(a)) continue
    const o = t[i] || (t[i] = { count: 0, placed: 0, weight: 0, size: 0 })
    o.count++, (o.weight += s)
  }
  return t
}
function $5(e, t) {
  const n = N5(e),
    { vBoxMaxWidth: i, hBoxMaxHeight: a } = t
  let s, o, r
  for (s = 0, o = e.length; s < o; ++s) {
    r = e[s]
    const { fullSize: l } = r.box,
      c = n[r.stack],
      u = c && r.stackWeight / c.weight
    r.horizontal
      ? ((r.width = u ? u * i : l && t.availableWidth), (r.height = a))
      : ((r.width = i), (r.height = u ? u * a : l && t.availableHeight))
  }
  return n
}
function z5(e) {
  const t = B5(e),
    n = Ro(
      t.filter((c) => c.box.fullSize),
      !0
    ),
    i = Ro(Fo(t, 'left'), !0),
    a = Ro(Fo(t, 'right')),
    s = Ro(Fo(t, 'top'), !0),
    o = Ro(Fo(t, 'bottom')),
    r = Gm(t, 'x'),
    l = Gm(t, 'y')
  return {
    fullSize: n,
    leftAndTop: i.concat(s),
    rightAndBottom: a.concat(l).concat(o).concat(r),
    chartArea: Fo(t, 'chartArea'),
    vertical: i.concat(a).concat(l),
    horizontal: s.concat(o).concat(r)
  }
}
function Xm(e, t, n, i) {
  return Math.max(e[n], t[n]) + Math.max(e[i], t[i])
}
function B_(e, t) {
  ;(e.top = Math.max(e.top, t.top)),
    (e.left = Math.max(e.left, t.left)),
    (e.bottom = Math.max(e.bottom, t.bottom)),
    (e.right = Math.max(e.right, t.right))
}
function H5(e, t, n, i) {
  const { pos: a, box: s } = n,
    o = e.maxPadding
  if (!at(a)) {
    n.size && (e[a] -= n.size)
    const d = i[n.stack] || { size: 0, count: 1 }
    ;(d.size = Math.max(d.size, n.horizontal ? s.height : s.width)),
      (n.size = d.size / d.count),
      (e[a] += n.size)
  }
  s.getPadding && B_(o, s.getPadding())
  const r = Math.max(0, t.outerWidth - Xm(o, e, 'left', 'right')),
    l = Math.max(0, t.outerHeight - Xm(o, e, 'top', 'bottom')),
    c = r !== e.w,
    u = l !== e.h
  return (e.w = r), (e.h = l), n.horizontal ? { same: c, other: u } : { same: u, other: c }
}
function W5(e) {
  const t = e.maxPadding
  function n(i) {
    const a = Math.max(t[i] - e[i], 0)
    return (e[i] += a), a
  }
  ;(e.y += n('top')), (e.x += n('left')), n('right'), n('bottom')
}
function j5(e, t) {
  const n = t.maxPadding
  function i(a) {
    const s = { left: 0, top: 0, right: 0, bottom: 0 }
    return (
      a.forEach((o) => {
        s[o] = Math.max(t[o], n[o])
      }),
      s
    )
  }
  return i(e ? ['left', 'right'] : ['top', 'bottom'])
}
function Go(e, t, n, i) {
  const a = []
  let s, o, r, l, c, u
  for (s = 0, o = e.length, c = 0; s < o; ++s) {
    ;(r = e[s]), (l = r.box), l.update(r.width || t.w, r.height || t.h, j5(r.horizontal, t))
    const { same: d, other: f } = H5(t, n, r, i)
    ;(c |= d && a.length), (u = u || f), l.fullSize || a.push(r)
  }
  return (c && Go(a, t, n, i)) || u
}
function Cl(e, t, n, i, a) {
  ;(e.top = n), (e.left = t), (e.right = t + i), (e.bottom = n + a), (e.width = i), (e.height = a)
}
function Km(e, t, n, i) {
  const a = n.padding
  let { x: s, y: o } = t
  for (const r of e) {
    const l = r.box,
      c = i[r.stack] || { count: 1, placed: 0, weight: 1 },
      u = r.stackWeight / c.weight || 1
    if (r.horizontal) {
      const d = t.w * u,
        f = c.size || l.height
      Ir(c.start) && (o = c.start),
        l.fullSize ? Cl(l, a.left, o, n.outerWidth - a.right - a.left, f) : Cl(l, t.left + c.placed, o, d, f),
        (c.start = o),
        (c.placed += d),
        (o = l.bottom)
    } else {
      const d = t.h * u,
        f = c.size || l.width
      Ir(c.start) && (s = c.start),
        l.fullSize ? Cl(l, s, a.top, f, n.outerHeight - a.bottom - a.top) : Cl(l, s, t.top + c.placed, f, d),
        (c.start = s),
        (c.placed += d),
        (s = l.right)
    }
  }
  ;(t.x = s), (t.y = o)
}
var un = {
  addBox(e, t) {
    e.boxes || (e.boxes = []),
      (t.fullSize = t.fullSize || !1),
      (t.position = t.position || 'top'),
      (t.weight = t.weight || 0),
      (t._layers =
        t._layers ||
        function () {
          return [
            {
              z: 0,
              draw(n) {
                t.draw(n)
              }
            }
          ]
        }),
      e.boxes.push(t)
  },
  removeBox(e, t) {
    const n = e.boxes ? e.boxes.indexOf(t) : -1
    n !== -1 && e.boxes.splice(n, 1)
  },
  configure(e, t, n) {
    ;(t.fullSize = n.fullSize), (t.position = n.position), (t.weight = n.weight)
  },
  update(e, t, n, i) {
    if (!e) return
    const a = fn(e.options.layout.padding),
      s = Math.max(t - a.width, 0),
      o = Math.max(n - a.height, 0),
      r = z5(e.boxes),
      l = r.vertical,
      c = r.horizontal
    ht(e.boxes, (g) => {
      typeof g.beforeLayout == 'function' && g.beforeLayout()
    })
    const u = l.reduce((g, p) => (p.box.options && p.box.options.display === !1 ? g : g + 1), 0) || 1,
      d = Object.freeze({
        outerWidth: t,
        outerHeight: n,
        padding: a,
        availableWidth: s,
        availableHeight: o,
        vBoxMaxWidth: s / 2 / u,
        hBoxMaxHeight: o / 2
      }),
      f = Object.assign({}, a)
    B_(f, fn(i))
    const h = Object.assign({ maxPadding: f, w: s, h: o, x: a.left, y: a.top }, a),
      v = $5(l.concat(c), d)
    Go(r.fullSize, h, d, v),
      Go(l, h, d, v),
      Go(c, h, d, v) && Go(l, h, d, v),
      W5(h),
      Km(r.leftAndTop, h, d, v),
      (h.x += h.w),
      (h.y += h.h),
      Km(r.rightAndBottom, h, d, v),
      (e.chartArea = {
        left: h.left,
        top: h.top,
        right: h.left + h.w,
        bottom: h.top + h.h,
        height: h.h,
        width: h.w
      }),
      ht(r.chartArea, (g) => {
        const p = g.box
        Object.assign(p, e.chartArea), p.update(h.w, h.h, { left: 0, top: 0, right: 0, bottom: 0 })
      })
  }
}
class N_ {
  acquireContext(t, n) {}
  releaseContext(t) {
    return !1
  }
  addEventListener(t, n, i) {}
  removeEventListener(t, n, i) {}
  getDevicePixelRatio() {
    return 1
  }
  getMaximumSize(t, n, i, a) {
    return (
      (n = Math.max(0, n || t.width)),
      (i = i || t.height),
      { width: n, height: Math.max(0, a ? Math.floor(n / a) : i) }
    )
  }
  isAttached(t) {
    return !0
  }
  updateConfig(t) {}
}
class U5 extends N_ {
  acquireContext(t) {
    return (t && t.getContext && t.getContext('2d')) || null
  }
  updateConfig(t) {
    t.options.animation = !1
  }
}
const Gl = '$chartjs',
  Y5 = {
    touchstart: 'mousedown',
    touchmove: 'mousemove',
    touchend: 'mouseup',
    pointerenter: 'mouseenter',
    pointerdown: 'mousedown',
    pointermove: 'mousemove',
    pointerup: 'mouseup',
    pointerleave: 'mouseout',
    pointerout: 'mouseout'
  },
  qm = (e) => e === null || e === ''
function G5(e, t) {
  const n = e.style,
    i = e.getAttribute('height'),
    a = e.getAttribute('width')
  if (
    ((e[Gl] = {
      initial: { height: i, width: a, style: { display: n.display, height: n.height, width: n.width } }
    }),
    (n.display = n.display || 'block'),
    (n.boxSizing = n.boxSizing || 'border-box'),
    qm(a))
  ) {
    const s = Lm(e, 'width')
    s !== void 0 && (e.width = s)
  }
  if (qm(i))
    if (e.style.height === '') e.height = e.width / (t || 2)
    else {
      const s = Lm(e, 'height')
      s !== void 0 && (e.height = s)
    }
  return e
}
const $_ = KF ? { passive: !0 } : !1
function X5(e, t, n) {
  e.addEventListener(t, n, $_)
}
function K5(e, t, n) {
  e.canvas.removeEventListener(t, n, $_)
}
function q5(e, t) {
  const n = Y5[e.type] || e.type,
    { x: i, y: a } = Ka(e, t)
  return { type: n, chart: t, native: e, x: i !== void 0 ? i : null, y: a !== void 0 ? a : null }
}
function xc(e, t) {
  for (const n of e) if (n === t || n.contains(t)) return !0
}
function Z5(e, t, n) {
  const i = e.canvas,
    a = new MutationObserver((s) => {
      let o = !1
      for (const r of s) (o = o || xc(r.addedNodes, i)), (o = o && !xc(r.removedNodes, i))
      o && n()
    })
  return a.observe(document, { childList: !0, subtree: !0 }), a
}
function J5(e, t, n) {
  const i = e.canvas,
    a = new MutationObserver((s) => {
      let o = !1
      for (const r of s) (o = o || xc(r.removedNodes, i)), (o = o && !xc(r.addedNodes, i))
      o && n()
    })
  return a.observe(document, { childList: !0, subtree: !0 }), a
}
const Rr = new Map()
let Zm = 0
function z_() {
  const e = window.devicePixelRatio
  e !== Zm &&
    ((Zm = e),
    Rr.forEach((t, n) => {
      n.currentDevicePixelRatio !== e && t()
    }))
}
function Q5(e, t) {
  Rr.size || window.addEventListener('resize', z_), Rr.set(e, t)
}
function eR(e) {
  Rr.delete(e), Rr.size || window.removeEventListener('resize', z_)
}
function tR(e, t, n) {
  const i = e.canvas,
    a = i && Bh(i)
  if (!a) return
  const s = m_((r, l) => {
      const c = a.clientWidth
      n(r, l), c < a.clientWidth && n()
    }, window),
    o = new ResizeObserver((r) => {
      const l = r[0],
        c = l.contentRect.width,
        u = l.contentRect.height
      ;(c === 0 && u === 0) || s(c, u)
    })
  return o.observe(a), Q5(e, s), o
}
function Wu(e, t, n) {
  n && n.disconnect(), t === 'resize' && eR(e)
}
function nR(e, t, n) {
  const i = e.canvas,
    a = m_((s) => {
      e.ctx !== null && n(q5(s, e))
    }, e)
  return X5(i, t, a), a
}
class iR extends N_ {
  acquireContext(t, n) {
    const i = t && t.getContext && t.getContext('2d')
    return i && i.canvas === t ? (G5(t, n), i) : null
  }
  releaseContext(t) {
    const n = t.canvas
    if (!n[Gl]) return !1
    const i = n[Gl].initial
    ;['height', 'width'].forEach((s) => {
      const o = i[s]
      lt(o) ? n.removeAttribute(s) : n.setAttribute(s, o)
    })
    const a = i.style || {}
    return (
      Object.keys(a).forEach((s) => {
        n.style[s] = a[s]
      }),
      (n.width = n.width),
      delete n[Gl],
      !0
    )
  }
  addEventListener(t, n, i) {
    this.removeEventListener(t, n)
    const a = t.$proxies || (t.$proxies = {}),
      o = { attach: Z5, detach: J5, resize: tR }[n] || nR
    a[n] = o(t, n, i)
  }
  removeEventListener(t, n) {
    const i = t.$proxies || (t.$proxies = {}),
      a = i[n]
    if (!a) return
    ;(({ attach: Wu, detach: Wu, resize: Wu })[n] || K5)(t, n, a), (i[n] = void 0)
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio
  }
  getMaximumSize(t, n, i, a) {
    return XF(t, n, i, a)
  }
  isAttached(t) {
    const n = Bh(t)
    return !!(n && n.isConnected)
  }
}
function aR(e) {
  return !P_() || (typeof OffscreenCanvas < 'u' && e instanceof OffscreenCanvas) ? U5 : iR
}
var Ol
let la =
  ((Ol = class {
    constructor() {
      ke(this, 'x')
      ke(this, 'y')
      ke(this, 'active', !1)
      ke(this, 'options')
      ke(this, '$animations')
    }
    tooltipPosition(t) {
      const { x: n, y: i } = this.getProps(['x', 'y'], t)
      return { x: n, y: i }
    }
    hasValue() {
      return io(this.x) && io(this.y)
    }
    getProps(t, n) {
      const i = this.$animations
      if (!n || !i) return this
      const a = {}
      return (
        t.forEach((s) => {
          a[s] = i[s] && i[s].active() ? i[s]._to : this[s]
        }),
        a
      )
    }
  }),
  ke(Ol, 'defaults', {}),
  ke(Ol, 'defaultRoutes'),
  Ol)
function sR(e, t) {
  const n = e.options.ticks,
    i = oR(e),
    a = Math.min(n.maxTicksLimit || i, i),
    s = n.major.enabled ? lR(t) : [],
    o = s.length,
    r = s[0],
    l = s[o - 1],
    c = []
  if (o > a) return cR(t, c, s, o / a), c
  const u = rR(s, t, a)
  if (o > 0) {
    let d, f
    const h = o > 1 ? Math.round((l - r) / (o - 1)) : null
    for (Ml(t, c, u, lt(h) ? 0 : r - h, r), d = 0, f = o - 1; d < f; d++) Ml(t, c, u, s[d], s[d + 1])
    return Ml(t, c, u, l, lt(h) ? t.length : l + h), c
  }
  return Ml(t, c, u), c
}
function oR(e) {
  const t = e.options.offset,
    n = e._tickSize(),
    i = e._length / n + (t ? 0 : 1),
    a = e._maxLength / n
  return Math.floor(Math.min(i, a))
}
function rR(e, t, n) {
  const i = uR(e),
    a = t.length / n
  if (!i) return Math.max(a, 1)
  const s = JD(i)
  for (let o = 0, r = s.length - 1; o < r; o++) {
    const l = s[o]
    if (l > a) return l
  }
  return Math.max(a, 1)
}
function lR(e) {
  const t = []
  let n, i
  for (n = 0, i = e.length; n < i; n++) e[n].major && t.push(n)
  return t
}
function cR(e, t, n, i) {
  let a = 0,
    s = n[0],
    o
  for (i = Math.ceil(i), o = 0; o < e.length; o++) o === s && (t.push(e[o]), a++, (s = n[a * i]))
}
function Ml(e, t, n, i, a) {
  const s = Ze(i, 0),
    o = Math.min(Ze(a, e.length), e.length)
  let r = 0,
    l,
    c,
    u
  for (n = Math.ceil(n), a && ((l = a - i), (n = l / Math.floor(l / n))), u = s; u < 0; )
    r++, (u = Math.round(s + r * n))
  for (c = Math.max(s, 0); c < o; c++) c === u && (t.push(e[c]), r++, (u = Math.round(s + r * n)))
}
function uR(e) {
  const t = e.length
  let n, i
  if (t < 2) return !1
  for (i = e[0], n = 1; n < t; ++n) if (e[n] - e[n - 1] !== i) return !1
  return i
}
const dR = (e) => (e === 'left' ? 'right' : e === 'right' ? 'left' : e),
  Jm = (e, t, n) => (t === 'top' || t === 'left' ? e[t] + n : e[t] - n),
  Qm = (e, t) => Math.min(t || e, e)
function ep(e, t) {
  const n = [],
    i = e.length / t,
    a = e.length
  let s = 0
  for (; s < a; s += i) n.push(e[Math.floor(s)])
  return n
}
function fR(e, t, n) {
  const i = e.ticks.length,
    a = Math.min(t, i - 1),
    s = e._startPixel,
    o = e._endPixel,
    r = 1e-6
  let l = e.getPixelForTick(a),
    c
  if (
    !(
      n &&
      (i === 1
        ? (c = Math.max(l - s, o - l))
        : t === 0
        ? (c = (e.getPixelForTick(1) - l) / 2)
        : (c = (l - e.getPixelForTick(a - 1)) / 2),
      (l += a < t ? c : -c),
      l < s - r || l > o + r)
    )
  )
    return l
}
function hR(e, t) {
  ht(e, (n) => {
    const i = n.gc,
      a = i.length / 2
    let s
    if (a > t) {
      for (s = 0; s < a; ++s) delete n.data[i[s]]
      i.splice(0, a)
    }
  })
}
function Bo(e) {
  return e.drawTicks ? e.tickLength : 0
}
function tp(e, t) {
  if (!e.display) return 0
  const n = jt(e.font, t),
    i = fn(e.padding)
  return (xt(e.text) ? e.text.length : 1) * n.lineHeight + i.height
}
function vR(e, t) {
  return Ba(e, { scale: t, type: 'scale' })
}
function gR(e, t, n) {
  return Ba(e, { tick: n, index: t, type: 'tick' })
}
function mR(e, t, n) {
  let i = Lh(e)
  return ((n && t !== 'right') || (!n && t === 'right')) && (i = dR(i)), i
}
function pR(e, t, n, i) {
  const { top: a, left: s, bottom: o, right: r, chart: l } = e,
    { chartArea: c, scales: u } = l
  let d = 0,
    f,
    h,
    v
  const g = o - a,
    p = r - s
  if (e.isHorizontal()) {
    if (((h = rn(i, s, r)), at(n))) {
      const y = Object.keys(n)[0],
        b = n[y]
      v = u[y].getPixelForValue(b) + g - t
    } else n === 'center' ? (v = (c.bottom + c.top) / 2 + g - t) : (v = Jm(e, n, t))
    f = r - s
  } else {
    if (at(n)) {
      const y = Object.keys(n)[0],
        b = n[y]
      h = u[y].getPixelForValue(b) - p + t
    } else n === 'center' ? (h = (c.left + c.right) / 2 - p + t) : (h = Jm(e, n, t))
    ;(v = rn(i, o, a)), (d = n === 'left' ? -Bt : Bt)
  }
  return { titleX: h, titleY: v, maxWidth: f, rotation: d }
}
class Ms extends la {
  constructor(t) {
    super(),
      (this.id = t.id),
      (this.type = t.type),
      (this.options = void 0),
      (this.ctx = t.ctx),
      (this.chart = t.chart),
      (this.top = void 0),
      (this.bottom = void 0),
      (this.left = void 0),
      (this.right = void 0),
      (this.width = void 0),
      (this.height = void 0),
      (this._margins = { left: 0, right: 0, top: 0, bottom: 0 }),
      (this.maxWidth = void 0),
      (this.maxHeight = void 0),
      (this.paddingTop = void 0),
      (this.paddingBottom = void 0),
      (this.paddingLeft = void 0),
      (this.paddingRight = void 0),
      (this.axis = void 0),
      (this.labelRotation = void 0),
      (this.min = void 0),
      (this.max = void 0),
      (this._range = void 0),
      (this.ticks = []),
      (this._gridLineItems = null),
      (this._labelItems = null),
      (this._labelSizes = null),
      (this._length = 0),
      (this._maxLength = 0),
      (this._longestTextCache = {}),
      (this._startPixel = void 0),
      (this._endPixel = void 0),
      (this._reversePixels = !1),
      (this._userMax = void 0),
      (this._userMin = void 0),
      (this._suggestedMax = void 0),
      (this._suggestedMin = void 0),
      (this._ticksLength = 0),
      (this._borderValue = 0),
      (this._cache = {}),
      (this._dataLimitsCached = !1),
      (this.$context = void 0)
  }
  init(t) {
    ;(this.options = t.setContext(this.getContext())),
      (this.axis = t.axis),
      (this._userMin = this.parse(t.min)),
      (this._userMax = this.parse(t.max)),
      (this._suggestedMin = this.parse(t.suggestedMin)),
      (this._suggestedMax = this.parse(t.suggestedMax))
  }
  parse(t, n) {
    return t
  }
  getUserBounds() {
    let { _userMin: t, _userMax: n, _suggestedMin: i, _suggestedMax: a } = this
    return (
      (t = Tn(t, Number.POSITIVE_INFINITY)),
      (n = Tn(n, Number.NEGATIVE_INFINITY)),
      (i = Tn(i, Number.POSITIVE_INFINITY)),
      (a = Tn(a, Number.NEGATIVE_INFINITY)),
      { min: Tn(t, i), max: Tn(n, a), minDefined: It(t), maxDefined: It(n) }
    )
  }
  getMinMax(t) {
    let { min: n, max: i, minDefined: a, maxDefined: s } = this.getUserBounds(),
      o
    if (a && s) return { min: n, max: i }
    const r = this.getMatchingVisibleMetas()
    for (let l = 0, c = r.length; l < c; ++l)
      (o = r[l].controller.getMinMax(this, t)), a || (n = Math.min(n, o.min)), s || (i = Math.max(i, o.max))
    return (n = s && n > i ? i : n), (i = a && n > i ? n : i), { min: Tn(n, Tn(i, n)), max: Tn(i, Tn(n, i)) }
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    }
  }
  getTicks() {
    return this.ticks
  }
  getLabels() {
    const t = this.chart.data
    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || []
  }
  getLabelItems(t = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(t))
  }
  beforeLayout() {
    ;(this._cache = {}), (this._dataLimitsCached = !1)
  }
  beforeUpdate() {
    pt(this.options.beforeUpdate, [this])
  }
  update(t, n, i) {
    const { beginAtZero: a, grace: s, ticks: o } = this.options,
      r = o.sampleSize
    this.beforeUpdate(),
      (this.maxWidth = t),
      (this.maxHeight = n),
      (this._margins = i = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, i)),
      (this.ticks = null),
      (this._labelSizes = null),
      (this._gridLineItems = null),
      (this._labelItems = null),
      this.beforeSetDimensions(),
      this.setDimensions(),
      this.afterSetDimensions(),
      (this._maxLength = this.isHorizontal()
        ? this.width + i.left + i.right
        : this.height + i.top + i.bottom),
      this._dataLimitsCached ||
        (this.beforeDataLimits(),
        this.determineDataLimits(),
        this.afterDataLimits(),
        (this._range = MF(this, s, a)),
        (this._dataLimitsCached = !0)),
      this.beforeBuildTicks(),
      (this.ticks = this.buildTicks() || []),
      this.afterBuildTicks()
    const l = r < this.ticks.length
    this._convertTicksToLabels(l ? ep(this.ticks, r) : this.ticks),
      this.configure(),
      this.beforeCalculateLabelRotation(),
      this.calculateLabelRotation(),
      this.afterCalculateLabelRotation(),
      o.display &&
        (o.autoSkip || o.source === 'auto') &&
        ((this.ticks = sR(this, this.ticks)), (this._labelSizes = null), this.afterAutoSkip()),
      l && this._convertTicksToLabels(this.ticks),
      this.beforeFit(),
      this.fit(),
      this.afterFit(),
      this.afterUpdate()
  }
  configure() {
    let t = this.options.reverse,
      n,
      i
    this.isHorizontal() ? ((n = this.left), (i = this.right)) : ((n = this.top), (i = this.bottom), (t = !t)),
      (this._startPixel = n),
      (this._endPixel = i),
      (this._reversePixels = t),
      (this._length = i - n),
      (this._alignToPixels = this.options.alignToPixels)
  }
  afterUpdate() {
    pt(this.options.afterUpdate, [this])
  }
  beforeSetDimensions() {
    pt(this.options.beforeSetDimensions, [this])
  }
  setDimensions() {
    this.isHorizontal()
      ? ((this.width = this.maxWidth), (this.left = 0), (this.right = this.width))
      : ((this.height = this.maxHeight), (this.top = 0), (this.bottom = this.height)),
      (this.paddingLeft = 0),
      (this.paddingTop = 0),
      (this.paddingRight = 0),
      (this.paddingBottom = 0)
  }
  afterSetDimensions() {
    pt(this.options.afterSetDimensions, [this])
  }
  _callHooks(t) {
    this.chart.notifyPlugins(t, this.getContext()), pt(this.options[t], [this])
  }
  beforeDataLimits() {
    this._callHooks('beforeDataLimits')
  }
  determineDataLimits() {}
  afterDataLimits() {
    this._callHooks('afterDataLimits')
  }
  beforeBuildTicks() {
    this._callHooks('beforeBuildTicks')
  }
  buildTicks() {
    return []
  }
  afterBuildTicks() {
    this._callHooks('afterBuildTicks')
  }
  beforeTickToLabelConversion() {
    pt(this.options.beforeTickToLabelConversion, [this])
  }
  generateTickLabels(t) {
    const n = this.options.ticks
    let i, a, s
    for (i = 0, a = t.length; i < a; i++) (s = t[i]), (s.label = pt(n.callback, [s.value, i, t], this))
  }
  afterTickToLabelConversion() {
    pt(this.options.afterTickToLabelConversion, [this])
  }
  beforeCalculateLabelRotation() {
    pt(this.options.beforeCalculateLabelRotation, [this])
  }
  calculateLabelRotation() {
    const t = this.options,
      n = t.ticks,
      i = Qm(this.ticks.length, t.ticks.maxTicksLimit),
      a = n.minRotation || 0,
      s = n.maxRotation
    let o = a,
      r,
      l,
      c
    if (!this._isVisible() || !n.display || a >= s || i <= 1 || !this.isHorizontal()) {
      this.labelRotation = a
      return
    }
    const u = this._getLabelSizes(),
      d = u.widest.width,
      f = u.highest.height,
      h = Zt(this.chart.width - d, 0, this.maxWidth)
    ;(r = t.offset ? this.maxWidth / i : h / (i - 1)),
      d + 6 > r &&
        ((r = h / (i - (t.offset ? 0.5 : 1))),
        (l = this.maxHeight - Bo(t.grid) - n.padding - tp(t.title, this.chart.options.font)),
        (c = Math.sqrt(d * d + f * f)),
        (o = Vh(
          Math.min(
            Math.asin(Zt((u.highest.height + 6) / r, -1, 1)),
            Math.asin(Zt(l / c, -1, 1)) - Math.asin(Zt(f / c, -1, 1))
          )
        )),
        (o = Math.max(a, Math.min(s, o)))),
      (this.labelRotation = o)
  }
  afterCalculateLabelRotation() {
    pt(this.options.afterCalculateLabelRotation, [this])
  }
  afterAutoSkip() {}
  beforeFit() {
    pt(this.options.beforeFit, [this])
  }
  fit() {
    const t = { width: 0, height: 0 },
      {
        chart: n,
        options: { ticks: i, title: a, grid: s }
      } = this,
      o = this._isVisible(),
      r = this.isHorizontal()
    if (o) {
      const l = tp(a, n.options.font)
      if (
        (r
          ? ((t.width = this.maxWidth), (t.height = Bo(s) + l))
          : ((t.height = this.maxHeight), (t.width = Bo(s) + l)),
        i.display && this.ticks.length)
      ) {
        const { first: c, last: u, widest: d, highest: f } = this._getLabelSizes(),
          h = i.padding * 2,
          v = oi(this.labelRotation),
          g = Math.cos(v),
          p = Math.sin(v)
        if (r) {
          const y = i.mirror ? 0 : p * d.width + g * f.height
          t.height = Math.min(this.maxHeight, t.height + y + h)
        } else {
          const y = i.mirror ? 0 : g * d.width + p * f.height
          t.width = Math.min(this.maxWidth, t.width + y + h)
        }
        this._calculatePadding(c, u, p, g)
      }
    }
    this._handleMargins(),
      r
        ? ((this.width = this._length = n.width - this._margins.left - this._margins.right),
          (this.height = t.height))
        : ((this.width = t.width),
          (this.height = this._length = n.height - this._margins.top - this._margins.bottom))
  }
  _calculatePadding(t, n, i, a) {
    const {
        ticks: { align: s, padding: o },
        position: r
      } = this.options,
      l = this.labelRotation !== 0,
      c = r !== 'top' && this.axis === 'x'
    if (this.isHorizontal()) {
      const u = this.getPixelForTick(0) - this.left,
        d = this.right - this.getPixelForTick(this.ticks.length - 1)
      let f = 0,
        h = 0
      l
        ? c
          ? ((f = a * t.width), (h = i * n.height))
          : ((f = i * t.height), (h = a * n.width))
        : s === 'start'
        ? (h = n.width)
        : s === 'end'
        ? (f = t.width)
        : s !== 'inner' && ((f = t.width / 2), (h = n.width / 2)),
        (this.paddingLeft = Math.max(((f - u + o) * this.width) / (this.width - u), 0)),
        (this.paddingRight = Math.max(((h - d + o) * this.width) / (this.width - d), 0))
    } else {
      let u = n.height / 2,
        d = t.height / 2
      s === 'start' ? ((u = 0), (d = t.height)) : s === 'end' && ((u = n.height), (d = 0)),
        (this.paddingTop = u + o),
        (this.paddingBottom = d + o)
    }
  }
  _handleMargins() {
    this._margins &&
      ((this._margins.left = Math.max(this.paddingLeft, this._margins.left)),
      (this._margins.top = Math.max(this.paddingTop, this._margins.top)),
      (this._margins.right = Math.max(this.paddingRight, this._margins.right)),
      (this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)))
  }
  afterFit() {
    pt(this.options.afterFit, [this])
  }
  isHorizontal() {
    const { axis: t, position: n } = this.options
    return n === 'top' || n === 'bottom' || t === 'x'
  }
  isFullSize() {
    return this.options.fullSize
  }
  _convertTicksToLabels(t) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(t)
    let n, i
    for (n = 0, i = t.length; n < i; n++) lt(t[n].label) && (t.splice(n, 1), i--, n--)
    this.afterTickToLabelConversion()
  }
  _getLabelSizes() {
    let t = this._labelSizes
    if (!t) {
      const n = this.options.ticks.sampleSize
      let i = this.ticks
      n < i.length && (i = ep(i, n)),
        (this._labelSizes = t = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit))
    }
    return t
  }
  _computeLabelSizes(t, n, i) {
    const { ctx: a, _longestTextCache: s } = this,
      o = [],
      r = [],
      l = Math.floor(n / Qm(n, i))
    let c = 0,
      u = 0,
      d,
      f,
      h,
      v,
      g,
      p,
      y,
      b,
      x,
      w,
      C
    for (d = 0; d < n; d += l) {
      if (
        ((v = t[d].label),
        (g = this._resolveTickFontOptions(d)),
        (a.font = p = g.string),
        (y = s[p] = s[p] || { data: {}, gc: [] }),
        (b = g.lineHeight),
        (x = w = 0),
        !lt(v) && !xt(v))
      )
        (x = bc(a, y.data, y.gc, x, v)), (w = b)
      else if (xt(v))
        for (f = 0, h = v.length; f < h; ++f)
          (C = v[f]), !lt(C) && !xt(C) && ((x = bc(a, y.data, y.gc, x, C)), (w += b))
      o.push(x), r.push(w), (c = Math.max(x, c)), (u = Math.max(w, u))
    }
    hR(s, n)
    const P = o.indexOf(c),
      k = r.indexOf(u),
      S = (_) => ({ width: o[_] || 0, height: r[_] || 0 })
    return { first: S(0), last: S(n - 1), widest: S(P), highest: S(k), widths: o, heights: r }
  }
  getLabelForValue(t) {
    return t
  }
  getPixelForValue(t, n) {
    return NaN
  }
  getValueForPixel(t) {}
  getPixelForTick(t) {
    const n = this.ticks
    return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value)
  }
  getPixelForDecimal(t) {
    this._reversePixels && (t = 1 - t)
    const n = this._startPixel + t * this._length
    return tF(this._alignToPixels ? Ya(this.chart, n, 0) : n)
  }
  getDecimalForPixel(t) {
    const n = (t - this._startPixel) / this._length
    return this._reversePixels ? 1 - n : n
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue())
  }
  getBaseValue() {
    const { min: t, max: n } = this
    return t < 0 && n < 0 ? n : t > 0 && n > 0 ? t : 0
  }
  getContext(t) {
    const n = this.ticks || []
    if (t >= 0 && t < n.length) {
      const i = n[t]
      return i.$context || (i.$context = gR(this.getContext(), t, i))
    }
    return this.$context || (this.$context = vR(this.chart.getContext(), this))
  }
  _tickSize() {
    const t = this.options.ticks,
      n = oi(this.labelRotation),
      i = Math.abs(Math.cos(n)),
      a = Math.abs(Math.sin(n)),
      s = this._getLabelSizes(),
      o = t.autoSkipPadding || 0,
      r = s ? s.widest.width + o : 0,
      l = s ? s.highest.height + o : 0
    return this.isHorizontal() ? (l * i > r * a ? r / i : l / a) : l * a < r * i ? l / i : r / a
  }
  _isVisible() {
    const t = this.options.display
    return t !== 'auto' ? !!t : this.getMatchingVisibleMetas().length > 0
  }
  _computeGridLineItems(t) {
    const n = this.axis,
      i = this.chart,
      a = this.options,
      { grid: s, position: o, border: r } = a,
      l = s.offset,
      c = this.isHorizontal(),
      d = this.ticks.length + (l ? 1 : 0),
      f = Bo(s),
      h = [],
      v = r.setContext(this.getContext()),
      g = v.display ? v.width : 0,
      p = g / 2,
      y = function (j) {
        return Ya(i, j, g)
      }
    let b, x, w, C, P, k, S, _, T, B, O, N
    if (o === 'top')
      (b = y(this.bottom)), (k = this.bottom - f), (_ = b - p), (B = y(t.top) + p), (N = t.bottom)
    else if (o === 'bottom')
      (b = y(this.top)), (B = t.top), (N = y(t.bottom) - p), (k = b + p), (_ = this.top + f)
    else if (o === 'left')
      (b = y(this.right)), (P = this.right - f), (S = b - p), (T = y(t.left) + p), (O = t.right)
    else if (o === 'right')
      (b = y(this.left)), (T = t.left), (O = y(t.right) - p), (P = b + p), (S = this.left + f)
    else if (n === 'x') {
      if (o === 'center') b = y((t.top + t.bottom) / 2 + 0.5)
      else if (at(o)) {
        const j = Object.keys(o)[0],
          U = o[j]
        b = y(this.chart.scales[j].getPixelForValue(U))
      }
      ;(B = t.top), (N = t.bottom), (k = b + p), (_ = k + f)
    } else if (n === 'y') {
      if (o === 'center') b = y((t.left + t.right) / 2)
      else if (at(o)) {
        const j = Object.keys(o)[0],
          U = o[j]
        b = y(this.chart.scales[j].getPixelForValue(U))
      }
      ;(P = b - p), (S = P - f), (T = t.left), (O = t.right)
    }
    const Q = Ze(a.ticks.maxTicksLimit, d),
      ue = Math.max(1, Math.ceil(d / Q))
    for (x = 0; x < d; x += ue) {
      const j = this.getContext(x),
        U = s.setContext(j),
        X = r.setContext(j),
        oe = U.lineWidth,
        de = U.color,
        ce = X.dash || [],
        Te = X.dashOffset,
        $e = U.tickWidth,
        He = U.tickColor,
        Ue = U.tickBorderDash || [],
        ie = U.tickBorderDashOffset
      ;(w = fR(this, x, l)),
        w !== void 0 &&
          ((C = Ya(i, w, oe)),
          c ? (P = S = T = O = C) : (k = _ = B = N = C),
          h.push({
            tx1: P,
            ty1: k,
            tx2: S,
            ty2: _,
            x1: T,
            y1: B,
            x2: O,
            y2: N,
            width: oe,
            color: de,
            borderDash: ce,
            borderDashOffset: Te,
            tickWidth: $e,
            tickColor: He,
            tickBorderDash: Ue,
            tickBorderDashOffset: ie
          }))
    }
    return (this._ticksLength = d), (this._borderValue = b), h
  }
  _computeLabelItems(t) {
    const n = this.axis,
      i = this.options,
      { position: a, ticks: s } = i,
      o = this.isHorizontal(),
      r = this.ticks,
      { align: l, crossAlign: c, padding: u, mirror: d } = s,
      f = Bo(i.grid),
      h = f + u,
      v = d ? -u : h,
      g = -oi(this.labelRotation),
      p = []
    let y,
      b,
      x,
      w,
      C,
      P,
      k,
      S,
      _,
      T,
      B,
      O,
      N = 'middle'
    if (a === 'top') (P = this.bottom - v), (k = this._getXAxisLabelAlignment())
    else if (a === 'bottom') (P = this.top + v), (k = this._getXAxisLabelAlignment())
    else if (a === 'left') {
      const ue = this._getYAxisLabelAlignment(f)
      ;(k = ue.textAlign), (C = ue.x)
    } else if (a === 'right') {
      const ue = this._getYAxisLabelAlignment(f)
      ;(k = ue.textAlign), (C = ue.x)
    } else if (n === 'x') {
      if (a === 'center') P = (t.top + t.bottom) / 2 + h
      else if (at(a)) {
        const ue = Object.keys(a)[0],
          j = a[ue]
        P = this.chart.scales[ue].getPixelForValue(j) + h
      }
      k = this._getXAxisLabelAlignment()
    } else if (n === 'y') {
      if (a === 'center') C = (t.left + t.right) / 2 - h
      else if (at(a)) {
        const ue = Object.keys(a)[0],
          j = a[ue]
        C = this.chart.scales[ue].getPixelForValue(j)
      }
      k = this._getYAxisLabelAlignment(f).textAlign
    }
    n === 'y' && (l === 'start' ? (N = 'top') : l === 'end' && (N = 'bottom'))
    const Q = this._getLabelSizes()
    for (y = 0, b = r.length; y < b; ++y) {
      ;(x = r[y]), (w = x.label)
      const ue = s.setContext(this.getContext(y))
      ;(S = this.getPixelForTick(y) + s.labelOffset),
        (_ = this._resolveTickFontOptions(y)),
        (T = _.lineHeight),
        (B = xt(w) ? w.length : 1)
      const j = B / 2,
        U = ue.color,
        X = ue.textStrokeColor,
        oe = ue.textStrokeWidth
      let de = k
      o
        ? ((C = S),
          k === 'inner' &&
            (y === b - 1
              ? (de = this.options.reverse ? 'left' : 'right')
              : y === 0
              ? (de = this.options.reverse ? 'right' : 'left')
              : (de = 'center')),
          a === 'top'
            ? c === 'near' || g !== 0
              ? (O = -B * T + T / 2)
              : c === 'center'
              ? (O = -Q.highest.height / 2 - j * T + T)
              : (O = -Q.highest.height + T / 2)
            : c === 'near' || g !== 0
            ? (O = T / 2)
            : c === 'center'
            ? (O = Q.highest.height / 2 - j * T)
            : (O = Q.highest.height - B * T),
          d && (O *= -1),
          g !== 0 && !ue.showLabelBackdrop && (C += (T / 2) * Math.sin(g)))
        : ((P = S), (O = ((1 - B) * T) / 2))
      let ce
      if (ue.showLabelBackdrop) {
        const Te = fn(ue.backdropPadding),
          $e = Q.heights[y],
          He = Q.widths[y]
        let Ue = O - Te.top,
          ie = 0 - Te.left
        switch (N) {
          case 'middle':
            Ue -= $e / 2
            break
          case 'bottom':
            Ue -= $e
            break
        }
        switch (k) {
          case 'center':
            ie -= He / 2
            break
          case 'right':
            ie -= He
            break
        }
        ce = { left: ie, top: Ue, width: He + Te.width, height: $e + Te.height, color: ue.backdropColor }
      }
      p.push({
        label: w,
        font: _,
        textOffset: O,
        options: {
          rotation: g,
          color: U,
          strokeColor: X,
          strokeWidth: oe,
          textAlign: de,
          textBaseline: N,
          translation: [C, P],
          backdrop: ce
        }
      })
    }
    return p
  }
  _getXAxisLabelAlignment() {
    const { position: t, ticks: n } = this.options
    if (-oi(this.labelRotation)) return t === 'top' ? 'left' : 'right'
    let a = 'center'
    return (
      n.align === 'start'
        ? (a = 'left')
        : n.align === 'end'
        ? (a = 'right')
        : n.align === 'inner' && (a = 'inner'),
      a
    )
  }
  _getYAxisLabelAlignment(t) {
    const {
        position: n,
        ticks: { crossAlign: i, mirror: a, padding: s }
      } = this.options,
      o = this._getLabelSizes(),
      r = t + s,
      l = o.widest.width
    let c, u
    return (
      n === 'left'
        ? a
          ? ((u = this.right + s),
            i === 'near'
              ? (c = 'left')
              : i === 'center'
              ? ((c = 'center'), (u += l / 2))
              : ((c = 'right'), (u += l)))
          : ((u = this.right - r),
            i === 'near'
              ? (c = 'right')
              : i === 'center'
              ? ((c = 'center'), (u -= l / 2))
              : ((c = 'left'), (u = this.left)))
        : n === 'right'
        ? a
          ? ((u = this.left + s),
            i === 'near'
              ? (c = 'right')
              : i === 'center'
              ? ((c = 'center'), (u -= l / 2))
              : ((c = 'left'), (u -= l)))
          : ((u = this.left + r),
            i === 'near'
              ? (c = 'left')
              : i === 'center'
              ? ((c = 'center'), (u += l / 2))
              : ((c = 'right'), (u = this.right)))
        : (c = 'right'),
      { textAlign: c, x: u }
    )
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) return
    const t = this.chart,
      n = this.options.position
    if (n === 'left' || n === 'right') return { top: 0, left: this.left, bottom: t.height, right: this.right }
    if (n === 'top' || n === 'bottom') return { top: this.top, left: 0, bottom: this.bottom, right: t.width }
  }
  drawBackground() {
    const {
      ctx: t,
      options: { backgroundColor: n },
      left: i,
      top: a,
      width: s,
      height: o
    } = this
    n && (t.save(), (t.fillStyle = n), t.fillRect(i, a, s, o), t.restore())
  }
  getLineWidthForValue(t) {
    const n = this.options.grid
    if (!this._isVisible() || !n.display) return 0
    const a = this.ticks.findIndex((s) => s.value === t)
    return a >= 0 ? n.setContext(this.getContext(a)).lineWidth : 0
  }
  drawGrid(t) {
    const n = this.options.grid,
      i = this.ctx,
      a = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t))
    let s, o
    const r = (l, c, u) => {
      !u.width ||
        !u.color ||
        (i.save(),
        (i.lineWidth = u.width),
        (i.strokeStyle = u.color),
        i.setLineDash(u.borderDash || []),
        (i.lineDashOffset = u.borderDashOffset),
        i.beginPath(),
        i.moveTo(l.x, l.y),
        i.lineTo(c.x, c.y),
        i.stroke(),
        i.restore())
    }
    if (n.display)
      for (s = 0, o = a.length; s < o; ++s) {
        const l = a[s]
        n.drawOnChartArea && r({ x: l.x1, y: l.y1 }, { x: l.x2, y: l.y2 }, l),
          n.drawTicks &&
            r(
              { x: l.tx1, y: l.ty1 },
              { x: l.tx2, y: l.ty2 },
              {
                color: l.tickColor,
                width: l.tickWidth,
                borderDash: l.tickBorderDash,
                borderDashOffset: l.tickBorderDashOffset
              }
            )
      }
  }
  drawBorder() {
    const {
        chart: t,
        ctx: n,
        options: { border: i, grid: a }
      } = this,
      s = i.setContext(this.getContext()),
      o = i.display ? s.width : 0
    if (!o) return
    const r = a.setContext(this.getContext(0)).lineWidth,
      l = this._borderValue
    let c, u, d, f
    this.isHorizontal()
      ? ((c = Ya(t, this.left, o) - o / 2), (u = Ya(t, this.right, r) + r / 2), (d = f = l))
      : ((d = Ya(t, this.top, o) - o / 2), (f = Ya(t, this.bottom, r) + r / 2), (c = u = l)),
      n.save(),
      (n.lineWidth = s.width),
      (n.strokeStyle = s.color),
      n.beginPath(),
      n.moveTo(c, d),
      n.lineTo(u, f),
      n.stroke(),
      n.restore()
  }
  drawLabels(t) {
    if (!this.options.ticks.display) return
    const i = this.ctx,
      a = this._computeLabelArea()
    a && au(i, a)
    const s = this.getLabelItems(t)
    for (const o of s) {
      const r = o.options,
        l = o.font,
        c = o.label,
        u = o.textOffset
      ps(i, c, 0, u, l, r)
    }
    a && su(i)
  }
  drawTitle() {
    const {
      ctx: t,
      options: { position: n, title: i, reverse: a }
    } = this
    if (!i.display) return
    const s = jt(i.font),
      o = fn(i.padding),
      r = i.align
    let l = s.lineHeight / 2
    n === 'bottom' || n === 'center' || at(n)
      ? ((l += o.bottom), xt(i.text) && (l += s.lineHeight * (i.text.length - 1)))
      : (l += o.top)
    const { titleX: c, titleY: u, maxWidth: d, rotation: f } = pR(this, l, n, r)
    ps(t, i.text, 0, 0, s, {
      color: i.color,
      maxWidth: d,
      rotation: f,
      textAlign: mR(r, n, a),
      textBaseline: 'middle',
      translation: [c, u]
    })
  }
  draw(t) {
    this._isVisible() &&
      (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t))
  }
  _layers() {
    const t = this.options,
      n = (t.ticks && t.ticks.z) || 0,
      i = Ze(t.grid && t.grid.z, -1),
      a = Ze(t.border && t.border.z, 0)
    return !this._isVisible() || this.draw !== Ms.prototype.draw
      ? [
          {
            z: n,
            draw: (s) => {
              this.draw(s)
            }
          }
        ]
      : [
          {
            z: i,
            draw: (s) => {
              this.drawBackground(), this.drawGrid(s), this.drawTitle()
            }
          },
          {
            z: a,
            draw: () => {
              this.drawBorder()
            }
          },
          {
            z: n,
            draw: (s) => {
              this.drawLabels(s)
            }
          }
        ]
  }
  getMatchingVisibleMetas(t) {
    const n = this.chart.getSortedVisibleDatasetMetas(),
      i = this.axis + 'AxisID',
      a = []
    let s, o
    for (s = 0, o = n.length; s < o; ++s) {
      const r = n[s]
      r[i] === this.id && (!t || r.type === t) && a.push(r)
    }
    return a
  }
  _resolveTickFontOptions(t) {
    const n = this.options.ticks.setContext(this.getContext(t))
    return jt(n.font)
  }
  _maxDigits() {
    const t = this._resolveTickFontOptions(0).lineHeight
    return (this.isHorizontal() ? this.width : this.height) / t
  }
}
class Al {
  constructor(t, n, i) {
    ;(this.type = t), (this.scope = n), (this.override = i), (this.items = Object.create(null))
  }
  isForType(t) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype)
  }
  register(t) {
    const n = Object.getPrototypeOf(t)
    let i
    _R(n) && (i = this.register(n))
    const a = this.items,
      s = t.id,
      o = this.scope + '.' + s
    if (!s) throw new Error('class does not have id: ' + t)
    return s in a || ((a[s] = t), yR(t, o, i), this.override && Dt.override(t.id, t.overrides)), o
  }
  get(t) {
    return this.items[t]
  }
  unregister(t) {
    const n = this.items,
      i = t.id,
      a = this.scope
    i in n && delete n[i], a && i in Dt[a] && (delete Dt[a][i], this.override && delete ms[i])
  }
}
function yR(e, t, n) {
  const i = Or(Object.create(null), [n ? Dt.get(n) : {}, Dt.get(t), e.defaults])
  Dt.set(t, i), e.defaultRoutes && bR(t, e.defaultRoutes), e.descriptors && Dt.describe(t, e.descriptors)
}
function bR(e, t) {
  Object.keys(t).forEach((n) => {
    const i = n.split('.'),
      a = i.pop(),
      s = [e].concat(i).join('.'),
      o = t[n].split('.'),
      r = o.pop(),
      l = o.join('.')
    Dt.route(s, a, l, r)
  })
}
function _R(e) {
  return 'id' in e && 'defaults' in e
}
class xR {
  constructor() {
    ;(this.controllers = new Al(ui, 'datasets', !0)),
      (this.elements = new Al(la, 'elements')),
      (this.plugins = new Al(Object, 'plugins')),
      (this.scales = new Al(Ms, 'scales')),
      (this._typedRegistries = [this.controllers, this.scales, this.elements])
  }
  add(...t) {
    this._each('register', t)
  }
  remove(...t) {
    this._each('unregister', t)
  }
  addControllers(...t) {
    this._each('register', t, this.controllers)
  }
  addElements(...t) {
    this._each('register', t, this.elements)
  }
  addPlugins(...t) {
    this._each('register', t, this.plugins)
  }
  addScales(...t) {
    this._each('register', t, this.scales)
  }
  getController(t) {
    return this._get(t, this.controllers, 'controller')
  }
  getElement(t) {
    return this._get(t, this.elements, 'element')
  }
  getPlugin(t) {
    return this._get(t, this.plugins, 'plugin')
  }
  getScale(t) {
    return this._get(t, this.scales, 'scale')
  }
  removeControllers(...t) {
    this._each('unregister', t, this.controllers)
  }
  removeElements(...t) {
    this._each('unregister', t, this.elements)
  }
  removePlugins(...t) {
    this._each('unregister', t, this.plugins)
  }
  removeScales(...t) {
    this._each('unregister', t, this.scales)
  }
  _each(t, n, i) {
    ;[...n].forEach((a) => {
      const s = i || this._getRegistryForType(a)
      i || s.isForType(a) || (s === this.plugins && a.id)
        ? this._exec(t, s, a)
        : ht(a, (o) => {
            const r = i || this._getRegistryForType(o)
            this._exec(t, r, o)
          })
    })
  }
  _exec(t, n, i) {
    const a = Th(t)
    pt(i['before' + a], [], i), n[t](i), pt(i['after' + a], [], i)
  }
  _getRegistryForType(t) {
    for (let n = 0; n < this._typedRegistries.length; n++) {
      const i = this._typedRegistries[n]
      if (i.isForType(t)) return i
    }
    return this.plugins
  }
  _get(t, n, i) {
    const a = n.get(t)
    if (a === void 0) throw new Error('"' + t + '" is not a registered ' + i + '.')
    return a
  }
}
var yi = new xR()
class wR {
  constructor() {
    this._init = []
  }
  notify(t, n, i, a) {
    n === 'beforeInit' &&
      ((this._init = this._createDescriptors(t, !0)), this._notify(this._init, t, 'install'))
    const s = a ? this._descriptors(t).filter(a) : this._descriptors(t),
      o = this._notify(s, t, n, i)
    return n === 'afterDestroy' && (this._notify(s, t, 'stop'), this._notify(this._init, t, 'uninstall')), o
  }
  _notify(t, n, i, a) {
    a = a || {}
    for (const s of t) {
      const o = s.plugin,
        r = o[i],
        l = [n, a, s.options]
      if (pt(r, l, o) === !1 && a.cancelable) return !1
    }
    return !0
  }
  invalidate() {
    lt(this._cache) || ((this._oldCache = this._cache), (this._cache = void 0))
  }
  _descriptors(t) {
    if (this._cache) return this._cache
    const n = (this._cache = this._createDescriptors(t))
    return this._notifyStateChanges(t), n
  }
  _createDescriptors(t, n) {
    const i = t && t.config,
      a = Ze(i.options && i.options.plugins, {}),
      s = SR(i)
    return a === !1 && !n ? [] : CR(t, s, a, n)
  }
  _notifyStateChanges(t) {
    const n = this._oldCache || [],
      i = this._cache,
      a = (s, o) => s.filter((r) => !o.some((l) => r.plugin.id === l.plugin.id))
    this._notify(a(n, i), t, 'stop'), this._notify(a(i, n), t, 'start')
  }
}
function SR(e) {
  const t = {},
    n = [],
    i = Object.keys(yi.plugins.items)
  for (let s = 0; s < i.length; s++) n.push(yi.getPlugin(i[s]))
  const a = e.plugins || []
  for (let s = 0; s < a.length; s++) {
    const o = a[s]
    n.indexOf(o) === -1 && (n.push(o), (t[o.id] = !0))
  }
  return { plugins: n, localIds: t }
}
function kR(e, t) {
  return !t && e === !1 ? null : e === !0 ? {} : e
}
function CR(e, { plugins: t, localIds: n }, i, a) {
  const s = [],
    o = e.getContext()
  for (const r of t) {
    const l = r.id,
      c = kR(i[l], a)
    c !== null && s.push({ plugin: r, options: MR(e.config, { plugin: r, local: n[l] }, c, o) })
  }
  return s
}
function MR(e, { plugin: t, local: n }, i, a) {
  const s = e.pluginScopeKeys(t),
    o = e.getOptionScopes(i, s)
  return (
    n && t.defaults && o.push(t.defaults),
    e.createResolver(o, a, [''], { scriptable: !1, indexable: !1, allKeys: !0 })
  )
}
function Zd(e, t) {
  const n = Dt.datasets[e] || {}
  return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || n.indexAxis || 'x'
}
function AR(e, t) {
  let n = e
  return e === '_index_' ? (n = t) : e === '_value_' && (n = t === 'x' ? 'y' : 'x'), n
}
function PR(e, t) {
  return e === t ? '_index_' : '_value_'
}
function np(e) {
  if (e === 'x' || e === 'y' || e === 'r') return e
}
function TR(e) {
  if (e === 'top' || e === 'bottom') return 'x'
  if (e === 'left' || e === 'right') return 'y'
}
function Jd(e, ...t) {
  if (np(e)) return e
  for (const n of t) {
    const i = n.axis || TR(n.position) || (e.length > 1 && np(e[0].toLowerCase()))
    if (i) return i
  }
  throw new Error(`Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`)
}
function ip(e, t, n) {
  if (n[t + 'AxisID'] === e) return { axis: t }
}
function VR(e, t) {
  if (t.data && t.data.datasets) {
    const n = t.data.datasets.filter((i) => i.xAxisID === e || i.yAxisID === e)
    if (n.length) return ip(e, 'x', n[0]) || ip(e, 'y', n[0])
  }
  return {}
}
function ER(e, t) {
  const n = ms[e.type] || { scales: {} },
    i = t.scales || {},
    a = Zd(e.type, t),
    s = Object.create(null)
  return (
    Object.keys(i).forEach((o) => {
      const r = i[o]
      if (!at(r)) return console.error(`Invalid scale configuration for scale: ${o}`)
      if (r._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${o}`)
      const l = Jd(o, r, VR(o, e), Dt.scales[r.type]),
        c = PR(l, a),
        u = n.scales || {}
      s[o] = rr(Object.create(null), [{ axis: l }, r, u[l], u[c]])
    }),
    e.data.datasets.forEach((o) => {
      const r = o.type || e.type,
        l = o.indexAxis || Zd(r, t),
        u = (ms[r] || {}).scales || {}
      Object.keys(u).forEach((d) => {
        const f = AR(d, l),
          h = o[f + 'AxisID'] || f
        ;(s[h] = s[h] || Object.create(null)), rr(s[h], [{ axis: f }, i[h], u[d]])
      })
    }),
    Object.keys(s).forEach((o) => {
      const r = s[o]
      rr(r, [Dt.scales[r.type], Dt.scale])
    }),
    s
  )
}
function H_(e) {
  const t = e.options || (e.options = {})
  ;(t.plugins = Ze(t.plugins, {})), (t.scales = ER(e, t))
}
function W_(e) {
  return (e = e || {}), (e.datasets = e.datasets || []), (e.labels = e.labels || []), e
}
function LR(e) {
  return (e = e || {}), (e.data = W_(e.data)), H_(e), e
}
const ap = new Map(),
  j_ = new Set()
function Pl(e, t) {
  let n = ap.get(e)
  return n || ((n = t()), ap.set(e, n), j_.add(n)), n
}
const No = (e, t, n) => {
  const i = Ta(t, n)
  i !== void 0 && e.add(i)
}
class OR {
  constructor(t) {
    ;(this._config = LR(t)), (this._scopeCache = new Map()), (this._resolverCache = new Map())
  }
  get platform() {
    return this._config.platform
  }
  get type() {
    return this._config.type
  }
  set type(t) {
    this._config.type = t
  }
  get data() {
    return this._config.data
  }
  set data(t) {
    this._config.data = W_(t)
  }
  get options() {
    return this._config.options
  }
  set options(t) {
    this._config.options = t
  }
  get plugins() {
    return this._config.plugins
  }
  update() {
    const t = this._config
    this.clearCache(), H_(t)
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear()
  }
  datasetScopeKeys(t) {
    return Pl(t, () => [[`datasets.${t}`, '']])
  }
  datasetAnimationScopeKeys(t, n) {
    return Pl(`${t}.transition.${n}`, () => [
      [`datasets.${t}.transitions.${n}`, `transitions.${n}`],
      [`datasets.${t}`, '']
    ])
  }
  datasetElementScopeKeys(t, n) {
    return Pl(`${t}-${n}`, () => [[`datasets.${t}.elements.${n}`, `datasets.${t}`, `elements.${n}`, '']])
  }
  pluginScopeKeys(t) {
    const n = t.id,
      i = this.type
    return Pl(`${i}-plugin-${n}`, () => [[`plugins.${n}`, ...(t.additionalOptionScopes || [])]])
  }
  _cachedScopes(t, n) {
    const i = this._scopeCache
    let a = i.get(t)
    return (!a || n) && ((a = new Map()), i.set(t, a)), a
  }
  getOptionScopes(t, n, i) {
    const { options: a, type: s } = this,
      o = this._cachedScopes(t, i),
      r = o.get(n)
    if (r) return r
    const l = new Set()
    n.forEach((u) => {
      t && (l.add(t), u.forEach((d) => No(l, t, d))),
        u.forEach((d) => No(l, a, d)),
        u.forEach((d) => No(l, ms[s] || {}, d)),
        u.forEach((d) => No(l, Dt, d)),
        u.forEach((d) => No(l, Xd, d))
    })
    const c = Array.from(l)
    return c.length === 0 && c.push(Object.create(null)), j_.has(n) && o.set(n, c), c
  }
  chartOptionScopes() {
    const { options: t, type: n } = this
    return [t, ms[n] || {}, Dt.datasets[n] || {}, { type: n }, Dt, Xd]
  }
  resolveNamedOptions(t, n, i, a = ['']) {
    const s = { $shared: !0 },
      { resolver: o, subPrefixes: r } = sp(this._resolverCache, t, a)
    let l = o
    if (DR(o, n)) {
      ;(s.$shared = !1), (i = Va(i) ? i() : i)
      const c = this.createResolver(t, i, r)
      l = ao(o, i, c)
    }
    for (const c of n) s[c] = l[c]
    return s
  }
  createResolver(t, n, i = [''], a) {
    const { resolver: s } = sp(this._resolverCache, t, i)
    return at(n) ? ao(s, n, void 0, a) : s
  }
}
function sp(e, t, n) {
  let i = e.get(t)
  i || ((i = new Map()), e.set(t, i))
  const a = n.join()
  let s = i.get(a)
  return (
    s ||
      ((s = { resolver: Dh(t, n), subPrefixes: n.filter((r) => !r.toLowerCase().includes('hover')) }),
      i.set(a, s)),
    s
  )
}
const IR = (e) => at(e) && Object.getOwnPropertyNames(e).reduce((t, n) => t || Va(e[n]), !1)
function DR(e, t) {
  const { isScriptable: n, isIndexable: i } = w_(e)
  for (const a of t) {
    const s = n(a),
      o = i(a),
      r = (o || s) && e[a]
    if ((s && (Va(r) || IR(r))) || (o && xt(r))) return !0
  }
  return !1
}
var FR = '4.4.0'
const RR = ['top', 'bottom', 'left', 'right', 'chartArea']
function op(e, t) {
  return e === 'top' || e === 'bottom' || (RR.indexOf(e) === -1 && t === 'x')
}
function rp(e, t) {
  return function (n, i) {
    return n[e] === i[e] ? n[t] - i[t] : n[e] - i[e]
  }
}
function lp(e) {
  const t = e.chart,
    n = t.options.animation
  t.notifyPlugins('afterRender'), pt(n && n.onComplete, [e], t)
}
function BR(e) {
  const t = e.chart,
    n = t.options.animation
  pt(n && n.onProgress, [e], t)
}
function U_(e) {
  return (
    P_() && typeof e == 'string' ? (e = document.getElementById(e)) : e && e.length && (e = e[0]),
    e && e.canvas && (e = e.canvas),
    e
  )
}
const Xl = {},
  cp = (e) => {
    const t = U_(e)
    return Object.values(Xl)
      .filter((n) => n.canvas === t)
      .pop()
  }
function NR(e, t, n) {
  const i = Object.keys(e)
  for (const a of i) {
    const s = +a
    if (s >= t) {
      const o = e[a]
      delete e[a], (n > 0 || s > t) && (e[s + n] = o)
    }
  }
}
function $R(e, t, n, i) {
  return !n || e.type === 'mouseout' ? null : i ? t : e
}
function Tl(e, t, n) {
  return e.options.clip ? e[n] : t[n]
}
function zR(e, t) {
  const { xScale: n, yScale: i } = e
  return n && i
    ? { left: Tl(n, t, 'left'), right: Tl(n, t, 'right'), top: Tl(i, t, 'top'), bottom: Tl(i, t, 'bottom') }
    : t
}
class xi {
  static register(...t) {
    yi.add(...t), up()
  }
  static unregister(...t) {
    yi.remove(...t), up()
  }
  constructor(t, n) {
    const i = (this.config = new OR(n)),
      a = U_(t),
      s = cp(a)
    if (s)
      throw new Error(
        "Canvas is already in use. Chart with ID '" +
          s.id +
          "' must be destroyed before the canvas with ID '" +
          s.canvas.id +
          "' can be reused."
      )
    const o = i.createResolver(i.chartOptionScopes(), this.getContext())
    ;(this.platform = new (i.platform || aR(a))()), this.platform.updateConfig(i)
    const r = this.platform.acquireContext(a, o.aspectRatio),
      l = r && r.canvas,
      c = l && l.height,
      u = l && l.width
    if (
      ((this.id = WD()),
      (this.ctx = r),
      (this.canvas = l),
      (this.width = u),
      (this.height = c),
      (this._options = o),
      (this._aspectRatio = this.aspectRatio),
      (this._layers = []),
      (this._metasets = []),
      (this._stacks = void 0),
      (this.boxes = []),
      (this.currentDevicePixelRatio = void 0),
      (this.chartArea = void 0),
      (this._active = []),
      (this._lastEvent = void 0),
      (this._listeners = {}),
      (this._responsiveListeners = void 0),
      (this._sortedMetasets = []),
      (this.scales = {}),
      (this._plugins = new wR()),
      (this.$proxies = {}),
      (this._hiddenIndices = {}),
      (this.attached = !1),
      (this._animationsDisabled = void 0),
      (this.$context = void 0),
      (this._doResize = sF((d) => this.update(d), o.resizeDelay || 0)),
      (this._dataChanges = []),
      (Xl[this.id] = this),
      !r || !l)
    ) {
      console.error("Failed to create chart: can't acquire context from the given item")
      return
    }
    $i.listen(this, 'complete', lp),
      $i.listen(this, 'progress', BR),
      this._initialize(),
      this.attached && this.update()
  }
  get aspectRatio() {
    const {
      options: { aspectRatio: t, maintainAspectRatio: n },
      width: i,
      height: a,
      _aspectRatio: s
    } = this
    return lt(t) ? (n && s ? s : a ? i / a : null) : t
  }
  get data() {
    return this.config.data
  }
  set data(t) {
    this.config.data = t
  }
  get options() {
    return this._options
  }
  set options(t) {
    this.config.options = t
  }
  get registry() {
    return yi
  }
  _initialize() {
    return (
      this.notifyPlugins('beforeInit'),
      this.options.responsive ? this.resize() : Em(this, this.options.devicePixelRatio),
      this.bindEvents(),
      this.notifyPlugins('afterInit'),
      this
    )
  }
  clear() {
    return Pm(this.canvas, this.ctx), this
  }
  stop() {
    return $i.stop(this), this
  }
  resize(t, n) {
    $i.running(this) ? (this._resizeBeforeDraw = { width: t, height: n }) : this._resize(t, n)
  }
  _resize(t, n) {
    const i = this.options,
      a = this.canvas,
      s = i.maintainAspectRatio && this.aspectRatio,
      o = this.platform.getMaximumSize(a, t, n, s),
      r = i.devicePixelRatio || this.platform.getDevicePixelRatio(),
      l = this.width ? 'resize' : 'attach'
    ;(this.width = o.width),
      (this.height = o.height),
      (this._aspectRatio = this.aspectRatio),
      Em(this, r, !0) &&
        (this.notifyPlugins('resize', { size: o }),
        pt(i.onResize, [this, o], this),
        this.attached && this._doResize(l) && this.render())
  }
  ensureScalesHaveIDs() {
    const n = this.options.scales || {}
    ht(n, (i, a) => {
      i.id = a
    })
  }
  buildOrUpdateScales() {
    const t = this.options,
      n = t.scales,
      i = this.scales,
      a = Object.keys(i).reduce((o, r) => ((o[r] = !1), o), {})
    let s = []
    n &&
      (s = s.concat(
        Object.keys(n).map((o) => {
          const r = n[o],
            l = Jd(o, r),
            c = l === 'r',
            u = l === 'x'
          return {
            options: r,
            dposition: c ? 'chartArea' : u ? 'bottom' : 'left',
            dtype: c ? 'radialLinear' : u ? 'category' : 'linear'
          }
        })
      )),
      ht(s, (o) => {
        const r = o.options,
          l = r.id,
          c = Jd(l, r),
          u = Ze(r.type, o.dtype)
        ;(r.position === void 0 || op(r.position, c) !== op(o.dposition)) && (r.position = o.dposition),
          (a[l] = !0)
        let d = null
        if (l in i && i[l].type === u) d = i[l]
        else {
          const f = yi.getScale(u)
          ;(d = new f({ id: l, type: u, ctx: this.ctx, chart: this })), (i[d.id] = d)
        }
        d.init(r, t)
      }),
      ht(a, (o, r) => {
        o || delete i[r]
      }),
      ht(i, (o) => {
        un.configure(this, o, o.options), un.addBox(this, o)
      })
  }
  _updateMetasets() {
    const t = this._metasets,
      n = this.data.datasets.length,
      i = t.length
    if ((t.sort((a, s) => a.index - s.index), i > n)) {
      for (let a = n; a < i; ++a) this._destroyDatasetMeta(a)
      t.splice(n, i - n)
    }
    this._sortedMetasets = t.slice(0).sort(rp('order', 'index'))
  }
  _removeUnreferencedMetasets() {
    const {
      _metasets: t,
      data: { datasets: n }
    } = this
    t.length > n.length && delete this._stacks,
      t.forEach((i, a) => {
        n.filter((s) => s === i._dataset).length === 0 && this._destroyDatasetMeta(a)
      })
  }
  buildOrUpdateControllers() {
    const t = [],
      n = this.data.datasets
    let i, a
    for (this._removeUnreferencedMetasets(), i = 0, a = n.length; i < a; i++) {
      const s = n[i]
      let o = this.getDatasetMeta(i)
      const r = s.type || this.config.type
      if (
        (o.type && o.type !== r && (this._destroyDatasetMeta(i), (o = this.getDatasetMeta(i))),
        (o.type = r),
        (o.indexAxis = s.indexAxis || Zd(r, this.options)),
        (o.order = s.order || 0),
        (o.index = i),
        (o.label = '' + s.label),
        (o.visible = this.isDatasetVisible(i)),
        o.controller)
      )
        o.controller.updateIndex(i), o.controller.linkScales()
      else {
        const l = yi.getController(r),
          { datasetElementType: c, dataElementType: u } = Dt.datasets[r]
        Object.assign(l, { dataElementType: yi.getElement(u), datasetElementType: c && yi.getElement(c) }),
          (o.controller = new l(this, i)),
          t.push(o.controller)
      }
    }
    return this._updateMetasets(), t
  }
  _resetElements() {
    ht(
      this.data.datasets,
      (t, n) => {
        this.getDatasetMeta(n).controller.reset()
      },
      this
    )
  }
  reset() {
    this._resetElements(), this.notifyPlugins('reset')
  }
  update(t) {
    const n = this.config
    n.update()
    const i = (this._options = n.createResolver(n.chartOptionScopes(), this.getContext())),
      a = (this._animationsDisabled = !i.animation)
    if (
      (this._updateScales(),
      this._checkEventBindings(),
      this._updateHiddenIndices(),
      this._plugins.invalidate(),
      this.notifyPlugins('beforeUpdate', { mode: t, cancelable: !0 }) === !1)
    )
      return
    const s = this.buildOrUpdateControllers()
    this.notifyPlugins('beforeElementsUpdate')
    let o = 0
    for (let c = 0, u = this.data.datasets.length; c < u; c++) {
      const { controller: d } = this.getDatasetMeta(c),
        f = !a && s.indexOf(d) === -1
      d.buildOrUpdateElements(f), (o = Math.max(+d.getMaxOverflow(), o))
    }
    ;(o = this._minPadding = i.layout.autoPadding ? o : 0),
      this._updateLayout(o),
      a ||
        ht(s, (c) => {
          c.reset()
        }),
      this._updateDatasets(t),
      this.notifyPlugins('afterUpdate', { mode: t }),
      this._layers.sort(rp('z', '_idx'))
    const { _active: r, _lastEvent: l } = this
    l ? this._eventHandler(l, !0) : r.length && this._updateHoverStyles(r, r, !0), this.render()
  }
  _updateScales() {
    ht(this.scales, (t) => {
      un.removeBox(this, t)
    }),
      this.ensureScalesHaveIDs(),
      this.buildOrUpdateScales()
  }
  _checkEventBindings() {
    const t = this.options,
      n = new Set(Object.keys(this._listeners)),
      i = new Set(t.events)
    ;(!bm(n, i) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents())
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: t } = this,
      n = this._getUniformDataChanges() || []
    for (const { method: i, start: a, count: s } of n) {
      const o = i === '_removeElements' ? -s : s
      NR(t, a, o)
    }
  }
  _getUniformDataChanges() {
    const t = this._dataChanges
    if (!t || !t.length) return
    this._dataChanges = []
    const n = this.data.datasets.length,
      i = (s) => new Set(t.filter((o) => o[0] === s).map((o, r) => r + ',' + o.splice(1).join(','))),
      a = i(0)
    for (let s = 1; s < n; s++) if (!bm(a, i(s))) return
    return Array.from(a)
      .map((s) => s.split(','))
      .map((s) => ({ method: s[1], start: +s[2], count: +s[3] }))
  }
  _updateLayout(t) {
    if (this.notifyPlugins('beforeLayout', { cancelable: !0 }) === !1) return
    un.update(this, this.width, this.height, t)
    const n = this.chartArea,
      i = n.width <= 0 || n.height <= 0
    ;(this._layers = []),
      ht(
        this.boxes,
        (a) => {
          ;(i && a.position === 'chartArea') ||
            (a.configure && a.configure(), this._layers.push(...a._layers()))
        },
        this
      ),
      this._layers.forEach((a, s) => {
        a._idx = s
      }),
      this.notifyPlugins('afterLayout')
  }
  _updateDatasets(t) {
    if (this.notifyPlugins('beforeDatasetsUpdate', { mode: t, cancelable: !0 }) !== !1) {
      for (let n = 0, i = this.data.datasets.length; n < i; ++n) this.getDatasetMeta(n).controller.configure()
      for (let n = 0, i = this.data.datasets.length; n < i; ++n)
        this._updateDataset(n, Va(t) ? t({ datasetIndex: n }) : t)
      this.notifyPlugins('afterDatasetsUpdate', { mode: t })
    }
  }
  _updateDataset(t, n) {
    const i = this.getDatasetMeta(t),
      a = { meta: i, index: t, mode: n, cancelable: !0 }
    this.notifyPlugins('beforeDatasetUpdate', a) !== !1 &&
      (i.controller._update(n), (a.cancelable = !1), this.notifyPlugins('afterDatasetUpdate', a))
  }
  render() {
    this.notifyPlugins('beforeRender', { cancelable: !0 }) !== !1 &&
      ($i.has(this)
        ? this.attached && !$i.running(this) && $i.start(this)
        : (this.draw(), lp({ chart: this })))
  }
  draw() {
    let t
    if (this._resizeBeforeDraw) {
      const { width: i, height: a } = this._resizeBeforeDraw
      this._resize(i, a), (this._resizeBeforeDraw = null)
    }
    if (
      (this.clear(),
      this.width <= 0 || this.height <= 0 || this.notifyPlugins('beforeDraw', { cancelable: !0 }) === !1)
    )
      return
    const n = this._layers
    for (t = 0; t < n.length && n[t].z <= 0; ++t) n[t].draw(this.chartArea)
    for (this._drawDatasets(); t < n.length; ++t) n[t].draw(this.chartArea)
    this.notifyPlugins('afterDraw')
  }
  _getSortedDatasetMetas(t) {
    const n = this._sortedMetasets,
      i = []
    let a, s
    for (a = 0, s = n.length; a < s; ++a) {
      const o = n[a]
      ;(!t || o.visible) && i.push(o)
    }
    return i
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0)
  }
  _drawDatasets() {
    if (this.notifyPlugins('beforeDatasetsDraw', { cancelable: !0 }) === !1) return
    const t = this.getSortedVisibleDatasetMetas()
    for (let n = t.length - 1; n >= 0; --n) this._drawDataset(t[n])
    this.notifyPlugins('afterDatasetsDraw')
  }
  _drawDataset(t) {
    const n = this.ctx,
      i = t._clip,
      a = !i.disabled,
      s = zR(t, this.chartArea),
      o = { meta: t, index: t.index, cancelable: !0 }
    this.notifyPlugins('beforeDatasetDraw', o) !== !1 &&
      (a &&
        au(n, {
          left: i.left === !1 ? 0 : s.left - i.left,
          right: i.right === !1 ? this.width : s.right + i.right,
          top: i.top === !1 ? 0 : s.top - i.top,
          bottom: i.bottom === !1 ? this.height : s.bottom + i.bottom
        }),
      t.controller.draw(),
      a && su(n),
      (o.cancelable = !1),
      this.notifyPlugins('afterDatasetDraw', o))
  }
  isPointInArea(t) {
    return Gi(t, this.chartArea, this._minPadding)
  }
  getElementsAtEventForMode(t, n, i, a) {
    const s = R5.modes[n]
    return typeof s == 'function' ? s(this, t, i, a) : []
  }
  getDatasetMeta(t) {
    const n = this.data.datasets[t],
      i = this._metasets
    let a = i.filter((s) => s && s._dataset === n).pop()
    return (
      a ||
        ((a = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          xAxisID: null,
          yAxisID: null,
          order: (n && n.order) || 0,
          index: t,
          _dataset: n,
          _parsed: [],
          _sorted: !1
        }),
        i.push(a)),
      a
    )
  }
  getContext() {
    return this.$context || (this.$context = Ba(null, { chart: this, type: 'chart' }))
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length
  }
  isDatasetVisible(t) {
    const n = this.data.datasets[t]
    if (!n) return !1
    const i = this.getDatasetMeta(t)
    return typeof i.hidden == 'boolean' ? !i.hidden : !n.hidden
  }
  setDatasetVisibility(t, n) {
    const i = this.getDatasetMeta(t)
    i.hidden = !n
  }
  toggleDataVisibility(t) {
    this._hiddenIndices[t] = !this._hiddenIndices[t]
  }
  getDataVisibility(t) {
    return !this._hiddenIndices[t]
  }
  _updateVisibility(t, n, i) {
    const a = i ? 'show' : 'hide',
      s = this.getDatasetMeta(t),
      o = s.controller._resolveAnimations(void 0, a)
    Ir(n)
      ? ((s.data[n].hidden = !i), this.update())
      : (this.setDatasetVisibility(t, i),
        o.update(s, { visible: i }),
        this.update((r) => (r.datasetIndex === t ? a : void 0)))
  }
  hide(t, n) {
    this._updateVisibility(t, n, !1)
  }
  show(t, n) {
    this._updateVisibility(t, n, !0)
  }
  _destroyDatasetMeta(t) {
    const n = this._metasets[t]
    n && n.controller && n.controller._destroy(), delete this._metasets[t]
  }
  _stop() {
    let t, n
    for (this.stop(), $i.remove(this), t = 0, n = this.data.datasets.length; t < n; ++t)
      this._destroyDatasetMeta(t)
  }
  destroy() {
    this.notifyPlugins('beforeDestroy')
    const { canvas: t, ctx: n } = this
    this._stop(),
      this.config.clearCache(),
      t &&
        (this.unbindEvents(),
        Pm(t, n),
        this.platform.releaseContext(n),
        (this.canvas = null),
        (this.ctx = null)),
      delete Xl[this.id],
      this.notifyPlugins('afterDestroy')
  }
  toBase64Image(...t) {
    return this.canvas.toDataURL(...t)
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : (this.attached = !0)
  }
  bindUserEvents() {
    const t = this._listeners,
      n = this.platform,
      i = (s, o) => {
        n.addEventListener(this, s, o), (t[s] = o)
      },
      a = (s, o, r) => {
        ;(s.offsetX = o), (s.offsetY = r), this._eventHandler(s)
      }
    ht(this.options.events, (s) => i(s, a))
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {})
    const t = this._responsiveListeners,
      n = this.platform,
      i = (l, c) => {
        n.addEventListener(this, l, c), (t[l] = c)
      },
      a = (l, c) => {
        t[l] && (n.removeEventListener(this, l, c), delete t[l])
      },
      s = (l, c) => {
        this.canvas && this.resize(l, c)
      }
    let o
    const r = () => {
      a('attach', r), (this.attached = !0), this.resize(), i('resize', s), i('detach', o)
    }
    ;(o = () => {
      ;(this.attached = !1), a('resize', s), this._stop(), this._resize(0, 0), i('attach', r)
    }),
      n.isAttached(this.canvas) ? r() : o()
  }
  unbindEvents() {
    ht(this._listeners, (t, n) => {
      this.platform.removeEventListener(this, n, t)
    }),
      (this._listeners = {}),
      ht(this._responsiveListeners, (t, n) => {
        this.platform.removeEventListener(this, n, t)
      }),
      (this._responsiveListeners = void 0)
  }
  updateHoverStyle(t, n, i) {
    const a = i ? 'set' : 'remove'
    let s, o, r, l
    for (
      n === 'dataset' &&
        ((s = this.getDatasetMeta(t[0].datasetIndex)), s.controller['_' + a + 'DatasetHoverStyle']()),
        r = 0,
        l = t.length;
      r < l;
      ++r
    ) {
      o = t[r]
      const c = o && this.getDatasetMeta(o.datasetIndex).controller
      c && c[a + 'HoverStyle'](o.element, o.datasetIndex, o.index)
    }
  }
  getActiveElements() {
    return this._active || []
  }
  setActiveElements(t) {
    const n = this._active || [],
      i = t.map(({ datasetIndex: s, index: o }) => {
        const r = this.getDatasetMeta(s)
        if (!r) throw new Error('No dataset found at index ' + s)
        return { datasetIndex: s, element: r.data[o], index: o }
      })
    !mc(i, n) && ((this._active = i), (this._lastEvent = null), this._updateHoverStyles(i, n))
  }
  notifyPlugins(t, n, i) {
    return this._plugins.notify(this, t, n, i)
  }
  isPluginEnabled(t) {
    return this._plugins._cache.filter((n) => n.plugin.id === t).length === 1
  }
  _updateHoverStyles(t, n, i) {
    const a = this.options.hover,
      s = (l, c) => l.filter((u) => !c.some((d) => u.datasetIndex === d.datasetIndex && u.index === d.index)),
      o = s(n, t),
      r = i ? t : s(t, n)
    o.length && this.updateHoverStyle(o, a.mode, !1),
      r.length && a.mode && this.updateHoverStyle(r, a.mode, !0)
  }
  _eventHandler(t, n) {
    const i = { event: t, replay: n, cancelable: !0, inChartArea: this.isPointInArea(t) },
      a = (o) => (o.options.events || this.options.events).includes(t.native.type)
    if (this.notifyPlugins('beforeEvent', i, a) === !1) return
    const s = this._handleEvent(t, n, i.inChartArea)
    return (
      (i.cancelable = !1), this.notifyPlugins('afterEvent', i, a), (s || i.changed) && this.render(), this
    )
  }
  _handleEvent(t, n, i) {
    const { _active: a = [], options: s } = this,
      o = n,
      r = this._getActiveElements(t, a, i, o),
      l = KD(t),
      c = $R(t, this._lastEvent, i, l)
    i && ((this._lastEvent = null), pt(s.onHover, [t, r, this], this), l && pt(s.onClick, [t, r, this], this))
    const u = !mc(r, a)
    return (u || n) && ((this._active = r), this._updateHoverStyles(r, a, n)), (this._lastEvent = c), u
  }
  _getActiveElements(t, n, i, a) {
    if (t.type === 'mouseout') return []
    if (!i) return n
    const s = this.options.hover
    return this.getElementsAtEventForMode(t, s.mode, s, a)
  }
}
ke(xi, 'defaults', Dt),
  ke(xi, 'instances', Xl),
  ke(xi, 'overrides', ms),
  ke(xi, 'registry', yi),
  ke(xi, 'version', FR),
  ke(xi, 'getChart', cp)
function up() {
  return ht(xi.instances, (e) => e._plugins.invalidate())
}
function HR(e, t, n) {
  const { startAngle: i, pixelMargin: a, x: s, y: o, outerRadius: r, innerRadius: l } = t
  let c = a / r
  e.beginPath(),
    e.arc(s, o, r, i - c, n + c),
    l > a ? ((c = a / l), e.arc(s, o, l, n + c, i - c, !0)) : e.arc(s, o, a, n + Bt, i - Bt),
    e.closePath(),
    e.clip()
}
function WR(e) {
  return Ih(e, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd'])
}
function jR(e, t, n, i) {
  const a = WR(e.options.borderRadius),
    s = (n - t) / 2,
    o = Math.min(s, (i * t) / 2),
    r = (l) => {
      const c = ((n - Math.min(s, l)) * i) / 2
      return Zt(l, 0, Math.min(s, c))
    }
  return {
    outerStart: r(a.outerStart),
    outerEnd: r(a.outerEnd),
    innerStart: Zt(a.innerStart, 0, o),
    innerEnd: Zt(a.innerEnd, 0, o)
  }
}
function Is(e, t, n, i) {
  return { x: n + e * Math.cos(t), y: i + e * Math.sin(t) }
}
function wc(e, t, n, i, a, s) {
  const { x: o, y: r, startAngle: l, pixelMargin: c, innerRadius: u } = t,
    d = Math.max(t.outerRadius + i + n - c, 0),
    f = u > 0 ? u + i + n + c : 0
  let h = 0
  const v = a - l
  if (i) {
    const ue = u > 0 ? u - i : 0,
      j = d > 0 ? d - i : 0,
      U = (ue + j) / 2,
      X = U !== 0 ? (v * U) / (U + i) : v
    h = (v - X) / 2
  }
  const g = Math.max(0.001, v * d - n / St) / d,
    p = (v - g) / 2,
    y = l + p + h,
    b = a - p - h,
    { outerStart: x, outerEnd: w, innerStart: C, innerEnd: P } = jR(t, f, d, b - y),
    k = d - x,
    S = d - w,
    _ = y + x / k,
    T = b - w / S,
    B = f + C,
    O = f + P,
    N = y + C / B,
    Q = b - P / O
  if ((e.beginPath(), s)) {
    const ue = (_ + T) / 2
    if ((e.arc(o, r, d, _, ue), e.arc(o, r, d, ue, T), w > 0)) {
      const oe = Is(S, T, o, r)
      e.arc(oe.x, oe.y, w, T, b + Bt)
    }
    const j = Is(O, b, o, r)
    if ((e.lineTo(j.x, j.y), P > 0)) {
      const oe = Is(O, Q, o, r)
      e.arc(oe.x, oe.y, P, b + Bt, Q + Math.PI)
    }
    const U = (b - P / f + (y + C / f)) / 2
    if ((e.arc(o, r, f, b - P / f, U, !0), e.arc(o, r, f, U, y + C / f, !0), C > 0)) {
      const oe = Is(B, N, o, r)
      e.arc(oe.x, oe.y, C, N + Math.PI, y - Bt)
    }
    const X = Is(k, y, o, r)
    if ((e.lineTo(X.x, X.y), x > 0)) {
      const oe = Is(k, _, o, r)
      e.arc(oe.x, oe.y, x, y - Bt, _)
    }
  } else {
    e.moveTo(o, r)
    const ue = Math.cos(_) * d + o,
      j = Math.sin(_) * d + r
    e.lineTo(ue, j)
    const U = Math.cos(T) * d + o,
      X = Math.sin(T) * d + r
    e.lineTo(U, X)
  }
  e.closePath()
}
function UR(e, t, n, i, a) {
  const { fullCircles: s, startAngle: o, circumference: r } = t
  let l = t.endAngle
  if (s) {
    wc(e, t, n, i, l, a)
    for (let c = 0; c < s; ++c) e.fill()
    isNaN(r) || (l = o + (r % wt || wt))
  }
  return wc(e, t, n, i, l, a), e.fill(), l
}
function YR(e, t, n, i, a) {
  const { fullCircles: s, startAngle: o, circumference: r, options: l } = t,
    { borderWidth: c, borderJoinStyle: u, borderDash: d, borderDashOffset: f } = l,
    h = l.borderAlign === 'inner'
  if (!c) return
  e.setLineDash(d || []),
    (e.lineDashOffset = f),
    h
      ? ((e.lineWidth = c * 2), (e.lineJoin = u || 'round'))
      : ((e.lineWidth = c), (e.lineJoin = u || 'bevel'))
  let v = t.endAngle
  if (s) {
    wc(e, t, n, i, v, a)
    for (let g = 0; g < s; ++g) e.stroke()
    isNaN(r) || (v = o + (r % wt || wt))
  }
  h && HR(e, t, v), s || (wc(e, t, n, i, v, a), e.stroke())
}
class Xo extends la {
  constructor(n) {
    super()
    ke(this, 'circumference')
    ke(this, 'endAngle')
    ke(this, 'fullCircles')
    ke(this, 'innerRadius')
    ke(this, 'outerRadius')
    ke(this, 'pixelMargin')
    ke(this, 'startAngle')
    ;(this.options = void 0),
      (this.circumference = void 0),
      (this.startAngle = void 0),
      (this.endAngle = void 0),
      (this.innerRadius = void 0),
      (this.outerRadius = void 0),
      (this.pixelMargin = 0),
      (this.fullCircles = 0),
      n && Object.assign(this, n)
  }
  inRange(n, i, a) {
    const s = this.getProps(['x', 'y'], a),
      { angle: o, distance: r } = f_(s, { x: n, y: i }),
      {
        startAngle: l,
        endAngle: c,
        innerRadius: u,
        outerRadius: d,
        circumference: f
      } = this.getProps(['startAngle', 'endAngle', 'innerRadius', 'outerRadius', 'circumference'], a),
      h = (this.options.spacing + this.options.borderWidth) / 2,
      g = Ze(f, c - l) >= wt || Dr(o, l, c),
      p = Ui(r, u + h, d + h)
    return g && p
  }
  getCenterPoint(n) {
    const {
        x: i,
        y: a,
        startAngle: s,
        endAngle: o,
        innerRadius: r,
        outerRadius: l
      } = this.getProps(['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius'], n),
      { offset: c, spacing: u } = this.options,
      d = (s + o) / 2,
      f = (r + l + u + c) / 2
    return { x: i + Math.cos(d) * f, y: a + Math.sin(d) * f }
  }
  tooltipPosition(n) {
    return this.getCenterPoint(n)
  }
  draw(n) {
    const { options: i, circumference: a } = this,
      s = (i.offset || 0) / 4,
      o = (i.spacing || 0) / 2,
      r = i.circular
    if (
      ((this.pixelMargin = i.borderAlign === 'inner' ? 0.33 : 0),
      (this.fullCircles = a > wt ? Math.floor(a / wt) : 0),
      a === 0 || this.innerRadius < 0 || this.outerRadius < 0)
    )
      return
    n.save()
    const l = (this.startAngle + this.endAngle) / 2
    n.translate(Math.cos(l) * s, Math.sin(l) * s)
    const c = 1 - Math.sin(Math.min(St, a || 0)),
      u = s * c
    ;(n.fillStyle = i.backgroundColor),
      (n.strokeStyle = i.borderColor),
      UR(n, this, u, o, r),
      YR(n, this, u, o, r),
      n.restore()
  }
}
ke(Xo, 'id', 'arc'),
  ke(Xo, 'defaults', {
    borderAlign: 'center',
    borderColor: '#fff',
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: !0
  }),
  ke(Xo, 'defaultRoutes', { backgroundColor: 'backgroundColor' }),
  ke(Xo, 'descriptors', { _scriptable: !0, _indexable: (n) => n !== 'borderDash' })
function Y_(e, t, n = t) {
  ;(e.lineCap = Ze(n.borderCapStyle, t.borderCapStyle)),
    e.setLineDash(Ze(n.borderDash, t.borderDash)),
    (e.lineDashOffset = Ze(n.borderDashOffset, t.borderDashOffset)),
    (e.lineJoin = Ze(n.borderJoinStyle, t.borderJoinStyle)),
    (e.lineWidth = Ze(n.borderWidth, t.borderWidth)),
    (e.strokeStyle = Ze(n.borderColor, t.borderColor))
}
function GR(e, t, n) {
  e.lineTo(n.x, n.y)
}
function XR(e) {
  return e.stepped ? pF : e.tension || e.cubicInterpolationMode === 'monotone' ? yF : GR
}
function G_(e, t, n = {}) {
  const i = e.length,
    { start: a = 0, end: s = i - 1 } = n,
    { start: o, end: r } = t,
    l = Math.max(a, o),
    c = Math.min(s, r),
    u = (a < o && s < o) || (a > r && s > r)
  return { count: i, start: l, loop: t.loop, ilen: c < l && !u ? i + c - l : c - l }
}
function KR(e, t, n, i) {
  const { points: a, options: s } = t,
    { count: o, start: r, loop: l, ilen: c } = G_(a, n, i),
    u = XR(s)
  let { move: d = !0, reverse: f } = i || {},
    h,
    v,
    g
  for (h = 0; h <= c; ++h)
    (v = a[(r + (f ? c - h : h)) % o]),
      !v.skip && (d ? (e.moveTo(v.x, v.y), (d = !1)) : u(e, g, v, f, s.stepped), (g = v))
  return l && ((v = a[(r + (f ? c : 0)) % o]), u(e, g, v, f, s.stepped)), !!l
}
function qR(e, t, n, i) {
  const a = t.points,
    { count: s, start: o, ilen: r } = G_(a, n, i),
    { move: l = !0, reverse: c } = i || {}
  let u = 0,
    d = 0,
    f,
    h,
    v,
    g,
    p,
    y
  const b = (w) => (o + (c ? r - w : w)) % s,
    x = () => {
      g !== p && (e.lineTo(u, p), e.lineTo(u, g), e.lineTo(u, y))
    }
  for (l && ((h = a[b(0)]), e.moveTo(h.x, h.y)), f = 0; f <= r; ++f) {
    if (((h = a[b(f)]), h.skip)) continue
    const w = h.x,
      C = h.y,
      P = w | 0
    P === v
      ? (C < g ? (g = C) : C > p && (p = C), (u = (d * u + w) / ++d))
      : (x(), e.lineTo(w, C), (v = P), (d = 0), (g = p = C)),
      (y = C)
  }
  x()
}
function Qd(e) {
  const t = e.options,
    n = t.borderDash && t.borderDash.length
  return !e._decimated &&
    !e._loop &&
    !t.tension &&
    t.cubicInterpolationMode !== 'monotone' &&
    !t.stepped &&
    !n
    ? qR
    : KR
}
function ZR(e) {
  return e.stepped ? qF : e.tension || e.cubicInterpolationMode === 'monotone' ? ZF : qa
}
function JR(e, t, n, i) {
  let a = t._path
  a || ((a = t._path = new Path2D()), t.path(a, n, i) && a.closePath()), Y_(e, t.options), e.stroke(a)
}
function QR(e, t, n, i) {
  const { segments: a, options: s } = t,
    o = Qd(t)
  for (const r of a)
    Y_(e, s, r.style), e.beginPath(), o(e, t, r, { start: n, end: n + i - 1 }) && e.closePath(), e.stroke()
}
const e4 = typeof Path2D == 'function'
function t4(e, t, n, i) {
  e4 && !t.options.segment ? JR(e, t, n, i) : QR(e, t, n, i)
}
class xa extends la {
  constructor(t) {
    super(),
      (this.animated = !0),
      (this.options = void 0),
      (this._chart = void 0),
      (this._loop = void 0),
      (this._fullLoop = void 0),
      (this._path = void 0),
      (this._points = void 0),
      (this._segments = void 0),
      (this._decimated = !1),
      (this._pointsUpdated = !1),
      (this._datasetIndex = void 0),
      t && Object.assign(this, t)
  }
  updateControlPoints(t, n) {
    const i = this.options
    if ((i.tension || i.cubicInterpolationMode === 'monotone') && !i.stepped && !this._pointsUpdated) {
      const a = i.spanGaps ? this._loop : this._fullLoop
      HF(this._points, i, t, a, n), (this._pointsUpdated = !0)
    }
  }
  set points(t) {
    ;(this._points = t), delete this._segments, delete this._path, (this._pointsUpdated = !1)
  }
  get points() {
    return this._points
  }
  get segments() {
    return this._segments || (this._segments = i5(this, this.options.segment))
  }
  first() {
    const t = this.segments,
      n = this.points
    return t.length && n[t[0].start]
  }
  last() {
    const t = this.segments,
      n = this.points,
      i = t.length
    return i && n[t[i - 1].end]
  }
  interpolate(t, n) {
    const i = this.options,
      a = t[n],
      s = this.points,
      o = O_(this, { property: n, start: a, end: a })
    if (!o.length) return
    const r = [],
      l = ZR(i)
    let c, u
    for (c = 0, u = o.length; c < u; ++c) {
      const { start: d, end: f } = o[c],
        h = s[d],
        v = s[f]
      if (h === v) {
        r.push(h)
        continue
      }
      const g = Math.abs((a - h[n]) / (v[n] - h[n])),
        p = l(h, v, g, i.stepped)
      ;(p[n] = t[n]), r.push(p)
    }
    return r.length === 1 ? r[0] : r
  }
  pathSegment(t, n, i) {
    return Qd(this)(t, this, n, i)
  }
  path(t, n, i) {
    const a = this.segments,
      s = Qd(this)
    let o = this._loop
    ;(n = n || 0), (i = i || this.points.length - n)
    for (const r of a) o &= s(t, this, r, { start: n, end: n + i - 1 })
    return !!o
  }
  draw(t, n, i, a) {
    const s = this.options || {}
    ;(this.points || []).length && s.borderWidth && (t.save(), t4(t, this, i, a), t.restore()),
      this.animated && ((this._pointsUpdated = !1), (this._path = void 0))
  }
}
ke(xa, 'id', 'line'),
  ke(xa, 'defaults', {
    borderCapStyle: 'butt',
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: 'miter',
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: 'default',
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0
  }),
  ke(xa, 'defaultRoutes', { backgroundColor: 'backgroundColor', borderColor: 'borderColor' }),
  ke(xa, 'descriptors', { _scriptable: !0, _indexable: (t) => t !== 'borderDash' && t !== 'fill' })
function dp(e, t, n, i) {
  const a = e.options,
    { [n]: s } = e.getProps([n], i)
  return Math.abs(t - s) < a.radius + a.hitRadius
}
class Kl extends la {
  constructor(n) {
    super()
    ke(this, 'parsed')
    ke(this, 'skip')
    ke(this, 'stop')
    ;(this.options = void 0),
      (this.parsed = void 0),
      (this.skip = void 0),
      (this.stop = void 0),
      n && Object.assign(this, n)
  }
  inRange(n, i, a) {
    const s = this.options,
      { x: o, y: r } = this.getProps(['x', 'y'], a)
    return Math.pow(n - o, 2) + Math.pow(i - r, 2) < Math.pow(s.hitRadius + s.radius, 2)
  }
  inXRange(n, i) {
    return dp(this, n, 'x', i)
  }
  inYRange(n, i) {
    return dp(this, n, 'y', i)
  }
  getCenterPoint(n) {
    const { x: i, y: a } = this.getProps(['x', 'y'], n)
    return { x: i, y: a }
  }
  size(n) {
    n = n || this.options || {}
    let i = n.radius || 0
    i = Math.max(i, (i && n.hoverRadius) || 0)
    const a = (i && n.borderWidth) || 0
    return (i + a) * 2
  }
  draw(n, i) {
    const a = this.options
    this.skip ||
      a.radius < 0.1 ||
      !Gi(this, i, this.size(a) / 2) ||
      ((n.strokeStyle = a.borderColor),
      (n.lineWidth = a.borderWidth),
      (n.fillStyle = a.backgroundColor),
      Kd(n, a, this.x, this.y))
  }
  getRange() {
    const n = this.options || {}
    return n.radius + n.hitRadius
  }
}
ke(Kl, 'id', 'point'),
  ke(Kl, 'defaults', {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: 'circle',
    radius: 3,
    rotation: 0
  }),
  ke(Kl, 'defaultRoutes', { backgroundColor: 'backgroundColor', borderColor: 'borderColor' })
function X_(e, t) {
  const { x: n, y: i, base: a, width: s, height: o } = e.getProps(['x', 'y', 'base', 'width', 'height'], t)
  let r, l, c, u, d
  return (
    e.horizontal
      ? ((d = o / 2), (r = Math.min(n, a)), (l = Math.max(n, a)), (c = i - d), (u = i + d))
      : ((d = s / 2), (r = n - d), (l = n + d), (c = Math.min(i, a)), (u = Math.max(i, a))),
    { left: r, top: c, right: l, bottom: u }
  )
}
function wa(e, t, n, i) {
  return e ? 0 : Zt(t, n, i)
}
function n4(e, t, n) {
  const i = e.options.borderWidth,
    a = e.borderSkipped,
    s = x_(i)
  return {
    t: wa(a.top, s.top, 0, n),
    r: wa(a.right, s.right, 0, t),
    b: wa(a.bottom, s.bottom, 0, n),
    l: wa(a.left, s.left, 0, t)
  }
}
function i4(e, t, n) {
  const { enableBorderRadius: i } = e.getProps(['enableBorderRadius']),
    a = e.options.borderRadius,
    s = cs(a),
    o = Math.min(t, n),
    r = e.borderSkipped,
    l = i || at(a)
  return {
    topLeft: wa(!l || r.top || r.left, s.topLeft, 0, o),
    topRight: wa(!l || r.top || r.right, s.topRight, 0, o),
    bottomLeft: wa(!l || r.bottom || r.left, s.bottomLeft, 0, o),
    bottomRight: wa(!l || r.bottom || r.right, s.bottomRight, 0, o)
  }
}
function a4(e) {
  const t = X_(e),
    n = t.right - t.left,
    i = t.bottom - t.top,
    a = n4(e, n / 2, i / 2),
    s = i4(e, n / 2, i / 2)
  return {
    outer: { x: t.left, y: t.top, w: n, h: i, radius: s },
    inner: {
      x: t.left + a.l,
      y: t.top + a.t,
      w: n - a.l - a.r,
      h: i - a.t - a.b,
      radius: {
        topLeft: Math.max(0, s.topLeft - Math.max(a.t, a.l)),
        topRight: Math.max(0, s.topRight - Math.max(a.t, a.r)),
        bottomLeft: Math.max(0, s.bottomLeft - Math.max(a.b, a.l)),
        bottomRight: Math.max(0, s.bottomRight - Math.max(a.b, a.r))
      }
    }
  }
}
function ju(e, t, n, i) {
  const a = t === null,
    s = n === null,
    r = e && !(a && s) && X_(e, i)
  return r && (a || Ui(t, r.left, r.right)) && (s || Ui(n, r.top, r.bottom))
}
function s4(e) {
  return e.topLeft || e.topRight || e.bottomLeft || e.bottomRight
}
function o4(e, t) {
  e.rect(t.x, t.y, t.w, t.h)
}
function Uu(e, t, n = {}) {
  const i = e.x !== n.x ? -t : 0,
    a = e.y !== n.y ? -t : 0,
    s = (e.x + e.w !== n.x + n.w ? t : 0) - i,
    o = (e.y + e.h !== n.y + n.h ? t : 0) - a
  return { x: e.x + i, y: e.y + a, w: e.w + s, h: e.h + o, radius: e.radius }
}
class ql extends la {
  constructor(t) {
    super(),
      (this.options = void 0),
      (this.horizontal = void 0),
      (this.base = void 0),
      (this.width = void 0),
      (this.height = void 0),
      (this.inflateAmount = void 0),
      t && Object.assign(this, t)
  }
  draw(t) {
    const {
        inflateAmount: n,
        options: { borderColor: i, backgroundColor: a }
      } = this,
      { inner: s, outer: o } = a4(this),
      r = s4(o.radius) ? Fr : o4
    t.save(),
      (o.w !== s.w || o.h !== s.h) &&
        (t.beginPath(),
        r(t, Uu(o, n, s)),
        t.clip(),
        r(t, Uu(s, -n, o)),
        (t.fillStyle = i),
        t.fill('evenodd')),
      t.beginPath(),
      r(t, Uu(s, n)),
      (t.fillStyle = a),
      t.fill(),
      t.restore()
  }
  inRange(t, n, i) {
    return ju(this, t, n, i)
  }
  inXRange(t, n) {
    return ju(this, t, null, n)
  }
  inYRange(t, n) {
    return ju(this, null, t, n)
  }
  getCenterPoint(t) {
    const { x: n, y: i, base: a, horizontal: s } = this.getProps(['x', 'y', 'base', 'horizontal'], t)
    return { x: s ? (n + a) / 2 : n, y: s ? i : (i + a) / 2 }
  }
  getRange(t) {
    return t === 'x' ? this.width / 2 : this.height / 2
  }
}
ke(ql, 'id', 'bar'),
  ke(ql, 'defaults', {
    borderSkipped: 'start',
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: 'auto',
    pointStyle: void 0
  }),
  ke(ql, 'defaultRoutes', { backgroundColor: 'backgroundColor', borderColor: 'borderColor' })
var r4 = Object.freeze({ __proto__: null, ArcElement: Xo, BarElement: ql, LineElement: xa, PointElement: Kl })
const ef = [
    'rgb(54, 162, 235)',
    'rgb(255, 99, 132)',
    'rgb(255, 159, 64)',
    'rgb(255, 205, 86)',
    'rgb(75, 192, 192)',
    'rgb(153, 102, 255)',
    'rgb(201, 203, 207)'
  ],
  fp = ef.map((e) => e.replace('rgb(', 'rgba(').replace(')', ', 0.5)'))
function K_(e) {
  return ef[e % ef.length]
}
function q_(e) {
  return fp[e % fp.length]
}
function l4(e, t) {
  return (e.borderColor = K_(t)), (e.backgroundColor = q_(t)), ++t
}
function c4(e, t) {
  return (e.backgroundColor = e.data.map(() => K_(t++))), t
}
function u4(e, t) {
  return (e.backgroundColor = e.data.map(() => q_(t++))), t
}
function d4(e) {
  let t = 0
  return (n, i) => {
    const a = e.getDatasetMeta(i).controller
    a instanceof as ? (t = c4(n, t)) : a instanceof dr ? (t = u4(n, t)) : a && (t = l4(n, t))
  }
}
function hp(e) {
  let t
  for (t in e) if (e[t].borderColor || e[t].backgroundColor) return !0
  return !1
}
function f4(e) {
  return e && (e.borderColor || e.backgroundColor)
}
var h4 = {
  id: 'colors',
  defaults: { enabled: !0, forceOverride: !1 },
  beforeLayout(e, t, n) {
    if (!n.enabled) return
    const {
        data: { datasets: i },
        options: a
      } = e.config,
      { elements: s } = a
    if (!n.forceOverride && (hp(i) || f4(a) || (s && hp(s)))) return
    const o = d4(e)
    i.forEach(o)
  }
}
function v4(e, t, n, i, a) {
  const s = a.samples || i
  if (s >= n) return e.slice(t, t + n)
  const o = [],
    r = (n - 2) / (s - 2)
  let l = 0
  const c = t + n - 1
  let u = t,
    d,
    f,
    h,
    v,
    g
  for (o[l++] = e[u], d = 0; d < s - 2; d++) {
    let p = 0,
      y = 0,
      b
    const x = Math.floor((d + 1) * r) + 1 + t,
      w = Math.min(Math.floor((d + 2) * r) + 1, n) + t,
      C = w - x
    for (b = x; b < w; b++) (p += e[b].x), (y += e[b].y)
    ;(p /= C), (y /= C)
    const P = Math.floor(d * r) + 1 + t,
      k = Math.min(Math.floor((d + 1) * r) + 1, n) + t,
      { x: S, y: _ } = e[u]
    for (h = v = -1, b = P; b < k; b++)
      (v = 0.5 * Math.abs((S - p) * (e[b].y - _) - (S - e[b].x) * (y - _))),
        v > h && ((h = v), (f = e[b]), (g = b))
    ;(o[l++] = f), (u = g)
  }
  return (o[l++] = e[c]), o
}
function g4(e, t, n, i) {
  let a = 0,
    s = 0,
    o,
    r,
    l,
    c,
    u,
    d,
    f,
    h,
    v,
    g
  const p = [],
    y = t + n - 1,
    b = e[t].x,
    w = e[y].x - b
  for (o = t; o < t + n; ++o) {
    ;(r = e[o]), (l = ((r.x - b) / w) * i), (c = r.y)
    const C = l | 0
    if (C === u) c < v ? ((v = c), (d = o)) : c > g && ((g = c), (f = o)), (a = (s * a + r.x) / ++s)
    else {
      const P = o - 1
      if (!lt(d) && !lt(f)) {
        const k = Math.min(d, f),
          S = Math.max(d, f)
        k !== h && k !== P && p.push({ ...e[k], x: a }), S !== h && S !== P && p.push({ ...e[S], x: a })
      }
      o > 0 && P !== h && p.push(e[P]), p.push(r), (u = C), (s = 0), (v = g = c), (d = f = h = o)
    }
  }
  return p
}
function Z_(e) {
  if (e._decimated) {
    const t = e._data
    delete e._decimated,
      delete e._data,
      Object.defineProperty(e, 'data', { configurable: !0, enumerable: !0, writable: !0, value: t })
  }
}
function vp(e) {
  e.data.datasets.forEach((t) => {
    Z_(t)
  })
}
function m4(e, t) {
  const n = t.length
  let i = 0,
    a
  const { iScale: s } = e,
    { min: o, max: r, minDefined: l, maxDefined: c } = s.getUserBounds()
  return (
    l && (i = Zt(Yi(t, s.axis, o).lo, 0, n - 1)),
    c ? (a = Zt(Yi(t, s.axis, r).hi + 1, i, n) - i) : (a = n - i),
    { start: i, count: a }
  )
}
var p4 = {
  id: 'decimation',
  defaults: { algorithm: 'min-max', enabled: !1 },
  beforeElementsUpdate: (e, t, n) => {
    if (!n.enabled) {
      vp(e)
      return
    }
    const i = e.width
    e.data.datasets.forEach((a, s) => {
      const { _data: o, indexAxis: r } = a,
        l = e.getDatasetMeta(s),
        c = o || a.data
      if (Yo([r, e.options.indexAxis]) === 'y' || !l.controller.supportsDecimation) return
      const u = e.scales[l.xAxisID]
      if ((u.type !== 'linear' && u.type !== 'time') || e.options.parsing) return
      let { start: d, count: f } = m4(l, c)
      const h = n.threshold || 4 * i
      if (f <= h) {
        Z_(a)
        return
      }
      lt(o) &&
        ((a._data = c),
        delete a.data,
        Object.defineProperty(a, 'data', {
          configurable: !0,
          enumerable: !0,
          get: function () {
            return this._decimated
          },
          set: function (g) {
            this._data = g
          }
        }))
      let v
      switch (n.algorithm) {
        case 'lttb':
          v = v4(c, d, f, i, n)
          break
        case 'min-max':
          v = g4(c, d, f, i)
          break
        default:
          throw new Error(`Unsupported decimation algorithm '${n.algorithm}'`)
      }
      a._decimated = v
    })
  },
  destroy(e) {
    vp(e)
  }
}
function y4(e, t, n) {
  const i = e.segments,
    a = e.points,
    s = t.points,
    o = []
  for (const r of i) {
    let { start: l, end: c } = r
    c = $h(l, c, a)
    const u = tf(n, a[l], a[c], r.loop)
    if (!t.segments) {
      o.push({ source: r, target: u, start: a[l], end: a[c] })
      continue
    }
    const d = O_(t, u)
    for (const f of d) {
      const h = tf(n, s[f.start], s[f.end], f.loop),
        v = L_(r, a, h)
      for (const g of v)
        o.push({
          source: g,
          target: f,
          start: { [n]: gp(u, h, 'start', Math.max) },
          end: { [n]: gp(u, h, 'end', Math.min) }
        })
    }
  }
  return o
}
function tf(e, t, n, i) {
  if (i) return
  let a = t[e],
    s = n[e]
  return e === 'angle' && ((a = En(a)), (s = En(s))), { property: e, start: a, end: s }
}
function b4(e, t) {
  const { x: n = null, y: i = null } = e || {},
    a = t.points,
    s = []
  return (
    t.segments.forEach(({ start: o, end: r }) => {
      r = $h(o, r, a)
      const l = a[o],
        c = a[r]
      i !== null
        ? (s.push({ x: l.x, y: i }), s.push({ x: c.x, y: i }))
        : n !== null && (s.push({ x: n, y: l.y }), s.push({ x: n, y: c.y }))
    }),
    s
  )
}
function $h(e, t, n) {
  for (; t > e; t--) {
    const i = n[t]
    if (!isNaN(i.x) && !isNaN(i.y)) break
  }
  return t
}
function gp(e, t, n, i) {
  return e && t ? i(e[n], t[n]) : e ? e[n] : t ? t[n] : 0
}
function J_(e, t) {
  let n = [],
    i = !1
  return (
    xt(e) ? ((i = !0), (n = e)) : (n = b4(e, t)),
    n.length ? new xa({ points: n, options: { tension: 0 }, _loop: i, _fullLoop: i }) : null
  )
}
function mp(e) {
  return e && e.fill !== !1
}
function _4(e, t, n) {
  let a = e[t].fill
  const s = [t]
  let o
  if (!n) return a
  for (; a !== !1 && s.indexOf(a) === -1; ) {
    if (!It(a)) return a
    if (((o = e[a]), !o)) return !1
    if (o.visible) return a
    s.push(a), (a = o.fill)
  }
  return !1
}
function x4(e, t, n) {
  const i = C4(e)
  if (at(i)) return isNaN(i.value) ? !1 : i
  let a = parseFloat(i)
  return It(a) && Math.floor(a) === a
    ? w4(i[0], t, a, n)
    : ['origin', 'start', 'end', 'stack', 'shape'].indexOf(i) >= 0 && i
}
function w4(e, t, n, i) {
  return (e === '-' || e === '+') && (n = t + n), n === t || n < 0 || n >= i ? !1 : n
}
function S4(e, t) {
  let n = null
  return (
    e === 'start'
      ? (n = t.bottom)
      : e === 'end'
      ? (n = t.top)
      : at(e)
      ? (n = t.getPixelForValue(e.value))
      : t.getBasePixel && (n = t.getBasePixel()),
    n
  )
}
function k4(e, t, n) {
  let i
  return (
    e === 'start'
      ? (i = n)
      : e === 'end'
      ? (i = t.options.reverse ? t.min : t.max)
      : at(e)
      ? (i = e.value)
      : (i = t.getBaseValue()),
    i
  )
}
function C4(e) {
  const t = e.options,
    n = t.fill
  let i = Ze(n && n.target, n)
  return i === void 0 && (i = !!t.backgroundColor), i === !1 || i === null ? !1 : i === !0 ? 'origin' : i
}
function M4(e) {
  const { scale: t, index: n, line: i } = e,
    a = [],
    s = i.segments,
    o = i.points,
    r = A4(t, n)
  r.push(J_({ x: null, y: t.bottom }, i))
  for (let l = 0; l < s.length; l++) {
    const c = s[l]
    for (let u = c.start; u <= c.end; u++) P4(a, o[u], r)
  }
  return new xa({ points: a, options: {} })
}
function A4(e, t) {
  const n = [],
    i = e.getMatchingVisibleMetas('line')
  for (let a = 0; a < i.length; a++) {
    const s = i[a]
    if (s.index === t) break
    s.hidden || n.unshift(s.dataset)
  }
  return n
}
function P4(e, t, n) {
  const i = []
  for (let a = 0; a < n.length; a++) {
    const s = n[a],
      { first: o, last: r, point: l } = T4(s, t, 'x')
    if (!(!l || (o && r))) {
      if (o) i.unshift(l)
      else if ((e.push(l), !r)) break
    }
  }
  e.push(...i)
}
function T4(e, t, n) {
  const i = e.interpolate(t, n)
  if (!i) return {}
  const a = i[n],
    s = e.segments,
    o = e.points
  let r = !1,
    l = !1
  for (let c = 0; c < s.length; c++) {
    const u = s[c],
      d = o[u.start][n],
      f = o[u.end][n]
    if (Ui(a, d, f)) {
      ;(r = a === d), (l = a === f)
      break
    }
  }
  return { first: r, last: l, point: i }
}
class Q_ {
  constructor(t) {
    ;(this.x = t.x), (this.y = t.y), (this.radius = t.radius)
  }
  pathSegment(t, n, i) {
    const { x: a, y: s, radius: o } = this
    return (n = n || { start: 0, end: wt }), t.arc(a, s, o, n.end, n.start, !0), !i.bounds
  }
  interpolate(t) {
    const { x: n, y: i, radius: a } = this,
      s = t.angle
    return { x: n + Math.cos(s) * a, y: i + Math.sin(s) * a, angle: s }
  }
}
function V4(e) {
  const { chart: t, fill: n, line: i } = e
  if (It(n)) return E4(t, n)
  if (n === 'stack') return M4(e)
  if (n === 'shape') return !0
  const a = L4(e)
  return a instanceof Q_ ? a : J_(a, i)
}
function E4(e, t) {
  const n = e.getDatasetMeta(t)
  return n && e.isDatasetVisible(t) ? n.dataset : null
}
function L4(e) {
  return (e.scale || {}).getPointPositionForValue ? I4(e) : O4(e)
}
function O4(e) {
  const { scale: t = {}, fill: n } = e,
    i = S4(n, t)
  if (It(i)) {
    const a = t.isHorizontal()
    return { x: a ? i : null, y: a ? null : i }
  }
  return null
}
function I4(e) {
  const { scale: t, fill: n } = e,
    i = t.options,
    a = t.getLabels().length,
    s = i.reverse ? t.max : t.min,
    o = k4(n, t, s),
    r = []
  if (i.grid.circular) {
    const l = t.getPointPositionForValue(0, s)
    return new Q_({ x: l.x, y: l.y, radius: t.getDistanceFromCenterForValue(o) })
  }
  for (let l = 0; l < a; ++l) r.push(t.getPointPositionForValue(l, o))
  return r
}
function Yu(e, t, n) {
  const i = V4(t),
    { line: a, scale: s, axis: o } = t,
    r = a.options,
    l = r.fill,
    c = r.backgroundColor,
    { above: u = c, below: d = c } = l || {}
  i &&
    a.points.length &&
    (au(e, n), D4(e, { line: a, target: i, above: u, below: d, area: n, scale: s, axis: o }), su(e))
}
function D4(e, t) {
  const { line: n, target: i, above: a, below: s, area: o, scale: r } = t,
    l = n._loop ? 'angle' : t.axis
  e.save(),
    l === 'x' &&
      s !== a &&
      (pp(e, i, o.top),
      yp(e, { line: n, target: i, color: a, scale: r, property: l }),
      e.restore(),
      e.save(),
      pp(e, i, o.bottom)),
    yp(e, { line: n, target: i, color: s, scale: r, property: l }),
    e.restore()
}
function pp(e, t, n) {
  const { segments: i, points: a } = t
  let s = !0,
    o = !1
  e.beginPath()
  for (const r of i) {
    const { start: l, end: c } = r,
      u = a[l],
      d = a[$h(l, c, a)]
    s ? (e.moveTo(u.x, u.y), (s = !1)) : (e.lineTo(u.x, n), e.lineTo(u.x, u.y)),
      (o = !!t.pathSegment(e, r, { move: o })),
      o ? e.closePath() : e.lineTo(d.x, n)
  }
  e.lineTo(t.first().x, n), e.closePath(), e.clip()
}
function yp(e, t) {
  const { line: n, target: i, property: a, color: s, scale: o } = t,
    r = y4(n, i, a)
  for (const { source: l, target: c, start: u, end: d } of r) {
    const { style: { backgroundColor: f = s } = {} } = l,
      h = i !== !0
    e.save(), (e.fillStyle = f), F4(e, o, h && tf(a, u, d)), e.beginPath()
    const v = !!n.pathSegment(e, l)
    let g
    if (h) {
      v ? e.closePath() : bp(e, i, d, a)
      const p = !!i.pathSegment(e, c, { move: v, reverse: !0 })
      ;(g = v && p), g || bp(e, i, u, a)
    }
    e.closePath(), e.fill(g ? 'evenodd' : 'nonzero'), e.restore()
  }
}
function F4(e, t, n) {
  const { top: i, bottom: a } = t.chart.chartArea,
    { property: s, start: o, end: r } = n || {}
  s === 'x' && (e.beginPath(), e.rect(o, i, r - o, a - i), e.clip())
}
function bp(e, t, n, i) {
  const a = t.interpolate(n, i)
  a && e.lineTo(a.x, a.y)
}
var R4 = {
  id: 'filler',
  afterDatasetsUpdate(e, t, n) {
    const i = (e.data.datasets || []).length,
      a = []
    let s, o, r, l
    for (o = 0; o < i; ++o)
      (s = e.getDatasetMeta(o)),
        (r = s.dataset),
        (l = null),
        r &&
          r.options &&
          r instanceof xa &&
          (l = {
            visible: e.isDatasetVisible(o),
            index: o,
            fill: x4(r, o, i),
            chart: e,
            axis: s.controller.options.indexAxis,
            scale: s.vScale,
            line: r
          }),
        (s.$filler = l),
        a.push(l)
    for (o = 0; o < i; ++o) (l = a[o]), !(!l || l.fill === !1) && (l.fill = _4(a, o, n.propagate))
  },
  beforeDraw(e, t, n) {
    const i = n.drawTime === 'beforeDraw',
      a = e.getSortedVisibleDatasetMetas(),
      s = e.chartArea
    for (let o = a.length - 1; o >= 0; --o) {
      const r = a[o].$filler
      r && (r.line.updateControlPoints(s, r.axis), i && r.fill && Yu(e.ctx, r, s))
    }
  },
  beforeDatasetsDraw(e, t, n) {
    if (n.drawTime !== 'beforeDatasetsDraw') return
    const i = e.getSortedVisibleDatasetMetas()
    for (let a = i.length - 1; a >= 0; --a) {
      const s = i[a].$filler
      mp(s) && Yu(e.ctx, s, e.chartArea)
    }
  },
  beforeDatasetDraw(e, t, n) {
    const i = t.meta.$filler
    !mp(i) || n.drawTime !== 'beforeDatasetDraw' || Yu(e.ctx, i, e.chartArea)
  },
  defaults: { propagate: !0, drawTime: 'beforeDatasetDraw' }
}
const _p = (e, t) => {
    let { boxHeight: n = t, boxWidth: i = t } = e
    return (
      e.usePointStyle && ((n = Math.min(n, t)), (i = e.pointStyleWidth || Math.min(i, t))),
      { boxWidth: i, boxHeight: n, itemHeight: Math.max(t, n) }
    )
  },
  B4 = (e, t) => e !== null && t !== null && e.datasetIndex === t.datasetIndex && e.index === t.index
class xp extends la {
  constructor(t) {
    super(),
      (this._added = !1),
      (this.legendHitBoxes = []),
      (this._hoveredItem = null),
      (this.doughnutMode = !1),
      (this.chart = t.chart),
      (this.options = t.options),
      (this.ctx = t.ctx),
      (this.legendItems = void 0),
      (this.columnSizes = void 0),
      (this.lineWidths = void 0),
      (this.maxHeight = void 0),
      (this.maxWidth = void 0),
      (this.top = void 0),
      (this.bottom = void 0),
      (this.left = void 0),
      (this.right = void 0),
      (this.height = void 0),
      (this.width = void 0),
      (this._margins = void 0),
      (this.position = void 0),
      (this.weight = void 0),
      (this.fullSize = void 0)
  }
  update(t, n, i) {
    ;(this.maxWidth = t),
      (this.maxHeight = n),
      (this._margins = i),
      this.setDimensions(),
      this.buildLabels(),
      this.fit()
  }
  setDimensions() {
    this.isHorizontal()
      ? ((this.width = this.maxWidth), (this.left = this._margins.left), (this.right = this.width))
      : ((this.height = this.maxHeight), (this.top = this._margins.top), (this.bottom = this.height))
  }
  buildLabels() {
    const t = this.options.labels || {}
    let n = pt(t.generateLabels, [this.chart], this) || []
    t.filter && (n = n.filter((i) => t.filter(i, this.chart.data))),
      t.sort && (n = n.sort((i, a) => t.sort(i, a, this.chart.data))),
      this.options.reverse && n.reverse(),
      (this.legendItems = n)
  }
  fit() {
    const { options: t, ctx: n } = this
    if (!t.display) {
      this.width = this.height = 0
      return
    }
    const i = t.labels,
      a = jt(i.font),
      s = a.size,
      o = this._computeTitleHeight(),
      { boxWidth: r, itemHeight: l } = _p(i, s)
    let c, u
    ;(n.font = a.string),
      this.isHorizontal()
        ? ((c = this.maxWidth), (u = this._fitRows(o, s, r, l) + 10))
        : ((u = this.maxHeight), (c = this._fitCols(o, a, r, l) + 10)),
      (this.width = Math.min(c, t.maxWidth || this.maxWidth)),
      (this.height = Math.min(u, t.maxHeight || this.maxHeight))
  }
  _fitRows(t, n, i, a) {
    const {
        ctx: s,
        maxWidth: o,
        options: {
          labels: { padding: r }
        }
      } = this,
      l = (this.legendHitBoxes = []),
      c = (this.lineWidths = [0]),
      u = a + r
    let d = t
    ;(s.textAlign = 'left'), (s.textBaseline = 'middle')
    let f = -1,
      h = -u
    return (
      this.legendItems.forEach((v, g) => {
        const p = i + n / 2 + s.measureText(v.text).width
        ;(g === 0 || c[c.length - 1] + p + 2 * r > o) &&
          ((d += u), (c[c.length - (g > 0 ? 0 : 1)] = 0), (h += u), f++),
          (l[g] = { left: 0, top: h, row: f, width: p, height: a }),
          (c[c.length - 1] += p + r)
      }),
      d
    )
  }
  _fitCols(t, n, i, a) {
    const {
        ctx: s,
        maxHeight: o,
        options: {
          labels: { padding: r }
        }
      } = this,
      l = (this.legendHitBoxes = []),
      c = (this.columnSizes = []),
      u = o - t
    let d = r,
      f = 0,
      h = 0,
      v = 0,
      g = 0
    return (
      this.legendItems.forEach((p, y) => {
        const { itemWidth: b, itemHeight: x } = N4(i, n, s, p, a)
        y > 0 &&
          h + x + 2 * r > u &&
          ((d += f + r), c.push({ width: f, height: h }), (v += f + r), g++, (f = h = 0)),
          (l[y] = { left: v, top: h, col: g, width: b, height: x }),
          (f = Math.max(f, b)),
          (h += x + r)
      }),
      (d += f),
      c.push({ width: f, height: h }),
      d
    )
  }
  adjustHitBoxes() {
    if (!this.options.display) return
    const t = this._computeTitleHeight(),
      {
        legendHitBoxes: n,
        options: {
          align: i,
          labels: { padding: a },
          rtl: s
        }
      } = this,
      o = Gs(s, this.left, this.width)
    if (this.isHorizontal()) {
      let r = 0,
        l = rn(i, this.left + a, this.right - this.lineWidths[r])
      for (const c of n)
        r !== c.row && ((r = c.row), (l = rn(i, this.left + a, this.right - this.lineWidths[r]))),
          (c.top += this.top + t + a),
          (c.left = o.leftForLtr(o.x(l), c.width)),
          (l += c.width + a)
    } else {
      let r = 0,
        l = rn(i, this.top + t + a, this.bottom - this.columnSizes[r].height)
      for (const c of n)
        c.col !== r && ((r = c.col), (l = rn(i, this.top + t + a, this.bottom - this.columnSizes[r].height))),
          (c.top = l),
          (c.left += this.left + a),
          (c.left = o.leftForLtr(o.x(c.left), c.width)),
          (l += c.height + a)
    }
  }
  isHorizontal() {
    return this.options.position === 'top' || this.options.position === 'bottom'
  }
  draw() {
    if (this.options.display) {
      const t = this.ctx
      au(t, this), this._draw(), su(t)
    }
  }
  _draw() {
    const { options: t, columnSizes: n, lineWidths: i, ctx: a } = this,
      { align: s, labels: o } = t,
      r = Dt.color,
      l = Gs(t.rtl, this.left, this.width),
      c = jt(o.font),
      { padding: u } = o,
      d = c.size,
      f = d / 2
    let h
    this.drawTitle(),
      (a.textAlign = l.textAlign('left')),
      (a.textBaseline = 'middle'),
      (a.lineWidth = 0.5),
      (a.font = c.string)
    const { boxWidth: v, boxHeight: g, itemHeight: p } = _p(o, d),
      y = function (P, k, S) {
        if (isNaN(v) || v <= 0 || isNaN(g) || g < 0) return
        a.save()
        const _ = Ze(S.lineWidth, 1)
        if (
          ((a.fillStyle = Ze(S.fillStyle, r)),
          (a.lineCap = Ze(S.lineCap, 'butt')),
          (a.lineDashOffset = Ze(S.lineDashOffset, 0)),
          (a.lineJoin = Ze(S.lineJoin, 'miter')),
          (a.lineWidth = _),
          (a.strokeStyle = Ze(S.strokeStyle, r)),
          a.setLineDash(Ze(S.lineDash, [])),
          o.usePointStyle)
        ) {
          const T = {
              radius: (g * Math.SQRT2) / 2,
              pointStyle: S.pointStyle,
              rotation: S.rotation,
              borderWidth: _
            },
            B = l.xPlus(P, v / 2),
            O = k + f
          __(a, T, B, O, o.pointStyleWidth && v)
        } else {
          const T = k + Math.max((d - g) / 2, 0),
            B = l.leftForLtr(P, v),
            O = cs(S.borderRadius)
          a.beginPath(),
            Object.values(O).some((N) => N !== 0)
              ? Fr(a, { x: B, y: T, w: v, h: g, radius: O })
              : a.rect(B, T, v, g),
            a.fill(),
            _ !== 0 && a.stroke()
        }
        a.restore()
      },
      b = function (P, k, S) {
        ps(a, S.text, P, k + p / 2, c, { strikethrough: S.hidden, textAlign: l.textAlign(S.textAlign) })
      },
      x = this.isHorizontal(),
      w = this._computeTitleHeight()
    x
      ? (h = { x: rn(s, this.left + u, this.right - i[0]), y: this.top + u + w, line: 0 })
      : (h = { x: this.left + u, y: rn(s, this.top + w + u, this.bottom - n[0].height), line: 0 }),
      T_(this.ctx, t.textDirection)
    const C = p + u
    this.legendItems.forEach((P, k) => {
      ;(a.strokeStyle = P.fontColor), (a.fillStyle = P.fontColor)
      const S = a.measureText(P.text).width,
        _ = l.textAlign(P.textAlign || (P.textAlign = o.textAlign)),
        T = v + f + S
      let B = h.x,
        O = h.y
      l.setWidth(this.width),
        x
          ? k > 0 &&
            B + T + u > this.right &&
            ((O = h.y += C), h.line++, (B = h.x = rn(s, this.left + u, this.right - i[h.line])))
          : k > 0 &&
            O + C > this.bottom &&
            ((B = h.x = B + n[h.line].width + u),
            h.line++,
            (O = h.y = rn(s, this.top + w + u, this.bottom - n[h.line].height)))
      const N = l.x(B)
      if ((y(N, O, P), (B = oF(_, B + v + f, x ? B + T : this.right, t.rtl)), b(l.x(B), O, P), x))
        h.x += T + u
      else if (typeof P.text != 'string') {
        const Q = c.lineHeight
        h.y += ex(P, Q) + u
      } else h.y += C
    }),
      V_(this.ctx, t.textDirection)
  }
  drawTitle() {
    const t = this.options,
      n = t.title,
      i = jt(n.font),
      a = fn(n.padding)
    if (!n.display) return
    const s = Gs(t.rtl, this.left, this.width),
      o = this.ctx,
      r = n.position,
      l = i.size / 2,
      c = a.top + l
    let u,
      d = this.left,
      f = this.width
    if (this.isHorizontal())
      (f = Math.max(...this.lineWidths)), (u = this.top + c), (d = rn(t.align, d, this.right - f))
    else {
      const v = this.columnSizes.reduce((g, p) => Math.max(g, p.height), 0)
      u = c + rn(t.align, this.top, this.bottom - v - t.labels.padding - this._computeTitleHeight())
    }
    const h = rn(r, d, d + f)
    ;(o.textAlign = s.textAlign(Lh(r))),
      (o.textBaseline = 'middle'),
      (o.strokeStyle = n.color),
      (o.fillStyle = n.color),
      (o.font = i.string),
      ps(o, n.text, h, u, i)
  }
  _computeTitleHeight() {
    const t = this.options.title,
      n = jt(t.font),
      i = fn(t.padding)
    return t.display ? n.lineHeight + i.height : 0
  }
  _getLegendItemAt(t, n) {
    let i, a, s
    if (Ui(t, this.left, this.right) && Ui(n, this.top, this.bottom)) {
      for (s = this.legendHitBoxes, i = 0; i < s.length; ++i)
        if (((a = s[i]), Ui(t, a.left, a.left + a.width) && Ui(n, a.top, a.top + a.height)))
          return this.legendItems[i]
    }
    return null
  }
  handleEvent(t) {
    const n = this.options
    if (!H4(t.type, n)) return
    const i = this._getLegendItemAt(t.x, t.y)
    if (t.type === 'mousemove' || t.type === 'mouseout') {
      const a = this._hoveredItem,
        s = B4(a, i)
      a && !s && pt(n.onLeave, [t, a, this], this),
        (this._hoveredItem = i),
        i && !s && pt(n.onHover, [t, i, this], this)
    } else i && pt(n.onClick, [t, i, this], this)
  }
}
function N4(e, t, n, i, a) {
  const s = $4(i, e, t, n),
    o = z4(a, i, t.lineHeight)
  return { itemWidth: s, itemHeight: o }
}
function $4(e, t, n, i) {
  let a = e.text
  return (
    a && typeof a != 'string' && (a = a.reduce((s, o) => (s.length > o.length ? s : o))),
    t + n.size / 2 + i.measureText(a).width
  )
}
function z4(e, t, n) {
  let i = e
  return typeof t.text != 'string' && (i = ex(t, n)), i
}
function ex(e, t) {
  const n = e.text ? e.text.length : 0
  return t * n
}
function H4(e, t) {
  return !!(
    ((e === 'mousemove' || e === 'mouseout') && (t.onHover || t.onLeave)) ||
    (t.onClick && (e === 'click' || e === 'mouseup'))
  )
}
var W4 = {
  id: 'legend',
  _element: xp,
  start(e, t, n) {
    const i = (e.legend = new xp({ ctx: e.ctx, options: n, chart: e }))
    un.configure(e, i, n), un.addBox(e, i)
  },
  stop(e) {
    un.removeBox(e, e.legend), delete e.legend
  },
  beforeUpdate(e, t, n) {
    const i = e.legend
    un.configure(e, i, n), (i.options = n)
  },
  afterUpdate(e) {
    const t = e.legend
    t.buildLabels(), t.adjustHitBoxes()
  },
  afterEvent(e, t) {
    t.replay || e.legend.handleEvent(t.event)
  },
  defaults: {
    display: !0,
    position: 'top',
    align: 'center',
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(e, t, n) {
      const i = t.datasetIndex,
        a = n.chart
      a.isDatasetVisible(i) ? (a.hide(i), (t.hidden = !0)) : (a.show(i), (t.hidden = !1))
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (e) => e.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(e) {
        const t = e.data.datasets,
          {
            labels: {
              usePointStyle: n,
              pointStyle: i,
              textAlign: a,
              color: s,
              useBorderRadius: o,
              borderRadius: r
            }
          } = e.legend.options
        return e._getSortedDatasetMetas().map((l) => {
          const c = l.controller.getStyle(n ? 0 : void 0),
            u = fn(c.borderWidth)
          return {
            text: t[l.index].label,
            fillStyle: c.backgroundColor,
            fontColor: s,
            hidden: !l.visible,
            lineCap: c.borderCapStyle,
            lineDash: c.borderDash,
            lineDashOffset: c.borderDashOffset,
            lineJoin: c.borderJoinStyle,
            lineWidth: (u.width + u.height) / 4,
            strokeStyle: c.borderColor,
            pointStyle: i || c.pointStyle,
            rotation: c.rotation,
            textAlign: a || c.textAlign,
            borderRadius: o && (r || c.borderRadius),
            datasetIndex: l.index
          }
        }, this)
      }
    },
    title: { color: (e) => e.chart.options.color, display: !1, position: 'center', text: '' }
  },
  descriptors: {
    _scriptable: (e) => !e.startsWith('on'),
    labels: { _scriptable: (e) => !['generateLabels', 'filter', 'sort'].includes(e) }
  }
}
class zh extends la {
  constructor(t) {
    super(),
      (this.chart = t.chart),
      (this.options = t.options),
      (this.ctx = t.ctx),
      (this._padding = void 0),
      (this.top = void 0),
      (this.bottom = void 0),
      (this.left = void 0),
      (this.right = void 0),
      (this.width = void 0),
      (this.height = void 0),
      (this.position = void 0),
      (this.weight = void 0),
      (this.fullSize = void 0)
  }
  update(t, n) {
    const i = this.options
    if (((this.left = 0), (this.top = 0), !i.display)) {
      this.width = this.height = this.right = this.bottom = 0
      return
    }
    ;(this.width = this.right = t), (this.height = this.bottom = n)
    const a = xt(i.text) ? i.text.length : 1
    this._padding = fn(i.padding)
    const s = a * jt(i.font).lineHeight + this._padding.height
    this.isHorizontal() ? (this.height = s) : (this.width = s)
  }
  isHorizontal() {
    const t = this.options.position
    return t === 'top' || t === 'bottom'
  }
  _drawArgs(t) {
    const { top: n, left: i, bottom: a, right: s, options: o } = this,
      r = o.align
    let l = 0,
      c,
      u,
      d
    return (
      this.isHorizontal()
        ? ((u = rn(r, i, s)), (d = n + t), (c = s - i))
        : (o.position === 'left'
            ? ((u = i + t), (d = rn(r, a, n)), (l = St * -0.5))
            : ((u = s - t), (d = rn(r, n, a)), (l = St * 0.5)),
          (c = a - n)),
      { titleX: u, titleY: d, maxWidth: c, rotation: l }
    )
  }
  draw() {
    const t = this.ctx,
      n = this.options
    if (!n.display) return
    const i = jt(n.font),
      s = i.lineHeight / 2 + this._padding.top,
      { titleX: o, titleY: r, maxWidth: l, rotation: c } = this._drawArgs(s)
    ps(t, n.text, 0, 0, i, {
      color: n.color,
      maxWidth: l,
      rotation: c,
      textAlign: Lh(n.align),
      textBaseline: 'middle',
      translation: [o, r]
    })
  }
}
function j4(e, t) {
  const n = new zh({ ctx: e.ctx, options: t, chart: e })
  un.configure(e, n, t), un.addBox(e, n), (e.titleBlock = n)
}
var U4 = {
  id: 'title',
  _element: zh,
  start(e, t, n) {
    j4(e, n)
  },
  stop(e) {
    const t = e.titleBlock
    un.removeBox(e, t), delete e.titleBlock
  },
  beforeUpdate(e, t, n) {
    const i = e.titleBlock
    un.configure(e, i, n), (i.options = n)
  },
  defaults: {
    align: 'center',
    display: !1,
    font: { weight: 'bold' },
    fullSize: !0,
    padding: 10,
    position: 'top',
    text: '',
    weight: 2e3
  },
  defaultRoutes: { color: 'color' },
  descriptors: { _scriptable: !0, _indexable: !1 }
}
const Vl = new WeakMap()
var Y4 = {
  id: 'subtitle',
  start(e, t, n) {
    const i = new zh({ ctx: e.ctx, options: n, chart: e })
    un.configure(e, i, n), un.addBox(e, i), Vl.set(e, i)
  },
  stop(e) {
    un.removeBox(e, Vl.get(e)), Vl.delete(e)
  },
  beforeUpdate(e, t, n) {
    const i = Vl.get(e)
    un.configure(e, i, n), (i.options = n)
  },
  defaults: {
    align: 'center',
    display: !1,
    font: { weight: 'normal' },
    fullSize: !0,
    padding: 0,
    position: 'top',
    text: '',
    weight: 1500
  },
  defaultRoutes: { color: 'color' },
  descriptors: { _scriptable: !0, _indexable: !1 }
}
const Ko = {
  average(e) {
    if (!e.length) return !1
    let t,
      n,
      i = 0,
      a = 0,
      s = 0
    for (t = 0, n = e.length; t < n; ++t) {
      const o = e[t].element
      if (o && o.hasValue()) {
        const r = o.tooltipPosition()
        ;(i += r.x), (a += r.y), ++s
      }
    }
    return { x: i / s, y: a / s }
  },
  nearest(e, t) {
    if (!e.length) return !1
    let n = t.x,
      i = t.y,
      a = Number.POSITIVE_INFINITY,
      s,
      o,
      r
    for (s = 0, o = e.length; s < o; ++s) {
      const l = e[s].element
      if (l && l.hasValue()) {
        const c = l.getCenterPoint(),
          u = Gd(t, c)
        u < a && ((a = u), (r = l))
      }
    }
    if (r) {
      const l = r.tooltipPosition()
      ;(n = l.x), (i = l.y)
    }
    return { x: n, y: i }
  }
}
function pi(e, t) {
  return t && (xt(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e
}
function zi(e) {
  return (typeof e == 'string' || e instanceof String) &&
    e.indexOf(`
`) > -1
    ? e.split(`
`)
    : e
}
function G4(e, t) {
  const { element: n, datasetIndex: i, index: a } = t,
    s = e.getDatasetMeta(i).controller,
    { label: o, value: r } = s.getLabelAndValue(a)
  return {
    chart: e,
    label: o,
    parsed: s.getParsed(a),
    raw: e.data.datasets[i].data[a],
    formattedValue: r,
    dataset: s.getDataset(),
    dataIndex: a,
    datasetIndex: i,
    element: n
  }
}
function wp(e, t) {
  const n = e.chart.ctx,
    { body: i, footer: a, title: s } = e,
    { boxWidth: o, boxHeight: r } = t,
    l = jt(t.bodyFont),
    c = jt(t.titleFont),
    u = jt(t.footerFont),
    d = s.length,
    f = a.length,
    h = i.length,
    v = fn(t.padding)
  let g = v.height,
    p = 0,
    y = i.reduce((w, C) => w + C.before.length + C.lines.length + C.after.length, 0)
  if (
    ((y += e.beforeBody.length + e.afterBody.length),
    d && (g += d * c.lineHeight + (d - 1) * t.titleSpacing + t.titleMarginBottom),
    y)
  ) {
    const w = t.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight
    g += h * w + (y - h) * l.lineHeight + (y - 1) * t.bodySpacing
  }
  f && (g += t.footerMarginTop + f * u.lineHeight + (f - 1) * t.footerSpacing)
  let b = 0
  const x = function (w) {
    p = Math.max(p, n.measureText(w).width + b)
  }
  return (
    n.save(),
    (n.font = c.string),
    ht(e.title, x),
    (n.font = l.string),
    ht(e.beforeBody.concat(e.afterBody), x),
    (b = t.displayColors ? o + 2 + t.boxPadding : 0),
    ht(i, (w) => {
      ht(w.before, x), ht(w.lines, x), ht(w.after, x)
    }),
    (b = 0),
    (n.font = u.string),
    ht(e.footer, x),
    n.restore(),
    (p += v.width),
    { width: p, height: g }
  )
}
function X4(e, t) {
  const { y: n, height: i } = t
  return n < i / 2 ? 'top' : n > e.height - i / 2 ? 'bottom' : 'center'
}
function K4(e, t, n, i) {
  const { x: a, width: s } = i,
    o = n.caretSize + n.caretPadding
  if ((e === 'left' && a + s + o > t.width) || (e === 'right' && a - s - o < 0)) return !0
}
function q4(e, t, n, i) {
  const { x: a, width: s } = n,
    {
      width: o,
      chartArea: { left: r, right: l }
    } = e
  let c = 'center'
  return (
    i === 'center'
      ? (c = a <= (r + l) / 2 ? 'left' : 'right')
      : a <= s / 2
      ? (c = 'left')
      : a >= o - s / 2 && (c = 'right'),
    K4(c, e, t, n) && (c = 'center'),
    c
  )
}
function Sp(e, t, n) {
  const i = n.yAlign || t.yAlign || X4(e, n)
  return { xAlign: n.xAlign || t.xAlign || q4(e, t, n, i), yAlign: i }
}
function Z4(e, t) {
  let { x: n, width: i } = e
  return t === 'right' ? (n -= i) : t === 'center' && (n -= i / 2), n
}
function J4(e, t, n) {
  let { y: i, height: a } = e
  return t === 'top' ? (i += n) : t === 'bottom' ? (i -= a + n) : (i -= a / 2), i
}
function kp(e, t, n, i) {
  const { caretSize: a, caretPadding: s, cornerRadius: o } = e,
    { xAlign: r, yAlign: l } = n,
    c = a + s,
    { topLeft: u, topRight: d, bottomLeft: f, bottomRight: h } = cs(o)
  let v = Z4(t, r)
  const g = J4(t, l, c)
  return (
    l === 'center'
      ? r === 'left'
        ? (v += c)
        : r === 'right' && (v -= c)
      : r === 'left'
      ? (v -= Math.max(u, f) + a)
      : r === 'right' && (v += Math.max(d, h) + a),
    { x: Zt(v, 0, i.width - t.width), y: Zt(g, 0, i.height - t.height) }
  )
}
function El(e, t, n) {
  const i = fn(n.padding)
  return t === 'center' ? e.x + e.width / 2 : t === 'right' ? e.x + e.width - i.right : e.x + i.left
}
function Cp(e) {
  return pi([], zi(e))
}
function Q4(e, t, n) {
  return Ba(e, { tooltip: t, tooltipItems: n, type: 'tooltip' })
}
function Mp(e, t) {
  const n = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks
  return n ? e.override(n) : e
}
const tx = {
  beforeTitle: Bi,
  title(e) {
    if (e.length > 0) {
      const t = e[0],
        n = t.chart.data.labels,
        i = n ? n.length : 0
      if (this && this.options && this.options.mode === 'dataset') return t.dataset.label || ''
      if (t.label) return t.label
      if (i > 0 && t.dataIndex < i) return n[t.dataIndex]
    }
    return ''
  },
  afterTitle: Bi,
  beforeBody: Bi,
  beforeLabel: Bi,
  label(e) {
    if (this && this.options && this.options.mode === 'dataset')
      return e.label + ': ' + e.formattedValue || e.formattedValue
    let t = e.dataset.label || ''
    t && (t += ': ')
    const n = e.formattedValue
    return lt(n) || (t += n), t
  },
  labelColor(e) {
    const n = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex)
    return {
      borderColor: n.borderColor,
      backgroundColor: n.backgroundColor,
      borderWidth: n.borderWidth,
      borderDash: n.borderDash,
      borderDashOffset: n.borderDashOffset,
      borderRadius: 0
    }
  },
  labelTextColor() {
    return this.options.bodyColor
  },
  labelPointStyle(e) {
    const n = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex)
    return { pointStyle: n.pointStyle, rotation: n.rotation }
  },
  afterLabel: Bi,
  afterBody: Bi,
  beforeFooter: Bi,
  footer: Bi,
  afterFooter: Bi
}
function wn(e, t, n, i) {
  const a = e[t].call(n, i)
  return typeof a > 'u' ? tx[t].call(n, i) : a
}
class nf extends la {
  constructor(t) {
    super(),
      (this.opacity = 0),
      (this._active = []),
      (this._eventPosition = void 0),
      (this._size = void 0),
      (this._cachedAnimations = void 0),
      (this._tooltipItems = []),
      (this.$animations = void 0),
      (this.$context = void 0),
      (this.chart = t.chart),
      (this.options = t.options),
      (this.dataPoints = void 0),
      (this.title = void 0),
      (this.beforeBody = void 0),
      (this.body = void 0),
      (this.afterBody = void 0),
      (this.footer = void 0),
      (this.xAlign = void 0),
      (this.yAlign = void 0),
      (this.x = void 0),
      (this.y = void 0),
      (this.height = void 0),
      (this.width = void 0),
      (this.caretX = void 0),
      (this.caretY = void 0),
      (this.labelColors = void 0),
      (this.labelPointStyles = void 0),
      (this.labelTextColors = void 0)
  }
  initialize(t) {
    ;(this.options = t), (this._cachedAnimations = void 0), (this.$context = void 0)
  }
  _resolveAnimations() {
    const t = this._cachedAnimations
    if (t) return t
    const n = this.chart,
      i = this.options.setContext(this.getContext()),
      a = i.enabled && n.options.animation && i.animations,
      s = new I_(this.chart, a)
    return a._cacheable && (this._cachedAnimations = Object.freeze(s)), s
  }
  getContext() {
    return this.$context || (this.$context = Q4(this.chart.getContext(), this, this._tooltipItems))
  }
  getTitle(t, n) {
    const { callbacks: i } = n,
      a = wn(i, 'beforeTitle', this, t),
      s = wn(i, 'title', this, t),
      o = wn(i, 'afterTitle', this, t)
    let r = []
    return (r = pi(r, zi(a))), (r = pi(r, zi(s))), (r = pi(r, zi(o))), r
  }
  getBeforeBody(t, n) {
    return Cp(wn(n.callbacks, 'beforeBody', this, t))
  }
  getBody(t, n) {
    const { callbacks: i } = n,
      a = []
    return (
      ht(t, (s) => {
        const o = { before: [], lines: [], after: [] },
          r = Mp(i, s)
        pi(o.before, zi(wn(r, 'beforeLabel', this, s))),
          pi(o.lines, wn(r, 'label', this, s)),
          pi(o.after, zi(wn(r, 'afterLabel', this, s))),
          a.push(o)
      }),
      a
    )
  }
  getAfterBody(t, n) {
    return Cp(wn(n.callbacks, 'afterBody', this, t))
  }
  getFooter(t, n) {
    const { callbacks: i } = n,
      a = wn(i, 'beforeFooter', this, t),
      s = wn(i, 'footer', this, t),
      o = wn(i, 'afterFooter', this, t)
    let r = []
    return (r = pi(r, zi(a))), (r = pi(r, zi(s))), (r = pi(r, zi(o))), r
  }
  _createItems(t) {
    const n = this._active,
      i = this.chart.data,
      a = [],
      s = [],
      o = []
    let r = [],
      l,
      c
    for (l = 0, c = n.length; l < c; ++l) r.push(G4(this.chart, n[l]))
    return (
      t.filter && (r = r.filter((u, d, f) => t.filter(u, d, f, i))),
      t.itemSort && (r = r.sort((u, d) => t.itemSort(u, d, i))),
      ht(r, (u) => {
        const d = Mp(t.callbacks, u)
        a.push(wn(d, 'labelColor', this, u)),
          s.push(wn(d, 'labelPointStyle', this, u)),
          o.push(wn(d, 'labelTextColor', this, u))
      }),
      (this.labelColors = a),
      (this.labelPointStyles = s),
      (this.labelTextColors = o),
      (this.dataPoints = r),
      r
    )
  }
  update(t, n) {
    const i = this.options.setContext(this.getContext()),
      a = this._active
    let s,
      o = []
    if (!a.length) this.opacity !== 0 && (s = { opacity: 0 })
    else {
      const r = Ko[i.position].call(this, a, this._eventPosition)
      ;(o = this._createItems(i)),
        (this.title = this.getTitle(o, i)),
        (this.beforeBody = this.getBeforeBody(o, i)),
        (this.body = this.getBody(o, i)),
        (this.afterBody = this.getAfterBody(o, i)),
        (this.footer = this.getFooter(o, i))
      const l = (this._size = wp(this, i)),
        c = Object.assign({}, r, l),
        u = Sp(this.chart, i, c),
        d = kp(i, c, u, this.chart)
      ;(this.xAlign = u.xAlign),
        (this.yAlign = u.yAlign),
        (s = { opacity: 1, x: d.x, y: d.y, width: l.width, height: l.height, caretX: r.x, caretY: r.y })
    }
    ;(this._tooltipItems = o),
      (this.$context = void 0),
      s && this._resolveAnimations().update(this, s),
      t && i.external && i.external.call(this, { chart: this.chart, tooltip: this, replay: n })
  }
  drawCaret(t, n, i, a) {
    const s = this.getCaretPosition(t, i, a)
    n.lineTo(s.x1, s.y1), n.lineTo(s.x2, s.y2), n.lineTo(s.x3, s.y3)
  }
  getCaretPosition(t, n, i) {
    const { xAlign: a, yAlign: s } = this,
      { caretSize: o, cornerRadius: r } = i,
      { topLeft: l, topRight: c, bottomLeft: u, bottomRight: d } = cs(r),
      { x: f, y: h } = t,
      { width: v, height: g } = n
    let p, y, b, x, w, C
    return (
      s === 'center'
        ? ((w = h + g / 2),
          a === 'left'
            ? ((p = f), (y = p - o), (x = w + o), (C = w - o))
            : ((p = f + v), (y = p + o), (x = w - o), (C = w + o)),
          (b = p))
        : (a === 'left'
            ? (y = f + Math.max(l, u) + o)
            : a === 'right'
            ? (y = f + v - Math.max(c, d) - o)
            : (y = this.caretX),
          s === 'top'
            ? ((x = h), (w = x - o), (p = y - o), (b = y + o))
            : ((x = h + g), (w = x + o), (p = y + o), (b = y - o)),
          (C = x)),
      { x1: p, x2: y, x3: b, y1: x, y2: w, y3: C }
    )
  }
  drawTitle(t, n, i) {
    const a = this.title,
      s = a.length
    let o, r, l
    if (s) {
      const c = Gs(i.rtl, this.x, this.width)
      for (
        t.x = El(this, i.titleAlign, i),
          n.textAlign = c.textAlign(i.titleAlign),
          n.textBaseline = 'middle',
          o = jt(i.titleFont),
          r = i.titleSpacing,
          n.fillStyle = i.titleColor,
          n.font = o.string,
          l = 0;
        l < s;
        ++l
      )
        n.fillText(a[l], c.x(t.x), t.y + o.lineHeight / 2),
          (t.y += o.lineHeight + r),
          l + 1 === s && (t.y += i.titleMarginBottom - r)
    }
  }
  _drawColorBox(t, n, i, a, s) {
    const o = this.labelColors[i],
      r = this.labelPointStyles[i],
      { boxHeight: l, boxWidth: c } = s,
      u = jt(s.bodyFont),
      d = El(this, 'left', s),
      f = a.x(d),
      h = l < u.lineHeight ? (u.lineHeight - l) / 2 : 0,
      v = n.y + h
    if (s.usePointStyle) {
      const g = {
          radius: Math.min(c, l) / 2,
          pointStyle: r.pointStyle,
          rotation: r.rotation,
          borderWidth: 1
        },
        p = a.leftForLtr(f, c) + c / 2,
        y = v + l / 2
      ;(t.strokeStyle = s.multiKeyBackground),
        (t.fillStyle = s.multiKeyBackground),
        Kd(t, g, p, y),
        (t.strokeStyle = o.borderColor),
        (t.fillStyle = o.backgroundColor),
        Kd(t, g, p, y)
    } else {
      ;(t.lineWidth = at(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1),
        (t.strokeStyle = o.borderColor),
        t.setLineDash(o.borderDash || []),
        (t.lineDashOffset = o.borderDashOffset || 0)
      const g = a.leftForLtr(f, c),
        p = a.leftForLtr(a.xPlus(f, 1), c - 2),
        y = cs(o.borderRadius)
      Object.values(y).some((b) => b !== 0)
        ? (t.beginPath(),
          (t.fillStyle = s.multiKeyBackground),
          Fr(t, { x: g, y: v, w: c, h: l, radius: y }),
          t.fill(),
          t.stroke(),
          (t.fillStyle = o.backgroundColor),
          t.beginPath(),
          Fr(t, { x: p, y: v + 1, w: c - 2, h: l - 2, radius: y }),
          t.fill())
        : ((t.fillStyle = s.multiKeyBackground),
          t.fillRect(g, v, c, l),
          t.strokeRect(g, v, c, l),
          (t.fillStyle = o.backgroundColor),
          t.fillRect(p, v + 1, c - 2, l - 2))
    }
    t.fillStyle = this.labelTextColors[i]
  }
  drawBody(t, n, i) {
    const { body: a } = this,
      { bodySpacing: s, bodyAlign: o, displayColors: r, boxHeight: l, boxWidth: c, boxPadding: u } = i,
      d = jt(i.bodyFont)
    let f = d.lineHeight,
      h = 0
    const v = Gs(i.rtl, this.x, this.width),
      g = function (S) {
        n.fillText(S, v.x(t.x + h), t.y + f / 2), (t.y += f + s)
      },
      p = v.textAlign(o)
    let y, b, x, w, C, P, k
    for (
      n.textAlign = o,
        n.textBaseline = 'middle',
        n.font = d.string,
        t.x = El(this, p, i),
        n.fillStyle = i.bodyColor,
        ht(this.beforeBody, g),
        h = r && p !== 'right' ? (o === 'center' ? c / 2 + u : c + 2 + u) : 0,
        w = 0,
        P = a.length;
      w < P;
      ++w
    ) {
      for (
        y = a[w],
          b = this.labelTextColors[w],
          n.fillStyle = b,
          ht(y.before, g),
          x = y.lines,
          r && x.length && (this._drawColorBox(n, t, w, v, i), (f = Math.max(d.lineHeight, l))),
          C = 0,
          k = x.length;
        C < k;
        ++C
      )
        g(x[C]), (f = d.lineHeight)
      ht(y.after, g)
    }
    ;(h = 0), (f = d.lineHeight), ht(this.afterBody, g), (t.y -= s)
  }
  drawFooter(t, n, i) {
    const a = this.footer,
      s = a.length
    let o, r
    if (s) {
      const l = Gs(i.rtl, this.x, this.width)
      for (
        t.x = El(this, i.footerAlign, i),
          t.y += i.footerMarginTop,
          n.textAlign = l.textAlign(i.footerAlign),
          n.textBaseline = 'middle',
          o = jt(i.footerFont),
          n.fillStyle = i.footerColor,
          n.font = o.string,
          r = 0;
        r < s;
        ++r
      )
        n.fillText(a[r], l.x(t.x), t.y + o.lineHeight / 2), (t.y += o.lineHeight + i.footerSpacing)
    }
  }
  drawBackground(t, n, i, a) {
    const { xAlign: s, yAlign: o } = this,
      { x: r, y: l } = t,
      { width: c, height: u } = i,
      { topLeft: d, topRight: f, bottomLeft: h, bottomRight: v } = cs(a.cornerRadius)
    ;(n.fillStyle = a.backgroundColor),
      (n.strokeStyle = a.borderColor),
      (n.lineWidth = a.borderWidth),
      n.beginPath(),
      n.moveTo(r + d, l),
      o === 'top' && this.drawCaret(t, n, i, a),
      n.lineTo(r + c - f, l),
      n.quadraticCurveTo(r + c, l, r + c, l + f),
      o === 'center' && s === 'right' && this.drawCaret(t, n, i, a),
      n.lineTo(r + c, l + u - v),
      n.quadraticCurveTo(r + c, l + u, r + c - v, l + u),
      o === 'bottom' && this.drawCaret(t, n, i, a),
      n.lineTo(r + h, l + u),
      n.quadraticCurveTo(r, l + u, r, l + u - h),
      o === 'center' && s === 'left' && this.drawCaret(t, n, i, a),
      n.lineTo(r, l + d),
      n.quadraticCurveTo(r, l, r + d, l),
      n.closePath(),
      n.fill(),
      a.borderWidth > 0 && n.stroke()
  }
  _updateAnimationTarget(t) {
    const n = this.chart,
      i = this.$animations,
      a = i && i.x,
      s = i && i.y
    if (a || s) {
      const o = Ko[t.position].call(this, this._active, this._eventPosition)
      if (!o) return
      const r = (this._size = wp(this, t)),
        l = Object.assign({}, o, this._size),
        c = Sp(n, t, l),
        u = kp(t, l, c, n)
      ;(a._to !== u.x || s._to !== u.y) &&
        ((this.xAlign = c.xAlign),
        (this.yAlign = c.yAlign),
        (this.width = r.width),
        (this.height = r.height),
        (this.caretX = o.x),
        (this.caretY = o.y),
        this._resolveAnimations().update(this, u))
    }
  }
  _willRender() {
    return !!this.opacity
  }
  draw(t) {
    const n = this.options.setContext(this.getContext())
    let i = this.opacity
    if (!i) return
    this._updateAnimationTarget(n)
    const a = { width: this.width, height: this.height },
      s = { x: this.x, y: this.y }
    i = Math.abs(i) < 0.001 ? 0 : i
    const o = fn(n.padding),
      r =
        this.title.length ||
        this.beforeBody.length ||
        this.body.length ||
        this.afterBody.length ||
        this.footer.length
    n.enabled &&
      r &&
      (t.save(),
      (t.globalAlpha = i),
      this.drawBackground(s, t, a, n),
      T_(t, n.textDirection),
      (s.y += o.top),
      this.drawTitle(s, t, n),
      this.drawBody(s, t, n),
      this.drawFooter(s, t, n),
      V_(t, n.textDirection),
      t.restore())
  }
  getActiveElements() {
    return this._active || []
  }
  setActiveElements(t, n) {
    const i = this._active,
      a = t.map(({ datasetIndex: r, index: l }) => {
        const c = this.chart.getDatasetMeta(r)
        if (!c) throw new Error('Cannot find a dataset at index ' + r)
        return { datasetIndex: r, element: c.data[l], index: l }
      }),
      s = !mc(i, a),
      o = this._positionChanged(a, n)
    ;(s || o) &&
      ((this._active = a), (this._eventPosition = n), (this._ignoreReplayEvents = !0), this.update(!0))
  }
  handleEvent(t, n, i = !0) {
    if (n && this._ignoreReplayEvents) return !1
    this._ignoreReplayEvents = !1
    const a = this.options,
      s = this._active || [],
      o = this._getActiveElements(t, s, n, i),
      r = this._positionChanged(o, t),
      l = n || !mc(o, s) || r
    return (
      l &&
        ((this._active = o),
        (a.enabled || a.external) && ((this._eventPosition = { x: t.x, y: t.y }), this.update(!0, n))),
      l
    )
  }
  _getActiveElements(t, n, i, a) {
    const s = this.options
    if (t.type === 'mouseout') return []
    if (!a) return n
    const o = this.chart.getElementsAtEventForMode(t, s.mode, s, i)
    return s.reverse && o.reverse(), o
  }
  _positionChanged(t, n) {
    const { caretX: i, caretY: a, options: s } = this,
      o = Ko[s.position].call(this, t, n)
    return o !== !1 && (i !== o.x || a !== o.y)
  }
}
ke(nf, 'positioners', Ko)
var eB = {
    id: 'tooltip',
    _element: nf,
    positioners: Ko,
    afterInit(e, t, n) {
      n && (e.tooltip = new nf({ chart: e, options: n }))
    },
    beforeUpdate(e, t, n) {
      e.tooltip && e.tooltip.initialize(n)
    },
    reset(e, t, n) {
      e.tooltip && e.tooltip.initialize(n)
    },
    afterDraw(e) {
      const t = e.tooltip
      if (t && t._willRender()) {
        const n = { tooltip: t }
        if (e.notifyPlugins('beforeTooltipDraw', { ...n, cancelable: !0 }) === !1) return
        t.draw(e.ctx), e.notifyPlugins('afterTooltipDraw', n)
      }
    },
    afterEvent(e, t) {
      if (e.tooltip) {
        const n = t.replay
        e.tooltip.handleEvent(t.event, n, t.inChartArea) && (t.changed = !0)
      }
    },
    defaults: {
      enabled: !0,
      external: null,
      position: 'average',
      backgroundColor: 'rgba(0,0,0,0.8)',
      titleColor: '#fff',
      titleFont: { weight: 'bold' },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: 'left',
      bodyColor: '#fff',
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: 'left',
      footerColor: '#fff',
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: { weight: 'bold' },
      footerAlign: 'left',
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (e, t) => t.bodyFont.size,
      boxWidth: (e, t) => t.bodyFont.size,
      multiKeyBackground: '#fff',
      displayColors: !0,
      boxPadding: 0,
      borderColor: 'rgba(0,0,0,0)',
      borderWidth: 0,
      animation: { duration: 400, easing: 'easeOutQuart' },
      animations: {
        numbers: { type: 'number', properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'] },
        opacity: { easing: 'linear', duration: 200 }
      },
      callbacks: tx
    },
    defaultRoutes: { bodyFont: 'font', footerFont: 'font', titleFont: 'font' },
    descriptors: {
      _scriptable: (e) => e !== 'filter' && e !== 'itemSort' && e !== 'external',
      _indexable: !1,
      callbacks: { _scriptable: !1, _indexable: !1 },
      animation: { _fallback: !1 },
      animations: { _fallback: 'animation' }
    },
    additionalOptionScopes: ['interaction']
  },
  tB = Object.freeze({
    __proto__: null,
    Colors: h4,
    Decimation: p4,
    Filler: R4,
    Legend: W4,
    SubTitle: Y4,
    Title: U4,
    Tooltip: eB
  })
const nB = (e, t, n, i) => (
  typeof t == 'string' ? ((n = e.push(t) - 1), i.unshift({ index: n, label: t })) : isNaN(t) && (n = null), n
)
function iB(e, t, n, i) {
  const a = e.indexOf(t)
  if (a === -1) return nB(e, t, n, i)
  const s = e.lastIndexOf(t)
  return a !== s ? n : a
}
const aB = (e, t) => (e === null ? null : Zt(Math.round(e), 0, t))
function Ap(e) {
  const t = this.getLabels()
  return e >= 0 && e < t.length ? t[e] : e
}
class af extends Ms {
  constructor(t) {
    super(t), (this._startValue = void 0), (this._valueRange = 0), (this._addedLabels = [])
  }
  init(t) {
    const n = this._addedLabels
    if (n.length) {
      const i = this.getLabels()
      for (const { index: a, label: s } of n) i[a] === s && i.splice(a, 1)
      this._addedLabels = []
    }
    super.init(t)
  }
  parse(t, n) {
    if (lt(t)) return null
    const i = this.getLabels()
    return (n = isFinite(n) && i[n] === t ? n : iB(i, t, Ze(n, t), this._addedLabels)), aB(n, i.length - 1)
  }
  determineDataLimits() {
    const { minDefined: t, maxDefined: n } = this.getUserBounds()
    let { min: i, max: a } = this.getMinMax(!0)
    this.options.bounds === 'ticks' && (t || (i = 0), n || (a = this.getLabels().length - 1)),
      (this.min = i),
      (this.max = a)
  }
  buildTicks() {
    const t = this.min,
      n = this.max,
      i = this.options.offset,
      a = []
    let s = this.getLabels()
    ;(s = t === 0 && n === s.length - 1 ? s : s.slice(t, n + 1)),
      (this._valueRange = Math.max(s.length - (i ? 0 : 1), 1)),
      (this._startValue = this.min - (i ? 0.5 : 0))
    for (let o = t; o <= n; o++) a.push({ value: o })
    return a
  }
  getLabelForValue(t) {
    return Ap.call(this, t)
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels)
  }
  getPixelForValue(t) {
    return (
      typeof t != 'number' && (t = this.parse(t)),
      t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
    )
  }
  getPixelForTick(t) {
    const n = this.ticks
    return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value)
  }
  getValueForPixel(t) {
    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange)
  }
  getBasePixel() {
    return this.bottom
  }
}
ke(af, 'id', 'category'), ke(af, 'defaults', { ticks: { callback: Ap } })
function sB(e, t) {
  const n = [],
    {
      bounds: a,
      step: s,
      min: o,
      max: r,
      precision: l,
      count: c,
      maxTicks: u,
      maxDigits: d,
      includeBounds: f
    } = e,
    h = s || 1,
    v = u - 1,
    { min: g, max: p } = t,
    y = !lt(o),
    b = !lt(r),
    x = !lt(c),
    w = (p - g) / (d + 1)
  let C = xm((p - g) / v / h) * h,
    P,
    k,
    S,
    _
  if (C < 1e-14 && !y && !b) return [{ value: g }, { value: p }]
  ;(_ = Math.ceil(p / C) - Math.floor(g / C)),
    _ > v && (C = xm((_ * C) / v / h) * h),
    lt(l) || ((P = Math.pow(10, l)), (C = Math.ceil(C * P) / P)),
    a === 'ticks' ? ((k = Math.floor(g / C) * C), (S = Math.ceil(p / C) * C)) : ((k = g), (S = p)),
    y && b && s && QD((r - o) / s, C / 1e3)
      ? ((_ = Math.round(Math.min((r - o) / C, u))), (C = (r - o) / _), (k = o), (S = r))
      : x
      ? ((k = y ? o : k), (S = b ? r : S), (_ = c - 1), (C = (S - k) / _))
      : ((_ = (S - k) / C), lr(_, Math.round(_), C / 1e3) ? (_ = Math.round(_)) : (_ = Math.ceil(_)))
  const T = Math.max(wm(C), wm(k))
  ;(P = Math.pow(10, lt(l) ? T : l)), (k = Math.round(k * P) / P), (S = Math.round(S * P) / P)
  let B = 0
  for (
    y &&
    (f && k !== o
      ? (n.push({ value: o }), k < o && B++, lr(Math.round((k + B * C) * P) / P, o, Pp(o, w, e)) && B++)
      : k < o && B++);
    B < _;
    ++B
  ) {
    const O = Math.round((k + B * C) * P) / P
    if (b && O > r) break
    n.push({ value: O })
  }
  return (
    b && f && S !== r
      ? n.length && lr(n[n.length - 1].value, r, Pp(r, w, e))
        ? (n[n.length - 1].value = r)
        : n.push({ value: r })
      : (!b || S === r) && n.push({ value: S }),
    n
  )
}
function Pp(e, t, { horizontal: n, minRotation: i }) {
  const a = oi(i),
    s = (n ? Math.sin(a) : Math.cos(a)) || 0.001,
    o = 0.75 * t * ('' + e).length
  return Math.min(t / s, o)
}
class Sc extends Ms {
  constructor(t) {
    super(t),
      (this.start = void 0),
      (this.end = void 0),
      (this._startValue = void 0),
      (this._endValue = void 0),
      (this._valueRange = 0)
  }
  parse(t, n) {
    return lt(t) || ((typeof t == 'number' || t instanceof Number) && !isFinite(+t)) ? null : +t
  }
  handleTickRangeOptions() {
    const { beginAtZero: t } = this.options,
      { minDefined: n, maxDefined: i } = this.getUserBounds()
    let { min: a, max: s } = this
    const o = (l) => (a = n ? a : l),
      r = (l) => (s = i ? s : l)
    if (t) {
      const l = Ai(a),
        c = Ai(s)
      l < 0 && c < 0 ? r(0) : l > 0 && c > 0 && o(0)
    }
    if (a === s) {
      let l = s === 0 ? 1 : Math.abs(s * 0.05)
      r(s + l), t || o(a - l)
    }
    ;(this.min = a), (this.max = s)
  }
  getTickLimit() {
    const t = this.options.ticks
    let { maxTicksLimit: n, stepSize: i } = t,
      a
    return (
      i
        ? ((a = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1),
          a > 1e3 &&
            (console.warn(
              `scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${a} ticks. Limiting to 1000.`
            ),
            (a = 1e3)))
        : ((a = this.computeTickLimit()), (n = n || 11)),
      n && (a = Math.min(n, a)),
      a
    )
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY
  }
  buildTicks() {
    const t = this.options,
      n = t.ticks
    let i = this.getTickLimit()
    i = Math.max(2, i)
    const a = {
        maxTicks: i,
        bounds: t.bounds,
        min: t.min,
        max: t.max,
        precision: n.precision,
        step: n.stepSize,
        count: n.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: n.minRotation || 0,
        includeBounds: n.includeBounds !== !1
      },
      s = this._range || this,
      o = sB(a, s)
    return (
      t.bounds === 'ticks' && d_(o, this, 'value'),
      t.reverse
        ? (o.reverse(), (this.start = this.max), (this.end = this.min))
        : ((this.start = this.min), (this.end = this.max)),
      o
    )
  }
  configure() {
    const t = this.ticks
    let n = this.min,
      i = this.max
    if ((super.configure(), this.options.offset && t.length)) {
      const a = (i - n) / Math.max(t.length - 1, 1) / 2
      ;(n -= a), (i += a)
    }
    ;(this._startValue = n), (this._endValue = i), (this._valueRange = i - n)
  }
  getLabelForValue(t) {
    return Jr(t, this.chart.options.locale, this.options.ticks.format)
  }
}
class sf extends Sc {
  determineDataLimits() {
    const { min: t, max: n } = this.getMinMax(!0)
    ;(this.min = It(t) ? t : 0), (this.max = It(n) ? n : 1), this.handleTickRangeOptions()
  }
  computeTickLimit() {
    const t = this.isHorizontal(),
      n = t ? this.width : this.height,
      i = oi(this.options.ticks.minRotation),
      a = (t ? Math.sin(i) : Math.cos(i)) || 0.001,
      s = this._resolveTickFontOptions(0)
    return Math.ceil(n / Math.min(40, s.lineHeight / a))
  }
  getPixelForValue(t) {
    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange
  }
}
ke(sf, 'id', 'linear'), ke(sf, 'defaults', { ticks: { callback: iu.formatters.numeric } })
const Br = (e) => Math.floor(_a(e)),
  Xa = (e, t) => Math.pow(10, Br(e) + t)
function Tp(e) {
  return e / Math.pow(10, Br(e)) === 1
}
function Vp(e, t, n) {
  const i = Math.pow(10, n),
    a = Math.floor(e / i)
  return Math.ceil(t / i) - a
}
function oB(e, t) {
  const n = t - e
  let i = Br(n)
  for (; Vp(e, t, i) > 10; ) i++
  for (; Vp(e, t, i) < 10; ) i--
  return Math.min(i, Br(e))
}
function rB(e, { min: t, max: n }) {
  t = Tn(e.min, t)
  const i = [],
    a = Br(t)
  let s = oB(t, n),
    o = s < 0 ? Math.pow(10, Math.abs(s)) : 1
  const r = Math.pow(10, s),
    l = a > s ? Math.pow(10, a) : 0,
    c = Math.round((t - l) * o) / o,
    u = Math.floor((t - l) / r / 10) * r * 10
  let d = Math.floor((c - u) / Math.pow(10, s)),
    f = Tn(e.min, Math.round((l + u + d * Math.pow(10, s)) * o) / o)
  for (; f < n; )
    i.push({ value: f, major: Tp(f), significand: d }),
      d >= 10 ? (d = d < 15 ? 15 : 20) : d++,
      d >= 20 && (s++, (d = 2), (o = s >= 0 ? 1 : o)),
      (f = Math.round((l + u + d * Math.pow(10, s)) * o) / o)
  const h = Tn(e.max, f)
  return i.push({ value: h, major: Tp(h), significand: d }), i
}
class of extends Ms {
  constructor(t) {
    super(t), (this.start = void 0), (this.end = void 0), (this._startValue = void 0), (this._valueRange = 0)
  }
  parse(t, n) {
    const i = Sc.prototype.parse.apply(this, [t, n])
    if (i === 0) {
      this._zero = !0
      return
    }
    return It(i) && i > 0 ? i : null
  }
  determineDataLimits() {
    const { min: t, max: n } = this.getMinMax(!0)
    ;(this.min = It(t) ? Math.max(0, t) : null),
      (this.max = It(n) ? Math.max(0, n) : null),
      this.options.beginAtZero && (this._zero = !0),
      this._zero &&
        this.min !== this._suggestedMin &&
        !It(this._userMin) &&
        (this.min = t === Xa(this.min, 0) ? Xa(this.min, -1) : Xa(this.min, 0)),
      this.handleTickRangeOptions()
  }
  handleTickRangeOptions() {
    const { minDefined: t, maxDefined: n } = this.getUserBounds()
    let i = this.min,
      a = this.max
    const s = (r) => (i = t ? i : r),
      o = (r) => (a = n ? a : r)
    i === a && (i <= 0 ? (s(1), o(10)) : (s(Xa(i, -1)), o(Xa(a, 1)))),
      i <= 0 && s(Xa(a, -1)),
      a <= 0 && o(Xa(i, 1)),
      (this.min = i),
      (this.max = a)
  }
  buildTicks() {
    const t = this.options,
      n = { min: this._userMin, max: this._userMax },
      i = rB(n, this)
    return (
      t.bounds === 'ticks' && d_(i, this, 'value'),
      t.reverse
        ? (i.reverse(), (this.start = this.max), (this.end = this.min))
        : ((this.start = this.min), (this.end = this.max)),
      i
    )
  }
  getLabelForValue(t) {
    return t === void 0 ? '0' : Jr(t, this.chart.options.locale, this.options.ticks.format)
  }
  configure() {
    const t = this.min
    super.configure(), (this._startValue = _a(t)), (this._valueRange = _a(this.max) - _a(t))
  }
  getPixelForValue(t) {
    return (
      (t === void 0 || t === 0) && (t = this.min),
      t === null || isNaN(t)
        ? NaN
        : this.getPixelForDecimal(t === this.min ? 0 : (_a(t) - this._startValue) / this._valueRange)
    )
  }
  getValueForPixel(t) {
    const n = this.getDecimalForPixel(t)
    return Math.pow(10, this._startValue + n * this._valueRange)
  }
}
ke(of, 'id', 'logarithmic'),
  ke(of, 'defaults', { ticks: { callback: iu.formatters.logarithmic, major: { enabled: !0 } } })
function rf(e) {
  const t = e.ticks
  if (t.display && e.display) {
    const n = fn(t.backdropPadding)
    return Ze(t.font && t.font.size, Dt.font.size) + n.height
  }
  return 0
}
function lB(e, t, n) {
  return (n = xt(n) ? n : [n]), { w: mF(e, t.string, n), h: n.length * t.lineHeight }
}
function Ep(e, t, n, i, a) {
  return e === i || e === a
    ? { start: t - n / 2, end: t + n / 2 }
    : e < i || e > a
    ? { start: t - n, end: t }
    : { start: t, end: t + n }
}
function cB(e) {
  const t = {
      l: e.left + e._padding.left,
      r: e.right - e._padding.right,
      t: e.top + e._padding.top,
      b: e.bottom - e._padding.bottom
    },
    n = Object.assign({}, t),
    i = [],
    a = [],
    s = e._pointLabels.length,
    o = e.options.pointLabels,
    r = o.centerPointLabels ? St / s : 0
  for (let l = 0; l < s; l++) {
    const c = o.setContext(e.getPointLabelContext(l))
    a[l] = c.padding
    const u = e.getPointPosition(l, e.drawingArea + a[l], r),
      d = jt(c.font),
      f = lB(e.ctx, d, e._pointLabels[l])
    i[l] = f
    const h = En(e.getIndexAngle(l) + r),
      v = Math.round(Vh(h)),
      g = Ep(v, u.x, f.w, 0, 180),
      p = Ep(v, u.y, f.h, 90, 270)
    uB(n, t, h, g, p)
  }
  e.setCenterPoint(t.l - n.l, n.r - t.r, t.t - n.t, n.b - t.b), (e._pointLabelItems = hB(e, i, a))
}
function uB(e, t, n, i, a) {
  const s = Math.abs(Math.sin(n)),
    o = Math.abs(Math.cos(n))
  let r = 0,
    l = 0
  i.start < t.l
    ? ((r = (t.l - i.start) / s), (e.l = Math.min(e.l, t.l - r)))
    : i.end > t.r && ((r = (i.end - t.r) / s), (e.r = Math.max(e.r, t.r + r))),
    a.start < t.t
      ? ((l = (t.t - a.start) / o), (e.t = Math.min(e.t, t.t - l)))
      : a.end > t.b && ((l = (a.end - t.b) / o), (e.b = Math.max(e.b, t.b + l)))
}
function dB(e, t, n) {
  const i = e.drawingArea,
    { extra: a, additionalAngle: s, padding: o, size: r } = n,
    l = e.getPointPosition(t, i + a + o, s),
    c = Math.round(Vh(En(l.angle + Bt))),
    u = mB(l.y, r.h, c),
    d = vB(c),
    f = gB(l.x, r.w, d)
  return { visible: !0, x: l.x, y: u, textAlign: d, left: f, top: u, right: f + r.w, bottom: u + r.h }
}
function fB(e, t) {
  if (!t) return !0
  const { left: n, top: i, right: a, bottom: s } = e
  return !(Gi({ x: n, y: i }, t) || Gi({ x: n, y: s }, t) || Gi({ x: a, y: i }, t) || Gi({ x: a, y: s }, t))
}
function hB(e, t, n) {
  const i = [],
    a = e._pointLabels.length,
    s = e.options,
    { centerPointLabels: o, display: r } = s.pointLabels,
    l = { extra: rf(s) / 2, additionalAngle: o ? St / a : 0 }
  let c
  for (let u = 0; u < a; u++) {
    ;(l.padding = n[u]), (l.size = t[u])
    const d = dB(e, u, l)
    i.push(d), r === 'auto' && ((d.visible = fB(d, c)), d.visible && (c = d))
  }
  return i
}
function vB(e) {
  return e === 0 || e === 180 ? 'center' : e < 180 ? 'left' : 'right'
}
function gB(e, t, n) {
  return n === 'right' ? (e -= t) : n === 'center' && (e -= t / 2), e
}
function mB(e, t, n) {
  return n === 90 || n === 270 ? (e -= t / 2) : (n > 270 || n < 90) && (e -= t), e
}
function pB(e, t, n) {
  const { left: i, top: a, right: s, bottom: o } = n,
    { backdropColor: r } = t
  if (!lt(r)) {
    const l = cs(t.borderRadius),
      c = fn(t.backdropPadding)
    e.fillStyle = r
    const u = i - c.left,
      d = a - c.top,
      f = s - i + c.width,
      h = o - a + c.height
    Object.values(l).some((v) => v !== 0)
      ? (e.beginPath(), Fr(e, { x: u, y: d, w: f, h, radius: l }), e.fill())
      : e.fillRect(u, d, f, h)
  }
}
function yB(e, t) {
  const {
    ctx: n,
    options: { pointLabels: i }
  } = e
  for (let a = t - 1; a >= 0; a--) {
    const s = e._pointLabelItems[a]
    if (!s.visible) continue
    const o = i.setContext(e.getPointLabelContext(a))
    pB(n, o, s)
    const r = jt(o.font),
      { x: l, y: c, textAlign: u } = s
    ps(n, e._pointLabels[a], l, c + r.lineHeight / 2, r, {
      color: o.color,
      textAlign: u,
      textBaseline: 'middle'
    })
  }
}
function nx(e, t, n, i) {
  const { ctx: a } = e
  if (n) a.arc(e.xCenter, e.yCenter, t, 0, wt)
  else {
    let s = e.getPointPosition(0, t)
    a.moveTo(s.x, s.y)
    for (let o = 1; o < i; o++) (s = e.getPointPosition(o, t)), a.lineTo(s.x, s.y)
  }
}
function bB(e, t, n, i, a) {
  const s = e.ctx,
    o = t.circular,
    { color: r, lineWidth: l } = t
  ;(!o && !i) ||
    !r ||
    !l ||
    n < 0 ||
    (s.save(),
    (s.strokeStyle = r),
    (s.lineWidth = l),
    s.setLineDash(a.dash),
    (s.lineDashOffset = a.dashOffset),
    s.beginPath(),
    nx(e, n, o, i),
    s.closePath(),
    s.stroke(),
    s.restore())
}
function _B(e, t, n) {
  return Ba(e, { label: n, index: t, type: 'pointLabel' })
}
class qo extends Sc {
  constructor(t) {
    super(t),
      (this.xCenter = void 0),
      (this.yCenter = void 0),
      (this.drawingArea = void 0),
      (this._pointLabels = []),
      (this._pointLabelItems = [])
  }
  setDimensions() {
    const t = (this._padding = fn(rf(this.options) / 2)),
      n = (this.width = this.maxWidth - t.width),
      i = (this.height = this.maxHeight - t.height)
    ;(this.xCenter = Math.floor(this.left + n / 2 + t.left)),
      (this.yCenter = Math.floor(this.top + i / 2 + t.top)),
      (this.drawingArea = Math.floor(Math.min(n, i) / 2))
  }
  determineDataLimits() {
    const { min: t, max: n } = this.getMinMax(!1)
    ;(this.min = It(t) && !isNaN(t) ? t : 0),
      (this.max = It(n) && !isNaN(n) ? n : 0),
      this.handleTickRangeOptions()
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / rf(this.options))
  }
  generateTickLabels(t) {
    Sc.prototype.generateTickLabels.call(this, t),
      (this._pointLabels = this.getLabels()
        .map((n, i) => {
          const a = pt(this.options.pointLabels.callback, [n, i], this)
          return a || a === 0 ? a : ''
        })
        .filter((n, i) => this.chart.getDataVisibility(i)))
  }
  fit() {
    const t = this.options
    t.display && t.pointLabels.display ? cB(this) : this.setCenterPoint(0, 0, 0, 0)
  }
  setCenterPoint(t, n, i, a) {
    ;(this.xCenter += Math.floor((t - n) / 2)),
      (this.yCenter += Math.floor((i - a) / 2)),
      (this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, n, i, a)))
  }
  getIndexAngle(t) {
    const n = wt / (this._pointLabels.length || 1),
      i = this.options.startAngle || 0
    return En(t * n + oi(i))
  }
  getDistanceFromCenterForValue(t) {
    if (lt(t)) return NaN
    const n = this.drawingArea / (this.max - this.min)
    return this.options.reverse ? (this.max - t) * n : (t - this.min) * n
  }
  getValueForDistanceFromCenter(t) {
    if (lt(t)) return NaN
    const n = t / (this.drawingArea / (this.max - this.min))
    return this.options.reverse ? this.max - n : this.min + n
  }
  getPointLabelContext(t) {
    const n = this._pointLabels || []
    if (t >= 0 && t < n.length) {
      const i = n[t]
      return _B(this.getContext(), t, i)
    }
  }
  getPointPosition(t, n, i = 0) {
    const a = this.getIndexAngle(t) - Bt + i
    return { x: Math.cos(a) * n + this.xCenter, y: Math.sin(a) * n + this.yCenter, angle: a }
  }
  getPointPositionForValue(t, n) {
    return this.getPointPosition(t, this.getDistanceFromCenterForValue(n))
  }
  getBasePosition(t) {
    return this.getPointPositionForValue(t || 0, this.getBaseValue())
  }
  getPointLabelPosition(t) {
    const { left: n, top: i, right: a, bottom: s } = this._pointLabelItems[t]
    return { left: n, top: i, right: a, bottom: s }
  }
  drawBackground() {
    const {
      backgroundColor: t,
      grid: { circular: n }
    } = this.options
    if (t) {
      const i = this.ctx
      i.save(),
        i.beginPath(),
        nx(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length),
        i.closePath(),
        (i.fillStyle = t),
        i.fill(),
        i.restore()
    }
  }
  drawGrid() {
    const t = this.ctx,
      n = this.options,
      { angleLines: i, grid: a, border: s } = n,
      o = this._pointLabels.length
    let r, l, c
    if (
      (n.pointLabels.display && yB(this, o),
      a.display &&
        this.ticks.forEach((u, d) => {
          if (d !== 0) {
            l = this.getDistanceFromCenterForValue(u.value)
            const f = this.getContext(d),
              h = a.setContext(f),
              v = s.setContext(f)
            bB(this, h, l, o, v)
          }
        }),
      i.display)
    ) {
      for (t.save(), r = o - 1; r >= 0; r--) {
        const u = i.setContext(this.getPointLabelContext(r)),
          { color: d, lineWidth: f } = u
        !f ||
          !d ||
          ((t.lineWidth = f),
          (t.strokeStyle = d),
          t.setLineDash(u.borderDash),
          (t.lineDashOffset = u.borderDashOffset),
          (l = this.getDistanceFromCenterForValue(n.ticks.reverse ? this.min : this.max)),
          (c = this.getPointPosition(r, l)),
          t.beginPath(),
          t.moveTo(this.xCenter, this.yCenter),
          t.lineTo(c.x, c.y),
          t.stroke())
      }
      t.restore()
    }
  }
  drawBorder() {}
  drawLabels() {
    const t = this.ctx,
      n = this.options,
      i = n.ticks
    if (!i.display) return
    const a = this.getIndexAngle(0)
    let s, o
    t.save(),
      t.translate(this.xCenter, this.yCenter),
      t.rotate(a),
      (t.textAlign = 'center'),
      (t.textBaseline = 'middle'),
      this.ticks.forEach((r, l) => {
        if (l === 0 && !n.reverse) return
        const c = i.setContext(this.getContext(l)),
          u = jt(c.font)
        if (((s = this.getDistanceFromCenterForValue(this.ticks[l].value)), c.showLabelBackdrop)) {
          ;(t.font = u.string), (o = t.measureText(r.label).width), (t.fillStyle = c.backdropColor)
          const d = fn(c.backdropPadding)
          t.fillRect(-o / 2 - d.left, -s - u.size / 2 - d.top, o + d.width, u.size + d.height)
        }
        ps(t, r.label, 0, -s, u, {
          color: c.color,
          strokeColor: c.textStrokeColor,
          strokeWidth: c.textStrokeWidth
        })
      }),
      t.restore()
  }
  drawTitle() {}
}
ke(qo, 'id', 'radialLinear'),
  ke(qo, 'defaults', {
    display: !0,
    animate: !0,
    position: 'chartArea',
    angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 },
    grid: { circular: !1 },
    startAngle: 0,
    ticks: { showLabelBackdrop: !0, callback: iu.formatters.numeric },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: !0,
      font: { size: 10 },
      callback(t) {
        return t
      },
      padding: 5,
      centerPointLabels: !1
    }
  }),
  ke(qo, 'defaultRoutes', {
    'angleLines.color': 'borderColor',
    'pointLabels.color': 'color',
    'ticks.color': 'color'
  }),
  ke(qo, 'descriptors', { angleLines: { _fallback: 'grid' } })
const ru = {
    millisecond: { common: !0, size: 1, steps: 1e3 },
    second: { common: !0, size: 1e3, steps: 60 },
    minute: { common: !0, size: 6e4, steps: 60 },
    hour: { common: !0, size: 36e5, steps: 24 },
    day: { common: !0, size: 864e5, steps: 30 },
    week: { common: !1, size: 6048e5, steps: 4 },
    month: { common: !0, size: 2628e6, steps: 12 },
    quarter: { common: !1, size: 7884e6, steps: 4 },
    year: { common: !0, size: 3154e7 }
  },
  kn = Object.keys(ru)
function Lp(e, t) {
  return e - t
}
function Op(e, t) {
  if (lt(t)) return null
  const n = e._adapter,
    { parser: i, round: a, isoWeekday: s } = e._parseOpts
  let o = t
  return (
    typeof i == 'function' && (o = i(o)),
    It(o) || (o = typeof i == 'string' ? n.parse(o, i) : n.parse(o)),
    o === null
      ? null
      : (a && (o = a === 'week' && (io(s) || s === !0) ? n.startOf(o, 'isoWeek', s) : n.startOf(o, a)), +o)
  )
}
function Ip(e, t, n, i) {
  const a = kn.length
  for (let s = kn.indexOf(e); s < a - 1; ++s) {
    const o = ru[kn[s]],
      r = o.steps ? o.steps : Number.MAX_SAFE_INTEGER
    if (o.common && Math.ceil((n - t) / (r * o.size)) <= i) return kn[s]
  }
  return kn[a - 1]
}
function xB(e, t, n, i, a) {
  for (let s = kn.length - 1; s >= kn.indexOf(n); s--) {
    const o = kn[s]
    if (ru[o].common && e._adapter.diff(a, i, o) >= t - 1) return o
  }
  return kn[n ? kn.indexOf(n) : 0]
}
function wB(e) {
  for (let t = kn.indexOf(e) + 1, n = kn.length; t < n; ++t) if (ru[kn[t]].common) return kn[t]
}
function Dp(e, t, n) {
  if (!n) e[t] = !0
  else if (n.length) {
    const { lo: i, hi: a } = Eh(n, t),
      s = n[i] >= t ? n[i] : n[a]
    e[s] = !0
  }
}
function SB(e, t, n, i) {
  const a = e._adapter,
    s = +a.startOf(t[0].value, i),
    o = t[t.length - 1].value
  let r, l
  for (r = s; r <= o; r = +a.add(r, 1, i)) (l = n[r]), l >= 0 && (t[l].major = !0)
  return t
}
function Fp(e, t, n) {
  const i = [],
    a = {},
    s = t.length
  let o, r
  for (o = 0; o < s; ++o) (r = t[o]), (a[r] = o), i.push({ value: r, major: !1 })
  return s === 0 || !n ? i : SB(e, i, a, n)
}
class Nr extends Ms {
  constructor(t) {
    super(t),
      (this._cache = { data: [], labels: [], all: [] }),
      (this._unit = 'day'),
      (this._majorUnit = void 0),
      (this._offsets = {}),
      (this._normalized = !1),
      (this._parseOpts = void 0)
  }
  init(t, n = {}) {
    const i = t.time || (t.time = {}),
      a = (this._adapter = new L5._date(t.adapters.date))
    a.init(n),
      rr(i.displayFormats, a.formats()),
      (this._parseOpts = { parser: i.parser, round: i.round, isoWeekday: i.isoWeekday }),
      super.init(t),
      (this._normalized = n.normalized)
  }
  parse(t, n) {
    return t === void 0 ? null : Op(this, t)
  }
  beforeLayout() {
    super.beforeLayout(), (this._cache = { data: [], labels: [], all: [] })
  }
  determineDataLimits() {
    const t = this.options,
      n = this._adapter,
      i = t.time.unit || 'day'
    let { min: a, max: s, minDefined: o, maxDefined: r } = this.getUserBounds()
    function l(c) {
      !o && !isNaN(c.min) && (a = Math.min(a, c.min)), !r && !isNaN(c.max) && (s = Math.max(s, c.max))
    }
    ;(!o || !r) &&
      (l(this._getLabelBounds()),
      (t.bounds !== 'ticks' || t.ticks.source !== 'labels') && l(this.getMinMax(!1))),
      (a = It(a) && !isNaN(a) ? a : +n.startOf(Date.now(), i)),
      (s = It(s) && !isNaN(s) ? s : +n.endOf(Date.now(), i) + 1),
      (this.min = Math.min(a, s - 1)),
      (this.max = Math.max(a + 1, s))
  }
  _getLabelBounds() {
    const t = this.getLabelTimestamps()
    let n = Number.POSITIVE_INFINITY,
      i = Number.NEGATIVE_INFINITY
    return t.length && ((n = t[0]), (i = t[t.length - 1])), { min: n, max: i }
  }
  buildTicks() {
    const t = this.options,
      n = t.time,
      i = t.ticks,
      a = i.source === 'labels' ? this.getLabelTimestamps() : this._generate()
    t.bounds === 'ticks' &&
      a.length &&
      ((this.min = this._userMin || a[0]), (this.max = this._userMax || a[a.length - 1]))
    const s = this.min,
      o = this.max,
      r = iF(a, s, o)
    return (
      (this._unit =
        n.unit ||
        (i.autoSkip
          ? Ip(n.minUnit, this.min, this.max, this._getLabelCapacity(s))
          : xB(this, r.length, n.minUnit, this.min, this.max))),
      (this._majorUnit = !i.major.enabled || this._unit === 'year' ? void 0 : wB(this._unit)),
      this.initOffsets(a),
      t.reverse && r.reverse(),
      Fp(this, r, this._majorUnit)
    )
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value))
  }
  initOffsets(t = []) {
    let n = 0,
      i = 0,
      a,
      s
    this.options.offset &&
      t.length &&
      ((a = this.getDecimalForValue(t[0])),
      t.length === 1 ? (n = 1 - a) : (n = (this.getDecimalForValue(t[1]) - a) / 2),
      (s = this.getDecimalForValue(t[t.length - 1])),
      t.length === 1 ? (i = s) : (i = (s - this.getDecimalForValue(t[t.length - 2])) / 2))
    const o = t.length < 3 ? 0.5 : 0.25
    ;(n = Zt(n, 0, o)), (i = Zt(i, 0, o)), (this._offsets = { start: n, end: i, factor: 1 / (n + 1 + i) })
  }
  _generate() {
    const t = this._adapter,
      n = this.min,
      i = this.max,
      a = this.options,
      s = a.time,
      o = s.unit || Ip(s.minUnit, n, i, this._getLabelCapacity(n)),
      r = Ze(a.ticks.stepSize, 1),
      l = o === 'week' ? s.isoWeekday : !1,
      c = io(l) || l === !0,
      u = {}
    let d = n,
      f,
      h
    if (
      (c && (d = +t.startOf(d, 'isoWeek', l)), (d = +t.startOf(d, c ? 'day' : o)), t.diff(i, n, o) > 1e5 * r)
    )
      throw new Error(n + ' and ' + i + ' are too far apart with stepSize of ' + r + ' ' + o)
    const v = a.ticks.source === 'data' && this.getDataTimestamps()
    for (f = d, h = 0; f < i; f = +t.add(f, r, o), h++) Dp(u, f, v)
    return (
      (f === i || a.bounds === 'ticks' || h === 1) && Dp(u, f, v),
      Object.keys(u)
        .sort(Lp)
        .map((g) => +g)
    )
  }
  getLabelForValue(t) {
    const n = this._adapter,
      i = this.options.time
    return i.tooltipFormat ? n.format(t, i.tooltipFormat) : n.format(t, i.displayFormats.datetime)
  }
  format(t, n) {
    const a = this.options.time.displayFormats,
      s = this._unit,
      o = n || a[s]
    return this._adapter.format(t, o)
  }
  _tickFormatFunction(t, n, i, a) {
    const s = this.options,
      o = s.ticks.callback
    if (o) return pt(o, [t, n, i], this)
    const r = s.time.displayFormats,
      l = this._unit,
      c = this._majorUnit,
      u = l && r[l],
      d = c && r[c],
      f = i[n],
      h = c && d && f && f.major
    return this._adapter.format(t, a || (h ? d : u))
  }
  generateTickLabels(t) {
    let n, i, a
    for (n = 0, i = t.length; n < i; ++n) (a = t[n]), (a.label = this._tickFormatFunction(a.value, n, t))
  }
  getDecimalForValue(t) {
    return t === null ? NaN : (t - this.min) / (this.max - this.min)
  }
  getPixelForValue(t) {
    const n = this._offsets,
      i = this.getDecimalForValue(t)
    return this.getPixelForDecimal((n.start + i) * n.factor)
  }
  getValueForPixel(t) {
    const n = this._offsets,
      i = this.getDecimalForPixel(t) / n.factor - n.end
    return this.min + i * (this.max - this.min)
  }
  _getLabelSize(t) {
    const n = this.options.ticks,
      i = this.ctx.measureText(t).width,
      a = oi(this.isHorizontal() ? n.maxRotation : n.minRotation),
      s = Math.cos(a),
      o = Math.sin(a),
      r = this._resolveTickFontOptions(0).size
    return { w: i * s + r * o, h: i * o + r * s }
  }
  _getLabelCapacity(t) {
    const n = this.options.time,
      i = n.displayFormats,
      a = i[n.unit] || i.millisecond,
      s = this._tickFormatFunction(t, 0, Fp(this, [t], this._majorUnit), a),
      o = this._getLabelSize(s),
      r = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1
    return r > 0 ? r : 1
  }
  getDataTimestamps() {
    let t = this._cache.data || [],
      n,
      i
    if (t.length) return t
    const a = this.getMatchingVisibleMetas()
    if (this._normalized && a.length) return (this._cache.data = a[0].controller.getAllParsedValues(this))
    for (n = 0, i = a.length; n < i; ++n) t = t.concat(a[n].controller.getAllParsedValues(this))
    return (this._cache.data = this.normalize(t))
  }
  getLabelTimestamps() {
    const t = this._cache.labels || []
    let n, i
    if (t.length) return t
    const a = this.getLabels()
    for (n = 0, i = a.length; n < i; ++n) t.push(Op(this, a[n]))
    return (this._cache.labels = this._normalized ? t : this.normalize(t))
  }
  normalize(t) {
    return v_(t.sort(Lp))
  }
}
ke(Nr, 'id', 'time'),
  ke(Nr, 'defaults', {
    bounds: 'data',
    adapters: {},
    time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: 'millisecond', displayFormats: {} },
    ticks: { source: 'auto', callback: !1, major: { enabled: !1 } }
  })
function Ll(e, t, n) {
  let i = 0,
    a = e.length - 1,
    s,
    o,
    r,
    l
  n
    ? (t >= e[i].pos && t <= e[a].pos && ({ lo: i, hi: a } = Yi(e, 'pos', t)),
      ({ pos: s, time: r } = e[i]),
      ({ pos: o, time: l } = e[a]))
    : (t >= e[i].time && t <= e[a].time && ({ lo: i, hi: a } = Yi(e, 'time', t)),
      ({ time: s, pos: r } = e[i]),
      ({ time: o, pos: l } = e[a]))
  const c = o - s
  return c ? r + ((l - r) * (t - s)) / c : r
}
class lf extends Nr {
  constructor(t) {
    super(t), (this._table = []), (this._minPos = void 0), (this._tableRange = void 0)
  }
  initOffsets() {
    const t = this._getTimestampsForTable(),
      n = (this._table = this.buildLookupTable(t))
    ;(this._minPos = Ll(n, this.min)),
      (this._tableRange = Ll(n, this.max) - this._minPos),
      super.initOffsets(t)
  }
  buildLookupTable(t) {
    const { min: n, max: i } = this,
      a = [],
      s = []
    let o, r, l, c, u
    for (o = 0, r = t.length; o < r; ++o) (c = t[o]), c >= n && c <= i && a.push(c)
    if (a.length < 2)
      return [
        { time: n, pos: 0 },
        { time: i, pos: 1 }
      ]
    for (o = 0, r = a.length; o < r; ++o)
      (u = a[o + 1]),
        (l = a[o - 1]),
        (c = a[o]),
        Math.round((u + l) / 2) !== c && s.push({ time: c, pos: o / (r - 1) })
    return s
  }
  _generate() {
    const t = this.min,
      n = this.max
    let i = super.getDataTimestamps()
    return (
      (!i.includes(t) || !i.length) && i.splice(0, 0, t),
      (!i.includes(n) || i.length === 1) && i.push(n),
      i.sort((a, s) => a - s)
    )
  }
  _getTimestampsForTable() {
    let t = this._cache.all || []
    if (t.length) return t
    const n = this.getDataTimestamps(),
      i = this.getLabelTimestamps()
    return (
      n.length && i.length ? (t = this.normalize(n.concat(i))) : (t = n.length ? n : i),
      (t = this._cache.all = t),
      t
    )
  }
  getDecimalForValue(t) {
    return (Ll(this._table, t) - this._minPos) / this._tableRange
  }
  getValueForPixel(t) {
    const n = this._offsets,
      i = this.getDecimalForPixel(t) / n.factor - n.end
    return Ll(this._table, i * this._tableRange + this._minPos, !0)
  }
}
ke(lf, 'id', 'timeseries'), ke(lf, 'defaults', Nr.defaults)
var kB = Object.freeze({
  __proto__: null,
  CategoryScale: af,
  LinearScale: sf,
  LogarithmicScale: of,
  RadialLinearScale: qo,
  TimeScale: Nr,
  TimeSeriesScale: lf
})
const CB = [E5, r4, tB, kB]
xi.register(...CB)
const ix = (e) => (Ea('data-v-9286d2be'), (e = e()), La(), e),
  MB = ix(() => z('div', { class: 'title' }, [z('h3', null, 'STATISTICS')], -1)),
  AB = { class: 'actions' },
  PB = { class: 'download' },
  TB = { class: 'stats' },
  VB = { class: 'numbers' },
  EB = { class: 'locked-stats' },
  LB = { class: 'unlocked-stats' },
  OB = { class: 'btn' },
  IB = ix(() =>
    z(
      'div',
      { class: 'charts' },
      [
        z('div', { class: 'phone-makes' }, [z('canvas', { id: 'myChart' })]),
        z('br'),
        z('div', { class: 'locked' }, [z('canvas', { id: 'lockedPhones' })])
      ],
      -1
    )
  ),
  DB = hn({
    __name: 'Numbers',
    setup(e) {
      te([]), te(!0)
      const n = te([]),
        i = te({ locked: 0, unlocked: 0, distribution: [] }),
        a = te([]),
        s = te(!1)
      te(!1),
        tn(async () => {
          var h
          let r = await ar({ getStats: !0 }),
            l = await ar({ locked: !0, $limit: 0 }),
            c = await ar({ locked: !1, $limit: 0 })
          ;(i.value.locked = l.total),
            (i.value.unlocked = c.total),
            (n.value =
              (h = r == null ? void 0 : r.data) == null
                ? void 0
                : h.map((v) => ({ model: v.make, count: v.count })))
          const u = document.getElementById('myChart')
          new xi(u, {
            type: 'bar',
            data: {
              labels: n.value.map((v) => v.model),
              datasets: [
                { label: 'Phone make distribution', data: n.value.map((v) => v.count), borderWidth: 0.5 }
              ]
            },
            options: { scales: { y: { beginAtZero: !0 } } }
          })
          const d = document.getElementById('lockedPhones'),
            f = [
              { state: 'UnLocked', count: c.total },
              { state: 'Locked', count: l.total }
            ]
          ;(a.value = f),
            new xi(d, {
              type: 'pie',
              data: {
                labels: a.value.map((v) => v.state),
                datasets: [{ label: '# of Unlocked', data: a.value.map((v) => v.count), borderWidth: 0.5 }]
              },
              options: { scales: { y: { beginAtZero: !0 } } }
            })
        })
      const o = async () => {
        const r = n.value.map((l, c) => ({ No: c + 1, Make: l.model, Count: l.count }))
        nu(r, 'numbers')
      }
      return (r, l) => {
        const c = Se('v-progress-linear'),
          u = Se('v-divider'),
          d = Se('v-btn'),
          f = Se('v-col'),
          h = Se('v-row')
        return (
          Re(),
          et(
            Oe,
            null,
            [
              s.value
                ? (Re(), Ct(c, { key: 0, class: 'loader', indeterminate: '', color: 'cyan' }))
                : ct('', !0),
              MB,
              m(u, { color: 'success' }),
              z('div', AB, [
                z('div', PB, [
                  m(
                    d,
                    { color: 'grey', onClick: o, 'prepend-icon': 'mdi-cloud' },
                    { default: we(() => [nt('Dowload')]), _: 1 }
                  )
                ]),
                z('div', TB, [
                  z('div', VB, [
                    z('p', null, [nt('TOTAL: '), z('b', null, ze(i.value.locked + i.value.unlocked), 1)])
                  ]),
                  z('div', EB, [z('p', null, [nt('LOCKED: '), z('b', null, ze(i.value.locked), 1)])]),
                  z('div', LB, [z('p', null, [nt('UNLOCKED: '), z('b', null, ze(i.value.unlocked), 1)])])
                ]),
                z('div', OB, [
                  m(
                    d,
                    { color: 'green', 'prepend-icon': 'bin' },
                    { default: we(() => [nt('Refresh')]), _: 1 }
                  )
                ])
              ]),
              m(
                h,
                { class: 'mb-6', 'no-gutters': '' },
                {
                  default: we(() => [
                    m(f, { cols: 1 }),
                    m(f, { cols: 9 }, { default: we(() => [IB]), _: 1 }),
                    m(f, { cols: 1 })
                  ]),
                  _: 1
                }
              )
            ],
            64
          )
        )
      }
    }
  })
const FB = Oi(DB, [['__scopeId', 'data-v-9286d2be']]),
  RB = eE({
    history: yV('/'),
    routes: [
      { path: '/', name: 'home', component: gI },
      { path: '/devices', name: 'devices', component: RI },
      { path: '/lock-history', name: 'lockHistory', component: XI },
      { path: '/queued-sms', name: 'queuedSms', component: tD },
      { path: '/sent-sms', name: 'sentSMs', component: fD },
      { path: '/reminders', name: 'Reminders', component: _D },
      { path: '/charts', name: 'chart', component: FB }
    ]
  }),
  BB = by({ components: HT, directives: qT, ssr: !0, icons: { defaultSet: 'mdi', aliases: ZT } }),
  lu = XS(oE)
lu.use(eV())
lu.use(RB)
lu.use(BB)
lu.mount('#app')
